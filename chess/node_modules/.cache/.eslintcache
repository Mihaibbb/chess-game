[{"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/index.js":"1","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/reportWebVitals.js":"2","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/App.js":"3","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Classic.jsx":"4","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Home.jsx":"5","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Computer.jsx":"6","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Tutorial.jsx":"7","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Online.jsx":"8","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Practice.jsx":"9","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Lessons.jsx":"10","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/RightSide.jsx":"11","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Header.jsx":"12","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/LeftSide.jsx":"13","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Board.jsx":"14","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/ComputerBoard.jsx":"15","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/OnlineBoard.jsx":"16","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/PracticeBoard.jsx":"17","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/PreviousButton.jsx":"18","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/ResetButton.jsx":"19","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/OnlineSocket.jsx":"20"},{"size":507,"mtime":1656604974979,"results":"21","hashOfConfig":"22"},{"size":362,"mtime":1656604974979,"results":"23","hashOfConfig":"22"},{"size":4877,"mtime":1656604974969,"results":"24","hashOfConfig":"22"},{"size":2687,"mtime":1656604974970,"results":"25","hashOfConfig":"22"},{"size":15630,"mtime":1656604974970,"results":"26","hashOfConfig":"22"},{"size":2006,"mtime":1656604974970,"results":"27","hashOfConfig":"22"},{"size":8731,"mtime":1656604974971,"results":"28","hashOfConfig":"22"},{"size":4850,"mtime":1656604974970,"results":"29","hashOfConfig":"22"},{"size":1608,"mtime":1656604974971,"results":"30","hashOfConfig":"22"},{"size":321,"mtime":1656604974970,"results":"31","hashOfConfig":"22"},{"size":7824,"mtime":1656604974971,"results":"32","hashOfConfig":"22"},{"size":3130,"mtime":1656604974970,"results":"33","hashOfConfig":"22"},{"size":5570,"mtime":1656604974970,"results":"34","hashOfConfig":"22"},{"size":64754,"mtime":1656604974970,"results":"35","hashOfConfig":"22"},{"size":75541,"mtime":1656604974970,"results":"36","hashOfConfig":"22"},{"size":61888,"mtime":1656604974971,"results":"37","hashOfConfig":"22"},{"size":79548,"mtime":1656604974971,"results":"38","hashOfConfig":"22"},{"size":475,"mtime":1656604974971,"results":"39","hashOfConfig":"22"},{"size":1223,"mtime":1656604974971,"results":"40","hashOfConfig":"22"},{"size":814,"mtime":1656604974971,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1oexa2v",{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"55","messages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60"},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66"},{"filePath":"67","messages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69"},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77"},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80"},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83"},{"filePath":"84","messages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91"},{"filePath":"92","messages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/index.js",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/reportWebVitals.js",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/App.js",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Classic.jsx",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Home.jsx",["94"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faUser, faRobot, faCheck, faAngleDown, faWifi, faChessBoard } from '@fortawesome/free-solid-svg-icons';\r\n\r\nimport Header from \"./Header\";\r\nimport black_queen from \"../image/black_queen.png\";\r\nimport white_queen from \"../image/white_queen.png\";\r\nimport half_queen from \"../image/half_queen.png\";\r\nimport '../styles/game-modes.css';\r\nimport selectS from \"../sounds/select.mp3\";\r\nimport clickS from \"../sounds/click.mp3\";\r\n\r\nexport default function Home({id, getColor, getDifficulty}) {\r\n\r\n    // Update 1\r\n    if (localStorage.length !== 0) {\r\n        for (let i = 0, len = localStorage.length; i < len; i++) {\r\n            const key = localStorage.key(i);\r\n            if (key === null) continue;\r\n            if (key.search(\"computer-\") === -1 && key.search(\"player\") === -1 && key.search(\"opponent\") === -1 && key !== 'language' && key.search(\"classic-\") === -1) localStorage.removeItem(key);\r\n            if (key.search(\"online-\") !== -1) localStorage.removeItem(key);\r\n        }\r\n    }\r\n\r\n    const [stop, setStop] = useState(false);\r\n    const [clickStop, setClickStop] = useState(false);\r\n    const [computerColor, setComputerColor] = useState(null);\r\n    const [lang, setLang] = useState(localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\");\r\n\r\n    const inputLinkRef = useRef(null);\r\n    const copyButtonRef = useRef(null);\r\n    const copyIconRef = useRef(null);\r\n    const colorButtons = useRef([]);\r\n    const difficultiesRef = useRef();\r\n    const difficultyRef = useRef();\r\n\r\n    const selectSound = new Audio(selectS);\r\n    const pointSound = new Audio(clickS);\r\n\r\n    const hoverSound = () => {\r\n        selectSound.pause();\r\n        selectSound.currentTime = 0;\r\n        selectSound.play();\r\n    };\r\n\r\n    const copyLink = (e) => {\r\n        setClickStop(false);\r\n        inputLinkRef?.current.select();\r\n        inputLinkRef?.current.setSelectionRange(0, 1000);\r\n\r\n        navigator.clipboard.writeText(inputLinkRef?.current.value);\r\n        copyButtonRef?.current.classList.add(\"sent\");\r\n        \r\n        setTimeout(() => copyButtonRef?.current.firstChild.classList.add('rotate'), 400);\r\n        // copyButtonRef?.current.addEventListener('transitionend', () => {\r\n        //     copyButtonRef?.current.classList.add('rotate');\r\n        // });\r\n\r\n        setTimeout(() => {\r\n            inputLinkRef?.current.blur();\r\n            setClickStop(true);\r\n        }, 150);\r\n    };\r\n\r\n    const clickSound = (path) => {\r\n        if (path === `/${id}` && (stop || !clickStop)) return;\r\n        pointSound.pause();\r\n        pointSound.currentTime = 0;\r\n        pointSound.play();\r\n        pointSound.addEventListener('ended', () => {\r\n            if (path === `/${id}`) {\r\n                localStorage.removeItem(\"board\");\r\n                localStorage.removeItem(\"current-move\")\r\n            }\r\n            window.location.href = path;\r\n        });\r\n    \r\n    };  \r\n\r\n    const playComputer = (e, color) => {\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('piece-button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n        setComputerColor(color);\r\n        getColor(color, \"computer-\");\r\n        // window.location.href = `${window.location.href}computer`;\r\n        [...newTarget.parentElement.childNodes].forEach(childNode => {\r\n            childNode.classList.remove('clicked');\r\n        });\r\n        newTarget.classList.add('clicked');\r\n    };\r\n\r\n    const playClassic = (e, color) => {\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('piece-button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n       \r\n        getColor(color, \"classic-\");\r\n        // window.location.href = `${window.location.href}computer`;\r\n        [...newTarget.parentElement.childNodes].forEach(childNode => {\r\n            childNode.classList.remove('clicked');\r\n        });\r\n        newTarget.classList.add('clicked');\r\n    };\r\n\r\n    const playOnline = (e, color) => {\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('piece-button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n        \r\n        getColor(color, \"online-\");\r\n        // window.location.href = `${window.location.href}computer`;\r\n        [...newTarget.parentElement.childNodes].forEach(childNode => {\r\n            childNode.classList.remove('clicked');\r\n        });\r\n        newTarget.classList.add('clicked');\r\n    };\r\n\r\n    const startComputerGame = () => {\r\n        console.log(computerColor);\r\n        // window.location.href = `${window.location.href}computer`;\r\n    };\r\n\r\n    const changeDifficulty = (e) => {\r\n        const difficulty = e.target.innerText.toLowerCase();\r\n        e.target.parentElement.childNodes.forEach(child => child.classList.remove('active'));\r\n        e.target.classList.add('active');\r\n        getDifficulty(difficulty);\r\n    };\r\n\r\n    const languageCallback = (language) => {\r\n        setLang(language);\r\n    };\r\n\r\n    useEffect(() => localStorage.setItem(\"language\", JSON.stringify(lang)), [lang]);\r\n\r\n    return (\r\n        <div className=\"container\">\r\n\r\n            <Header languageCallback={languageCallback}/>\r\n\r\n            <div className=\"home-content\">\r\n             \r\n                <div className=\"classic-mode game-mode\" onMouseEnter={() => hoverSound()} >\r\n                    <div className=\"title\">\r\n                        <h2>{lang === \"en\" ? \"Classic\" : lang === \"ro\" ? \"Clasic\" : \"Klasszikus\"}</h2>\r\n    \r\n                        <div className=\"icon\">\r\n                            <FontAwesomeIcon \r\n                                icon={faUser} \r\n                                color=\"#fff\"\r\n                                className=\"mode-icon\"\r\n                            />\r\n\r\n                            <FontAwesomeIcon \r\n                                className=\"mode-icon board-icon\"\r\n                                icon={faChessBoard}\r\n                            />\r\n\r\n                            <FontAwesomeIcon \r\n                            icon={faUser} \r\n                                color=\"#fff\"\r\n                                className=\"mode-icon\"\r\n                            />\r\n\r\n                        </div>\r\n                    </div>\r\n\r\n                    <div className=\"colors\">\r\n                        <div className=\"white piece-button clicked\" onClick={(e) => playClassic(e, 1)}>\r\n                            <img src={white_queen} className=\"color-img\" alt=\"white color play\"/>\r\n                        </div>\r\n                        <div className=\"black piece-button\" onClick={(e) => playClassic(e, -1)} >\r\n                            <img src={black_queen} className=\"color-img\" alt=\"black color play\"/>\r\n                        </div>\r\n                        <div className=\"random piece-button\" onClick={(e) => playClassic(e, Math.random() < 0.5 ? 1 : -1)}>\r\n                            <img src={half_queen} className=\"color-img\" alt=\"random color play\"/>\r\n                        </div>\r\n                    </div>\r\n\r\n                    <div></div>\r\n\r\n                    <div></div>\r\n\r\n                    <div className=\"start\">\r\n                            <button className=\"start-button\" onClick={() => clickSound(`/classic`)}>{lang === \"en\" ? \"Start game!\" : lang === \"ro\" ? \"Incepe jocul!\" : \"Játék kezdése!\"}</button>\r\n                    </div>\r\n    \r\n                </div>\r\n                \r\n                <div className=\"online-mode game-mode\" onMouseEnter={() => hoverSound()}>\r\n                    \r\n                    <div className=\"title\">\r\n                        <h2>Online</h2>\r\n    \r\n                        <div className=\"icon\">\r\n                            <FontAwesomeIcon \r\n                                icon={faUser} \r\n                                color=\"#fff\"\r\n                                className=\"mode-icon\"\r\n                            />\r\n\r\n                            <div className=\"icon-manager\">\r\n                                <FontAwesomeIcon\r\n                                    color=\"#fff\"\r\n                                    icon={faWifi}\r\n                                    className=\"mode-icon wifi\"\r\n                                    size={10}\r\n                                />\r\n                                <FontAwesomeIcon\r\n                                    color=\"#fff\"\r\n                                    icon={faWifi}\r\n                                    className=\"mode-icon\"\r\n                                />\r\n                                \r\n                            </div>\r\n                            <FontAwesomeIcon \r\n                                    icon={faUser} \r\n                                    color=\"#fff\"\r\n                                    className=\"mode-icon\"\r\n                            />\r\n                             \r\n                        </div>\r\n    \r\n                        \r\n                    </div>      \r\n                    <div className=\"colors\">\r\n                        <div className=\"white piece-button clicked\" onClick={(e) => playOnline(e, 1)}>\r\n                            <img src={white_queen} className=\"color-img\" alt=\"white color play\"/>\r\n                        </div>\r\n                        <div className=\"black piece-button\" onClick={(e) => playOnline(e, -1)} >\r\n                            <img src={black_queen} className=\"color-img\" alt=\"black color play\"/>\r\n                        </div>\r\n                        <div className=\"random piece-button\" onClick={(e) => playOnline(e, Math.random() < 0.5 ? 1 : -1)}>\r\n                            <img src={half_queen} className=\"color-img\" alt=\"random color play\"/>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"link-container\">\r\n                        <p className=\"link-text\">{lang === \"en\" ? \"Invite your friend to a match:\" : lang === \"ro\" ? \"Invită-ți prietenul la un meci:\" : \"Hívd meg a barátodat egy meccsre\"} </p>\r\n                        \r\n                        <div className=\"link\">\r\n                            <label htmlFor=\"link-input\">\r\n                                <input type=\"text\" className=\"link-input\" value={`${window.location.href}${id}`} ref={inputLinkRef} onFocus={e => setStop(true)} onBlur={e => setStop(false)} readOnly/>\r\n                            </label>\r\n    \r\n                            <div className=\"copy-button\" onClick={(e) => copyLink(e)} ref={copyButtonRef}>\r\n                                <FontAwesomeIcon \r\n                                    icon={faCheck}\r\n                                    className=\"fa copy-icon\"\r\n                                    ref={copyIconRef}\r\n                                />\r\n                                \r\n                            </div>\r\n                        </div>\r\n                        \r\n                    </div>\r\n\r\n                    <div className=\"icon\"></div>\r\n    \r\n                    {/* <div className=\"icon\">\r\n                        \r\n                    </div>\r\n    \r\n                    <div className=\"icon\">\r\n                        \r\n                    </div> */}\r\n\r\n                    <div className=\"start\">\r\n                        <button className=\"start-button\" onClick={() => clickSound(`/${id}`)}>{lang === \"en\" ? \"Start game!\" : lang === \"ro\" ? \"Incepe jocul!\" : \"Játék kezdése!\"}</button>\r\n                    </div>\r\n                    \r\n                </div>\r\n    \r\n                <div className=\"computer-mode game-mode\" onMouseEnter={() => hoverSound()}>\r\n                    <div className=\"title\">\r\n                            <h2>{lang === \"en\" ? \"Computer\" : lang === \"ro\" ? \"Calculator\" : \"Számítógép\"} </h2>\r\n    \r\n                            <div className=\"icon\">\r\n                                <FontAwesomeIcon \r\n                                    icon={faUser} \r\n                                    color=\"#fff\"\r\n                                    className=\"mode-icon\"\r\n                                />\r\n\r\n                                <FontAwesomeIcon \r\n                                    className=\"mode-icon board-icon\"\r\n                                    icon={faChessBoard}\r\n                                />\r\n                                \r\n                                <FontAwesomeIcon \r\n                                    className=\"mode-icon\"\r\n                                    icon={faRobot}\r\n                                />\r\n                            </div>\r\n                    </div>\r\n    \r\n                    <div className=\"colors\">\r\n                        <div className=\"white piece-button clicked\" onClick={(e) => playComputer(e, 1)}>\r\n                            <img src={white_queen} className=\"color-img\" alt=\"white color play\"/>\r\n                        </div>\r\n                        <div className=\"black piece-button\" onClick={(e) => playComputer(e, -1)} >\r\n                            <img src={black_queen} className=\"color-img\" alt=\"black color play\"/>\r\n                        </div>\r\n                        <div className=\"random piece-button\" onClick={(e) => playComputer(e, Math.random() < 0.5 ? 1 : -1)}>\r\n                            <img src={half_queen} className=\"color-img\" alt=\"random color play\"/>\r\n                        </div>\r\n                    </div>\r\n                  \r\n                    <div className=\"difficulty-selection\">\r\n                        <div ref={difficultyRef} className=\"difficulty\" onClick={(e) => {\r\n                            difficultiesRef.current.classList.toggle(\"show\");\r\n                            difficultyRef.current.classList.toggle(\"show\");\r\n                        }}>\r\n                            \r\n                            <p>{lang === \"en\" ? \"Choose your difficulty\" : lang === \"ro\" ? \"Alege-ți dificultatea\" : \"Válassza ki a nehézséget\"}</p>\r\n                            <FontAwesomeIcon\r\n                                icon={faAngleDown}\r\n                                color=\"#fff\"\r\n                                className=\"icon\"\r\n                            />\r\n                        </div>\r\n                       \r\n                    </div>\r\n    \r\n                    <div className=\"difficulties\" ref={difficultiesRef}>\r\n                        <div className=\"difficulty active\" onClick={(e) => changeDifficulty(e)}>{lang === \"en\" ? \"Easy\" : lang === \"ro\" ? \"Uşor\" : \"Könnyen\"}</div>\r\n                        <div className=\"difficulty\" onClick={(e) => changeDifficulty(e)}>{lang === \"en\" ? \"Medium\" : lang === \"ro\" ? \"Mediu\" : \"Közepes\"}</div>\r\n                        <div className=\"difficulty\" onClick={(e) => changeDifficulty(e)}>{lang === \"en\" ? \"Hard\" : lang === \"ro\" ? \"Greu\" : \"Kemény\"}</div>\r\n                        {/* <div className=\"difficulty\" onClick={(e) => changeDifficulty(e)}>Very Hard</div> */}\r\n                    </div>\r\n    \r\n                    <div className=\"start\">\r\n                        <Link to=\"/computer\">\r\n                            <button className=\"start-button\" onClick={() => startComputerGame()}>{lang === \"en\" ? \"Start game!\" : lang === \"ro\" ? \"Incepe jocul!\" : \"Játék kezdése!\"}</button>\r\n                        </Link>\r\n                        \r\n                    </div>\r\n                    \r\n                </div>\r\n \r\n            </div>\r\n        </div>\r\n        \r\n    );\r\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Computer.jsx",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Tutorial.jsx",["95","96","97"],"import React, {useState, useEffect, useRef} from \"react\";\nimport Header from \"./Header\";\nimport tutorialJson from \"../json/tutorial.json\";\n\nimport \"../styles/tutorial.css\";\nimport PracticeBoard from \"./PracticeBoard\";\nimport Board from \"./Board\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faAngleLeft, faAngleRight } from \"@fortawesome/free-solid-svg-icons\";\n\n\nexport default function Tutorial() {\n\n    const chapters = tutorialJson.modules;\n\n    const [lang, setLang] = useState(localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\");\n    const [content, setContent] = useState(null);\n    const [currChapter, setCurrChapter] = useState(Object.values(chapters)[0].chapters);\n    const [currChapterName, setCurrChapterName] = useState(Object.values(chapters)[0][`title_${lang}`]);\n    const [currSubChapterName, setCurrSubChapterName] = useState(null);\n    const [currSubChapter, setCurrSubChapter] = useState(null);\n    const [currChapterIdx, setCurrChapterIdx] = useState(0);\n    const [currSubChapterIdx, setCurrSubChapterIdx] = useState(0);\n\n    const chaptersRef = useRef();\n\n    useEffect(() => {\n        if (localStorage.length !== 0) {\n            for (let i = 0, len = localStorage.length; i < len; i++) {\n                const key = localStorage.key(i);\n                if (key === null) continue;\n                if (key.search(\"classic-\") !== -1) localStorage.removeItem(key);\n            }\n        }\n    }, []);\n\n    useEffect(() => console.log(currChapter), [currChapter]);\n\n    const stopTimer = () => {\n\n    };\n\n    const nextLesson = () => {\n        const newSubChapterIdx =  currSubChapterIdx + 1;\n        if (newSubChapterIdx < Object.values(currChapter).length) {\n            setCurrSubChapter(Object.values(currChapter)[newSubChapterIdx].description);\n            setCurrSubChapterIdx(newSubChapterIdx);\n            setCurrSubChapterName(Object.values(currChapter)[newSubChapterIdx][`title_${lang}`]);\n            return;\n        }\n\n        const newChapterIdx = currChapterIdx + 1;\n        const newChapter = Object.values(chapters)[newChapterIdx];\n        const newSubChapter = Object.values(newChapter.chapters)[0];\n        setCurrChapterIdx(newChapterIdx);\n        setCurrChapter(newChapter.chapters);\n        setCurrChapterName(newChapter[`title_${lang}`]);\n        setCurrSubChapterIdx(0);\n        setCurrSubChapter(newSubChapter.description);\n        setCurrSubChapterName(newSubChapter[`title_${lang}`]);\n    };\n\n    const backLesson = () => {\n        const newSubChapterIdx =  currSubChapterIdx - 1;\n        if (newSubChapterIdx >= 0) {\n            setCurrSubChapter(Object.values(currChapter)[newSubChapterIdx].description);\n            setCurrSubChapterIdx(newSubChapterIdx);\n            setCurrSubChapterName(Object.values(currChapter)[newSubChapterIdx][`title_${lang}`]);\n            return;\n        }\n\n\n        const newChapterIdx = currChapterIdx - 1;\n        if (newChapterIdx < 0) return;\n        const newChapter = Object.values(chapters)[newChapterIdx];\n        const newSubChapter = Object.values(newChapter.chapters)[Object.values(newChapter.chapters).length - 1];\n        setCurrChapterIdx(newChapterIdx);\n        setCurrChapter(newChapter.chapters);\n        setCurrChapterName(newChapter[`title_${lang}`]);\n        setCurrSubChapterIdx(Object.values(newChapter.chapters).length - 1);\n        setCurrSubChapter(newSubChapter.description);\n        setCurrSubChapterName(newSubChapter[`title_${lang}`]);\n    };\n    \n    return (\n        <div className=\"container\">\n            <Header />\n            <div className=\"banner\">\n                <h2 className=\"center-text\">Tutorial for absolute beginners!</h2>\n            </div>\n\n            <div className=\"content-tutorial\">\n                <div className=\"chapters\">\n                    {Object.values(chapters).map((chapter, idx) => (\n                        <div className=\"chapter\" key={idx} onClick={() => {\n                            chaptersRef.current.classList.remove(\"total_hide\");\n                            chaptersRef.current.classList.remove(\"hide\");\n                           \n                                setCurrChapterIdx(idx);\n                                setCurrSubChapterIdx(0);\n                                setCurrChapter(chapter.chapters);\n                                setCurrChapterName(chapter[`title_${lang}`])\n                                setCurrSubChapter(null);\n                                setCurrSubChapterName(null);\n                            \n                        }}>\n                            <p>{idx + 1}. {chapter[`title_${lang}`]}</p>\n                            <div className=\"tick\"></div>\n                        </div>\n                    ))}\n                </div>\n                \n                <div ref={chaptersRef} className={`description-tutorial`}>\n                    <h2 className=\"chapter-title\">{currChapterName}</h2>\n                    <div className=\"chapter-content\">\n                        {Object.values(currChapter).map((chapter, idx) => (\n                            <div className=\"content-text\" key={idx} onClick={(e) => {\n                                chaptersRef.current.classList.add(\"hide\");\n                                chaptersRef.current.addEventListener(\"transitionend\", () => {\n                                    chaptersRef.current.classList.add(\"total_hide\");\n                                    setCurrSubChapterName(chapter[`title_${lang}`]);\n                                    setCurrSubChapter(chapter.description);\n                                    setCurrSubChapterIdx(idx);\n                                });\n                            }}>\n                                <p className=\"subchapter-title\">{chapter[`title_${lang}`]}</p>\n                            </div>\n                        ))}\n                    </div>\n                </div>\n\n                <div className={`subchapter-description ${currSubChapter ? \"show\" : null}`}>\n                    <div className=\"subchapter-title\">{currSubChapterName}</div>\n                   \n                        {currSubChapter && (\n                            <div className=\"subchapter-content\">\n                                <p className=\"description\">{currSubChapter[`text_${lang}`]}</p>\n                                {currSubChapter[`text_2_${lang}`] && (\n                                    <p className=\"description\">{currSubChapter[`text_2_${lang}`]}</p>\n                                )}\n                                \n                                <div className=\"board-container-lesson\">\n                                    {currSubChapter.board === \"classic\" ? (\n                                        <Board color={1} stopTimer={stopTimer} lesson={true}/>\n                                    ) : currSubChapter.board === \"practice\" ? (\n                                        <PracticeBoard pieceCode={currSubChapter.pieceCode} lesson={true} />\n                                    ) : null}       \n                                </div>\n\n                                <div className=\"lesson-buttons\">\n                                    {(currChapterIdx - 1 >= 0 || currSubChapterIdx - 1 >= 0) && <button className=\"previous-lesson\" type=\"click\" onClick={() => backLesson()}>\n                                        <h3> <FontAwesomeIcon \n                                                icon={faAngleLeft}\n                                                color=\"#fff\"\n                                                className=\"prev-icon\"\n                                            />\n                                            Previous lesson \n                                        </h3>\n                                    </button>}\n                                    {(currChapterIdx + 1 < Object.values(chapters).length || currSubChapterIdx + 1 < Object.values(Object.values(chapters)[currChapterIdx]).length)&& <button className=\"next-lesson\" type=\"click\" onClick={() => nextLesson()}>\n                                        <h3>Next lesson \n                                            <FontAwesomeIcon \n                                                icon={faAngleRight}\n                                                color=\"#fff\"\n                                                className=\"next-icon\"\n                                            />\n                                        </h3>\n                                    </button>}\n                                </div>\n\n                                \n                            </div>\n                        )}\n                    \n                </div>\n            </div>\n        </div>\n    );\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Online.jsx",["98","99","100","101","102","103","104","105","106"],"import React, {useState, useEffect } from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport io from \"socket.io-client\";\n\nimport Board from './Board';\nimport OnlineBoard from \"./OnlineBoard\";\nimport RightSide from \"./RightSide\";\nimport LeftSide from \"./LeftSide\";\nimport Header from \"./Header\";\n\nimport '../styles/home.css';\n\nexport default function Online({ socket }) {\n\n    const { id } = useParams();\n    //const gotColor = localStorage.getItem(\"online-player-color\") ? parseInt(localStorage.getItem(\"online-player-color\")) : 1; \n\n    if (id.length !== 20) window.location.href = \"/\";\n\n    const [color, setColor] = useState(null);\n    const [buttonsTarget, setButtonsTarget] = useState(null);\n    const [random, setRandom] = useState(null);\n    const [done, setDone] = useState(true);\n    const [numberOfPlayers, setNumberOfPlayers] = useState(null);\n    const [lang, setLang] = useState(localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\");\n    const [winner, setWin] = useState(null);\n    const [stopRealTimer, setStopTimer] = useState(false);\n    const [message, setMessage] = useState(\"\");\n\n    let players;\n\n    socket.on(\"rooms\", rooms => {\n        console.log(\"HERE\");\n        const isThisRoom = [...Object.keys(rooms)].filter(room => room == id);\n        console.log(\"NOT FOUND ROOM\", isThisRoom);\n        if (isThisRoom === undefined) {\n           \n            return null;\n        }\n    });\n\n    socket.emit(\"create-room\", id);\n\n    socket.emit(\"get-players\");\n\n    socket.on(\"players\", player => {\n        console.log(player, id, socket.id, JSON.parse(localStorage.getItem(\"socket\")));\n        const ownColor = (localStorage.getItem(\"player\") !== null ? parseInt(localStorage.getItem(\"player\")) : player === 1 ? 1 : -1);\n        setColor(ownColor);\n        console.log(ownColor);\n        if (parseInt(ownColor) === -1) {\n            for (let i = 0; i < localStorage.length; i++) {\n                const key = localStorage.key(i);\n                console.log(key);\n                if (key.search('online-') !== -1) localStorage.removeItem(key);\n            }\n        }\n        \n        if (localStorage.getItem(\"player\") === null) localStorage.setItem(\"player\", player === 1 ? player : -1);\n        \n        setNumberOfPlayers(player);\n        // if (localStorage.getItem(\"id\") === null) localStorage.setItem(\"id\", parseInt(id));\n        // else if (localStorage.getItem(\"id\") !== parseInt(id) && localStorage.length !== 0) {\n        //     localStorage.removeItem(\"id\");\n        //     localStorage.clear();\n        //     // window.location.reload();\n        // }\n    });\n   \n    // if (id != JSON.parse(localStorage.getItem(\"socket\"))) return null;\n    // Request for room's players\n\n    const returnButtonsClick = (e) => {\n\n        let newTarget = e.target;\n\n        while (!newTarget.classList.contains('button')) {\n            newTarget = newTarget.parentElement;\n        }\n\n        setButtonsTarget(newTarget);\n        setRandom(Math.random());\n    };\n\n    useEffect(() => {\n        if (numberOfPlayers === null) return null;\n\n        return (\n            <div className=\"content\">\n                <div className=\"game\">\n                    <LeftSide />\n                    <OnlineBoard color={color} prevButtons={buttonsTarget} random={random} socket={socket} oppId=\"ij3YC-_VZmKbEahoAABH\" players={numberOfPlayers} />\n                    <RightSide clickButton={returnButtonsClick}  onlineGame={true} computerGame={false} stopTimer={parseInt(color) === 1 ? stopRealTimer : !stopRealTimer} time={10} gameEnd={gameEnd} timer={true} players={numberOfPlayers} color={color}/>\n                </div>\n            </div>\n        );\n\n    }, [numberOfPlayers]);\n\n    const languageCallback = (language) => {\n        setLang(language);\n    };\n\n    const gameEnd = (win) => {\n        if (win) {\n            setWin(true);\n            setMessage(\"You win!\");\n            return;\n        } \n        setWin(false);\n        setMessage(\"You lose!\");\n    }\n\n    const stopTimer = (cond) => setStopTimer(cond);\n\n    useEffect(() => localStorage.setItem(\"language\", JSON.stringify(lang)), [lang]);\n\n    \n    return color && (\n        <div className=\"content\">\n            <Header languageCallback={languageCallback} />\n            <div className=\"game\">\n                <LeftSide color={color} online={true} socket={socket} />\n                <OnlineBoard color={color} prevButtons={buttonsTarget} random={random} socket={socket} oppId=\"ij3YC-_VZmKbEahoAABH\" players={numberOfPlayers} stopTimer={stopTimer} />\n                <RightSide clickButton={returnButtonsClick} onlineGame={true} computerGame={false} stopTimer={parseInt(color) === 1 ? stopRealTimer : !stopRealTimer} time={10} gameEnd={gameEnd} timer={true} players={numberOfPlayers} color={color}/>\n            </div>\n        </div>\n    );\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Practice.jsx",["107","108"],"import React, { useState, useEffect, useRef } from \"react\";\n\nimport PracticeBoard from \"./PracticeBoard\";\nimport RightSide from \"./RightSide\";\nimport LeftSide from \"./LeftSide\";\nimport Header from \"./Header\";\n\nimport '../styles/home.css';\n\nexport default function Classic() {\n\n    const [buttonsTarget, setButtonsTarget] = useState(null);\n    const [random, setRandom] = useState(null);\n    const [choosePiece, setChoosePiece] = useState(null);\n    const [deleteIcon, setDeleteIcon] = useState(null);\n\n    const returnButtonsClick = (e) => {\n\n        let newTarget = e.target;\n\n        while (!newTarget.classList.contains('button')) {\n            newTarget = newTarget.parentElement;\n        }\n\n        setButtonsTarget(newTarget);\n        setRandom(Math.random());\n    };\n\n    const handlePieceChoose = (idx) => {\n        console.log(idx)\n        setChoosePiece(idx);\n    };\n\n    const handleDelete = () => setDeleteIcon(Math.random());\n\n    const languageCallback = () => {\n        \n    };\n\n    \n    return (\n        <div className=\"content\">\n            <Header languageCallback={languageCallback}/>\n            <div className=\"game\">\n                <LeftSide practice={true} handlePieceChoose={handlePieceChoose} handleDelete={handleDelete} color={1}/>\n                <PracticeBoard color={1} prevButtons={buttonsTarget} random={random} difficulty=\"very hard\" choosePiece={choosePiece} deleteIcon={deleteIcon} />\n                <RightSide clickButton={returnButtonsClick} practiceGame={true} computerGame={false} onlineGame={false} timer={false}/>\n            </div>\n        </div>\n        \n    );\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Lessons.jsx",["109","110"],"import React, {useState, useEffect} from \"react\";\nimport Header from \"./Header\";\n\nimport \"../styles/lessons.css\";\n\nexport default function Lessons() {\n    return (\n        <div className=\"container\">\n            <Header />\n            <div className=\"banner\">\n                s\n            </div>\n        </div>\n    );\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/RightSide.jsx",["111","112"],"import React, {useEffect, useState} from \"react\";\r\nimport { faArrowLeft, faArrowRight } from '@fortawesome/free-solid-svg-icons';\r\n\r\nimport ResetButton from './ResetButton';\r\nimport PreviousButton from \"./PreviousButton\";\r\n\r\nimport '../styles/right-side.css';\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\n\r\nexport default function RightSide({clickButton, onlineGame, computerGame, practiceGame, empty, stopTimer, time, gameEnd, timer, players, color}) {\r\n\r\n \r\n    console.log(stopTimer);\r\n    const [upTimerMinutes, setUpTimerMinutes] = useState(onlineGame ? (localStorage.getItem(\"online-opponent-minutes\") ? localStorage.getItem(\"online-opponent-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-opponent-minutes\") ? localStorage.getItem(\"computer-opponent-minutes\") : time) : (localStorage.getItem(\"opponent-minutes\") ? localStorage.getItem(\"opponent-minutes\") : time));\r\n    const [upTimerSeconds, setUpTimerSeconds] = useState(onlineGame ? (localStorage.getItem(\"online-opponent-seconds\") ? localStorage.getItem(\"online-opponent-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-opponent-seconds\") ? localStorage.getItem(\"computer-opponent-seconds\") : 0) : (localStorage.getItem(\"opponent-seconds\") ? localStorage.getItem(\"opponent-seconds\") : 0));\r\n    const [downTimerMinutes, setDownTimerMinutes] = useState(onlineGame ? (localStorage.getItem(\"online-player-minutes\") ? localStorage.getItem(\"online-player-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-player-minutes\") ? localStorage.getItem(\"computer-player-minutes\") : time) : (localStorage.getItem(\"player-minutes\") ? localStorage.getItem(\"player-minutes\") : time));\r\n    const [downTimerSeconds, setDownTimerSeconds] = useState(onlineGame ? (localStorage.getItem(\"online-player-seconds\") ? localStorage.getItem(\"online-player-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-player-seconds\") ? localStorage.getItem(\"computer-player-seconds\") : 0) : (localStorage.getItem(\"player-seconds\") ? localStorage.getItem(\"player-seconds\") : 0));\r\n    \r\n    let downTimeSec = onlineGame ? (localStorage.getItem(\"online-player-seconds\") ? localStorage.getItem(\"online-player-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-player-seconds\") ? localStorage.getItem(\"computer-player-seconds\") : 0) : (localStorage.getItem(\"player-seconds\") ? localStorage.getItem(\"player-seconds\") : 0);\r\n    let upTimeSec = onlineGame ? (localStorage.getItem(\"online-opponent-seconds\") ? localStorage.getItem(\"online-opponent-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-opponent-seconds\") ? localStorage.getItem(\"computer-opponent-seconds\") : 0) : (localStorage.getItem(\"opponent-seconds\") ? localStorage.getItem(\"opponent-seconds\") : 0);\r\n    let downTimeMinutes = onlineGame ? (localStorage.getItem(\"online-player-minutes\") ? localStorage.getItem(\"online-player-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-player-minutes\") ? localStorage.getItem(\"computer-player-minutes\") : time) : (localStorage.getItem(\"player-minutes\") ? localStorage.getItem(\"player-minutes\") : time);\r\n    let upTimeMinutes = onlineGame ? (localStorage.getItem(\"online-opponent-minutes\") ? localStorage.getItem(\"online-opponent-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-opponent-minutes\") ? localStorage.getItem(\"computer-opponent-minutes\") : time) : (localStorage.getItem(\"opponent-minutes\") ? localStorage.getItem(\"opponent-minutes\") : time);\r\n    // const setStorage = computerGame ? (localStorage.getItem(\"computer-opponent-minutes\") || localStorage.getItem(\"computer-opponent-seconds\") || localStorage.getItem(\"computer-player-minutes\") || localStorage.getItem(\"computer-player-seconds\")) : (localStorage.getItem(\"opponent-minutes\") || localStorage.getItem(\"opponent-seconds\") || localStorage.getItem(\"player-minutes\") || localStorage.getItem(\"player-seconds\"));\r\n    // console.log(setStorage);\r\n\r\n    const downTimer = () => {\r\n        if (!timer) return;\r\n        if (onlineGame && players < 2) return;\r\n        if (downTimeSec <= 0 && downTimeMinutes <= 0) {\r\n            gameEnd(!color);\r\n            clearInterval(upTimer);\r\n            clearInterval(downTimer);\r\n            return;\r\n        }\r\n\r\n        console.log(stopTimer);\r\n   \r\n        if (downTimeSec <= 0) {\r\n            setDownTimerMinutes(downTime => downTime - 1);\r\n            setDownTimerSeconds(59);\r\n            downTimeSec = 59;\r\n            downTimeMinutes--;\r\n        } else {\r\n            setDownTimerSeconds(downTime => downTime - 1);\r\n            downTimeSec--;\r\n        }\r\n\r\n        if (onlineGame) {\r\n            localStorage.setItem(\"online-player-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"online-player-seconds\", downTimeSec);\r\n        }\r\n        else if (computerGame) {\r\n            localStorage.setItem(\"computer-player-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"computer-player-seconds\", downTimeSec);\r\n        } else {\r\n            localStorage.setItem(\"player-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"player-seconds\", downTimeSec);\r\n        }\r\n        \r\n    };\r\n\r\n    const upTimer = () => {\r\n        if (computerGame) return;\r\n        if (onlineGame && players < 2) return;\r\n        if (upTimeSec <= 0 && upTimeMinutes <= 0) {\r\n            gameEnd(color);\r\n            clearInterval(upTimer);\r\n            clearInterval(downTimer);\r\n            return;\r\n        }\r\n\r\n\r\n        if (upTimeSec <= 0) {\r\n            setUpTimerMinutes(upTime => upTime - 1);\r\n            setUpTimerSeconds(59);\r\n            upTimeSec = 59;\r\n            upTimeMinutes--;\r\n        } else {\r\n            setUpTimerSeconds(upTime => upTime - 1);\r\n            upTimeSec--;\r\n        }\r\n\r\n        if (onlineGame) {\r\n            localStorage.setItem(\"online-opponent-minutes\", upTimeMinutes);\r\n            localStorage.setItem(\"online-opponent-seconds\", upTimeSec);\r\n        }\r\n        else if (computerGame) {\r\n            localStorage.setItem(\"computer-opponent-minutes\", upTimeMinutes);\r\n            localStorage.setItem(\"computer-opponent-seconds\", upTimeSec);\r\n        } else {\r\n            localStorage.setItem(\"opponent-minutes\", upTimeMinutes);\r\n            localStorage.setItem(\"opponent-seconds\", upTimeSec);\r\n        }\r\n       \r\n    };\r\n\r\n    \r\n\r\n    useEffect(() => {\r\n        const interval1 = setInterval(downTimer, 1000);\r\n        const interval2 = setInterval(upTimer, 1000);\r\n        \r\n        if (stopTimer || (onlineGame && players < 2)) clearInterval(interval1);\r\n        else if (!stopTimer) clearInterval(interval2);\r\n\r\n        return () => {\r\n            clearInterval(interval1);\r\n            clearInterval(interval2);\r\n        }\r\n    }, [stopTimer, players]);\r\n    \r\n\r\n    if (empty) return <div></div>;\r\n\r\n    return (\r\n        <div className=\"right-side\">\r\n            <div className={`timer opponent-timer ${parseInt(color) === 1 ? \"black\" : \"white\"} `}>\r\n                {!computerGame && !practiceGame && <h2>{upTimerMinutes < 10 ? `0${upTimerMinutes}` : upTimerMinutes} : {upTimerSeconds < 10 ? `0${upTimerSeconds}` : upTimerSeconds}</h2>}\r\n            </div>\r\n            <ResetButton computerGame={computerGame} />\r\n            <div className=\"prev-next\">\r\n                <PreviousButton icon={faArrowLeft} classDiv=\"prev-button\" clickButton={clickButton}/>\r\n                <PreviousButton icon={faArrowRight} classDiv=\"next-button\" clickButton={clickButton}/>\r\n            </div>\r\n            <div className={`timer my-timer ${parseInt(color) === 1 ? \"white\" : \"black\"} `}>\r\n                {timer && <h2>{downTimerMinutes < 10 ? `0${downTimerMinutes}` : downTimerMinutes} : {downTimerSeconds < 10 ? `0${downTimerSeconds}` : downTimerSeconds}</h2>}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Header.jsx",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/LeftSide.jsx",["113","114"],"import React, { useEffect, useState } from 'react';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen, faTimes, faPaperPlane, faAngleRight } from '@fortawesome/free-solid-svg-icons'; \r\n\r\nimport '../styles/left-side.css';\r\n\r\nconst pieceIcons = {\r\n    1: faChessPawn,\r\n    2: faChessRook,\r\n    3: faChessKnight,\r\n    4: faChessBishop,\r\n    5: faChessQueen,\r\n    6: faChessKing\r\n};\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\n\r\nexport default function LeftSide({practice, handlePieceChoose, handleDelete, color, online, socket}) {\r\n\r\n    const [messages, setMessages] = useState([]);\r\n    const [message, setMessage] = useState(\"\");\r\n\r\n    useEffect(() => {\r\n        if (!online) return;\r\n        socket.on(\"recieve-message\", opponentMessage => {\r\n            console.log(socket.id, opponentMessage);\r\n            setMessages(currMessages => [...currMessages, {\r\n                type: \"opponent\",\r\n                message: opponentMessage \r\n            }]);\r\n        });\r\n    }, []);\r\n\r\n    const getIcons = () => {\r\n        const elements = Object.values(pieceIcons).map((pieceIcon, idx) => {\r\n            return (\r\n                <div className=\"piece-selections\">\r\n                    <div className=\"white-icon icon\" onClick={() => handlePieceChoose(idx + 1)}>\r\n                        <FontAwesomeIcon\r\n                            icon={pieceIcon} \r\n                            className=\"white-piece piece-selection\"\r\n                            color=\"#fff\"\r\n                        />\r\n    \r\n                    </div>\r\n    \r\n                    <div className=\"black-icon icon\" onClick={() => handlePieceChoose(-idx - 1)}>\r\n                        <FontAwesomeIcon\r\n                            icon={pieceIcon} \r\n                            className=\"black-piece piece-selection\"\r\n                            color=\"#000\"\r\n                        />\r\n                        \r\n                    </div>\r\n    \r\n                </div>\r\n            );\r\n        });\r\n    \r\n        return elements;\r\n    };  \r\n\r\n    const sendMessage = () => {\r\n        if (message.trim().length === 0) {\r\n            setMessage(\"\");\r\n            return;\r\n        }\r\n\r\n        setMessages(currMessages => [...currMessages, {\r\n            type: \"player\",\r\n            message: message \r\n        }]);\r\n        socket.emit(\"send-message\", message)\r\n        setMessage(\"\");\r\n        \r\n    };\r\n\r\n\r\n    return (\r\n        <div className=\"left-side\" style={{maxHeight: `${HEIGHT}px`}}>\r\n\r\n            {online && \r\n                <div className=\"chat-container\">\r\n                    <div className=\"title-chat\">\r\n                        <h2>Chat with opponent</h2>\r\n                    </div>\r\n                    <div className=\"messages-container\">\r\n                        {messages.length > 0 && messages.map((message, idx) => (\r\n                            <div className={`message ${message.type === \"player\" ? \"own\" : \"opponent\"} ${parseInt(color) === 1 && message.type === \"player\" ? \"white\" : parseInt(color) === 1 && message.type === \"opponent\" ? \"black\" : parseInt(color) === -1 && message.type === \"player\" ? \"black\" : parseInt(color) === -1 && message.type === \"opponent\" ? \"white\" : null}`} key={idx}>\r\n                                <p>{message.message}</p>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n\r\n                    <div className=\"send-message\">\r\n                        <input \r\n                            type=\"text\" \r\n                            className=\"message-input\" \r\n                            placeholder=\"Type a message here...\" \r\n                            onChange={(e) => setMessage(e.target.value)} \r\n                            onKeyDown={(e) => e.key === \"Enter\" ? sendMessage() : null}\r\n\r\n                            value={message}\r\n                        />\r\n                            \r\n                        <FontAwesomeIcon\r\n                            className=\"send-icon\"\r\n                            icon={faAngleRight}\r\n                            onClick={() => sendMessage()}\r\n                        />\r\n                    </div>\r\n                    \r\n                </div>\r\n            }\r\n\r\n            {practice && (\r\n                <div className=\"pieces\">\r\n                    {getIcons()}\r\n                    <div className=\"delete\" onClick={handleDelete}>\r\n                        <FontAwesomeIcon \r\n                            className=\"delete-icon\"\r\n                            icon={faTimes}\r\n                            color=\"crimson\"\r\n                        />\r\n                        <h2>Delete</h2>\r\n                    </div>\r\n                </div>\r\n                \r\n            )}\r\n            \r\n\r\n            {color === undefined || parseInt(color) === 1? (\r\n                <div className=\"numbers\">\r\n                    <p>8</p>\r\n                    <p>7</p>\r\n                    <p>6</p>\r\n                    <p>5</p>\r\n                    <p>4</p>\r\n                    <p>3</p>\r\n                    <p>2</p>\r\n                    <p>1</p>\r\n                </div>\r\n            ) : (\r\n                <div className=\"numbers\">\r\n                    <p>1</p>\r\n                    <p>2</p>\r\n                    <p>3</p>\r\n                    <p>4</p>\r\n                    <p>5</p>\r\n                    <p>6</p>\r\n                    <p>7</p>\r\n                    <p>8</p>\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/Board.jsx",["115","116","117"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\r\nimport cloneDeep from 'lodash/cloneDeep';\r\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\r\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\r\n\r\nimport '../styles/board.css';\r\n\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\nconst ROWS = 8;\r\nconst COLUMNS = 8;\r\n\r\nexport default function Board({ color, prevButtons, random, stopTimer, winner, lesson, gameEnd }) {\r\n\r\n    const setColor = color;\r\n  \r\n\r\n    const createVirtualBoard = () => {\r\n        let board = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            let row = [];\r\n\r\n            for (let j = 0; j < 8; j++)\r\n                if (i === 1) row.push(-setColor * 1);\r\n                else if (i === 6) row.push(setColor * 1);\r\n                else if (i !== 7 && i !== 0) row.push(0);\r\n\r\n            if (color < 0) {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 6, -setColor * 5, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 6, setColor * 5, setColor * 4, setColor * 3, setColor * 2);    \r\n            } else {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 5, -setColor * 6, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 5, setColor * 6, setColor * 4, setColor * 3, setColor * 2);    \r\n            }         \r\n            board.push(row);\r\n        }\r\n\r\n        return board;\r\n    };\r\n\r\n    const boardRef = useRef(null);\r\n    const squareRef = useRef(null);\r\n    \r\n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"classic-current-move\") === null ? 1 : localStorage.getItem(\"classic-current-move\"));\r\n    const [oldIdx, setOldIdx] = useState(null);\r\n    const [possibleMoves, setPossibleMoves] = useState(null);\r\n    const [activePiece, setActivePiece] = useState(null);\r\n    const [dropPiecer, setActiveDrop] = useState(null);\r\n    const virtualBoard = localStorage.getItem(\"classic-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"classic-board\"));\r\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\r\n    const [previewMoves, setPreviewMoves] = useState([]);\r\n    const [gameRunning, setGameRunning] = useState(true);\r\n    const [pawnTransform, setPawnTransform] = useState(null);\r\n    const [prevMoves, setPrevMoves] = useState(localStorage.getItem(\"classic-prev-moves\") !== null ? JSON.parse(localStorage.getItem(\"classic-prev-moves\")) : []);\r\n    const [nextMoves, setNextMoves] = useState(localStorage.getItem(\"classic-next-moves\") !== null ? JSON.parse(localStorage.getItem(\"classic-next-moves\")) : []);\r\n \r\n    const previewVirtualBoard = useRef(virtualBoard);\r\n    const squareElements = useRef(null);\r\n    const currSquareElement = useRef([]);\r\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\r\n    const rookMoved = useRef({\r\n        \"2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        },\r\n\r\n        \"-2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        }\r\n    });\r\n\r\n    const piecesCode = {\r\n        1: faChessPawn,\r\n        2: faChessRook,\r\n        3: faChessKnight,\r\n        4: faChessBishop,\r\n        5: faChessQueen,\r\n        6: faChessKing\r\n    };\r\n\r\n    const pieceSound = new Audio(pieceMoveSound);\r\n    const pieceCapture = new Audio(pieceCaptureSound);\r\n    pieceCapture.volume = 0.3;\r\n\r\n    console.log(boardRef.current);\r\n\r\n    const minX = boardRef.current?.offsetLeft;\r\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\r\n\r\n    const minY = boardRef.current?.offsetTop;\r\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\r\n\r\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\r\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\r\n\r\n    console.log(squareWidth, squareHeight);\r\n\r\n    // Checking everytime prev/next button is pressed\r\n    \r\n    useEffect(() => {\r\n       \r\n        if (!prevButtons) return;\r\n        if (prevButtons.classList.contains('prev-button') && prevMoves.length === 0) return;\r\n        if (prevButtons.classList.contains('next-button') && nextMoves.length === 0) return;\r\n        \r\n        const lastMove = prevButtons.classList.contains('prev-button') ? prevMoves[prevMoves.length - 1] : nextMoves[nextMoves.length - 1];\r\n        console.log(prevButtons, prevMoves, lastMove.pieceCode);\r\n        const currBoard = cloneDeep(newVirtualBoard);\r\n        const oldX = parseInt(lastMove.oldIdx / 8);\r\n        const oldY = lastMove.oldIdx % 8;\r\n        const newX = parseInt(lastMove.newIdx / 8);\r\n        const newY = lastMove.newIdx % 8;\r\n        currBoard[oldX][oldY] = prevButtons.classList.contains('prev-button') ? lastMove.pieceCode : 0;\r\n        currBoard[newX][newY] = lastMove.oldPieceCode;\r\n    \r\n        setNewVirtualBoard(currBoard);\r\n\r\n        if (prevButtons.classList.contains('prev-button')) {\r\n            const newNextMoves = [...nextMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n            localStorage.setItem(\"classic-prev-moves\", JSON.stringify(prevMoves.slice(0, -1)));\r\n            localStorage.setItem(\"classic-next-moves\", JSON.stringify(newNextMoves));\r\n\r\n            setPrevMoves(prevMoves.slice(0, -1));\r\n            setNextMoves(newNextMoves);\r\n\r\n        } else  {\r\n            console.log('ok from here');\r\n            const newPrevMoves = [...prevMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n\r\n            localStorage.setItem(\"classic-prev-moves\", JSON.stringify(newPrevMoves));\r\n            localStorage.setItem(\"classic-next-moves\", JSON.stringify(nextMoves.slice(0, -1)));\r\n        \r\n            setNextMoves(nextMoves.slice(0, -1));\r\n            setPrevMoves(newPrevMoves);\r\n        }\r\n\r\n        localStorage.setItem(\"classic-current-move\", -currentMove);\r\n        localStorage.setItem(\"classic-board\", JSON.stringify(currBoard));\r\n        \r\n        setCurrentMove(-currentMove);\r\n\r\n    }, [random]);\r\n\r\n    // Function for checking the check \r\n\r\n    const getPossibleMoves = (pieceCode, coords, board) => {\r\n        const piece = Math.abs(pieceCode);\r\n        let possibleMoves = [];\r\n\r\n        // Current coordonates\r\n        const currentX = parseInt(coords / 8);\r\n        const currentY = coords % 8; \r\n\r\n        console.log(currentX, currentY);\r\n\r\n        // Code for pawn\r\n        if (piece === 1) {\r\n\r\n            // Coordonates for possible moves\r\n            const newDiagX = currentX - (pieceCode * setColor);\r\n            const newDiagY = currentY + (pieceCode * setColor);\r\n            const newDiagY2 = currentY - (pieceCode * setColor);\r\n            \r\n            const newCoords = newDiagX * 8 + newDiagY;\r\n            const newCoords2 = newDiagX * 8 + newDiagY2;\r\n            const newFrontCoords = newDiagX * 8 + currentY;\r\n            const frontElement = board[newDiagX] &&\r\n                                 board[newDiagX][currentY] &&\r\n                                 board[newDiagX][currentY];\r\n\r\n            console.log(frontElement);\r\n\r\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\r\n\r\n            console.log(possibleMoves);\r\n            \r\n            const diagonalElement = board[newDiagX] &&\r\n                                    board[newDiagX][newDiagY] &&\r\n                                    board[newDiagX][newDiagY];\r\n\r\n            const diagonalElement2 = board[newDiagX] &&\r\n                                     board[newDiagX][newDiagY2] &&\r\n                                     board[newDiagX][newDiagY2];\r\n            \r\n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\r\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\r\n                console.log(newFrontX);\r\n                const newFrontCoords = newFrontX * 8 + currentY;\r\n\r\n                const newCoordsSquare = board[newFrontX][currentY];\r\n                if (newCoordsSquare === 0 && frontElement === 0) possibleMoves.push(newFrontCoords);\r\n                \r\n            }\r\n\r\n            if (diagonalElement2 !== 0) {\r\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\r\n            }\r\n           \r\n            if (diagonalElement === 0) return possibleMoves;\r\n            \r\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\r\n\r\n        } else if (piece === 2) {\r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    \r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);    \r\n \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                             break;\r\n                        } else possibleMoves.push(newCoords);    \r\n\r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                                           \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n                        \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 3) {\r\n\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 2\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    }\r\n                    else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n        } else if (piece === 4) {\r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n  \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                       \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves, newSquare, board, newX, newY);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 5) {\r\n            console.log(board); \r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);   \r\n                                         \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {   \r\n\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newCoords, possibleMoves);\r\n                    }   \r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            }\r\n            \r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY, pieceCode);\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY);\r\n                    if (newSquare !== undefined) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n        \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                   \r\n                    if (newSquare !== undefined) {\r\n                        console.log(newX, newY);\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 6) {\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY \r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 1\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    } else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n\r\n            // Movement for rocade\r\n            console.log(kingsMoved.current[pieceCode]);\r\n            if (!kingsMoved.current[pieceCode]) {\r\n                console.log('rocade', rookMoved);\r\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\r\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\r\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\r\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\r\n\r\n                const smallRocadeSquare = board[currentX] &&\r\n                                          board[currentX][currentY + 2] &&\r\n                                          board[currentX][currentY + 2];\r\n\r\n                const bigRocadeSquare = board[currentX] &&\r\n                                        board[currentX][currentY - 3] &&\r\n                                        board[currentX][currentY - 3];\r\n\r\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\r\n\r\n                // Checking if the squares between king and rook are empty \r\n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                   \r\n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\r\n                } \r\n\r\n                for (let i = bigRocadeCoords; i < coords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                    console.log('gdjigdfjhh');\r\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\r\n                } \r\n\r\n                console.log(smallRocadeEmpty, bigRocadeEmpty)\r\n\r\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\r\n                    possibleMoves.push({\r\n                        king: smallRocadeCoords,\r\n                        rook: smallRocadeRookCoords,\r\n                        rocade: \"s\"\r\n                    });\r\n                } \r\n\r\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\r\n                    possibleMoves.push({\r\n                        king: bigRocadeCoords,\r\n                        rook: bigRocadeRookCoords,\r\n                        rocade: \"b\"\r\n                    });\r\n                }\r\n\r\n                \r\n\r\n                // possibleMoves.push(smallRocade);\r\n                // possibleMoves.push(bigRocade);\r\n            }\r\n        }\r\n      \r\n        return possibleMoves;\r\n    };\r\n\r\n    const dragPiece = (e, square) => {\r\n        if (lesson) return;\r\n        if (!gameRunning) return;\r\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\r\n\r\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\r\n        const containerElement = element.parentElement;\r\n        console.log(containerElement, square, containerElement.getBoundingClientRect().top);\r\n \r\n        const x = e.clientX - 20 + (lesson ? window.scrollX : 0);\r\n        const y = e.clientY - 20 + (lesson ? window.scrollY : 0);\r\n        console.log(x, y, square, currentMove);\r\n        containerElement.style.position = 'absolute';\r\n        containerElement.style.left = `${x}px`;\r\n        containerElement.style.top = `${y}px`;\r\n        \r\n        setActivePiece(containerElement);\r\n        setActiveDrop(parseInt(containerElement.classList[2]));\r\n        let newTotalCoords;\r\n        currSquareElement.current.forEach((square, idx) => {\r\n            if (square === containerElement.parentElement) newTotalCoords = idx;\r\n        });\r\n\r\n        setOldIdx(newTotalCoords);\r\n\r\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\r\n        console.log(currPossibleMoves, newVirtualBoard, square, currentMove, newTotalCoords);\r\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\r\n        else {\r\n            setPossibleMoves(currPossibleMoves);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                console.log(move, oldPreviewMoves);\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n        \r\n            let newPreviewMoves = [];\r\n            currPossibleMoves.forEach((move, idx) => {\r\n                setTimeout(() => {\r\n                    const currSquare = currSquareElement.current[move];\r\n\r\n                    if (currSquare && currSquare.firstChild == null) {\r\n                        const dotElement = document.createElement('div');\r\n                        dotElement.classList.add('possible-move')\r\n\r\n                        currSquare.appendChild(dotElement);\r\n                        console.log(currSquare);\r\n                        newPreviewMoves.push(currSquare);\r\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\r\n                        currSquare.firstChild.firstChild.classList.add('attacked');\r\n                        newPreviewMoves.push(currSquare);\r\n                    }\r\n                }, idx * 0);\r\n            });\r\n\r\n            setPreviewMoves(newPreviewMoves);\r\n        }\r\n       \r\n    };\r\n    \r\n    const movePiece = e => {\r\n       \r\n        if (!activePiece) return;\r\n        const x = e.clientX - 20 + (lesson ? window.scrollX : 0);\r\n        const y = e.clientY - 20 + (lesson ? window.scrollY : 0);\r\n        activePiece.style.position = 'absolute';\r\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\r\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\r\n        activePiece.style.zIndex = 3;\r\n\r\n        console.log()\r\n\r\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\r\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\r\n        \r\n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\r\n        console.log(squareRef.current);\r\n    };\r\n    \r\n    const dropPiece = (e, pieceCode) => {\r\n        console.log(winner);\r\n        \r\n        if (!activePiece || !squareRef.current || oldIdx === null) return;\r\n        if (!possibleMoves) return;\r\n        setActivePiece(null);\r\n        console.log(squareRef.current?.x, squareRef.current?.y)\r\n        const currentX = squareRef.current?.x;\r\n        const currentY = squareRef.current?.y;\r\n        let rocade = false;\r\n        const idx = currentX * 8 + currentY;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n\r\n        const sameIndex = possibleMoves.find(move => {\r\n            if (typeof move === 'object') rocade = move;\r\n            return idx === (typeof move === 'object' ? move.king : move);\r\n        });\r\n\r\n        activePiece.style.left = 'initial';\r\n        activePiece.style.top= 'initial';\r\n        activePiece.position = 'relative';\r\n        activePiece.style.zIndex = 'initial';\r\n        console.log(previewVirtualBoard.current);\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n        const otherBoard = cloneDeep(previewVirtualBoard.current);\r\n        otherBoard[oldX][oldY] = 0;\r\n        otherBoard[currentX][currentY] = pieceCode; \r\n        previewVirtualBoard.current = otherBoard;\r\n        console.log('afdsokogjfdjjhihijhpjhijhipfghjpifjhpgjhpijhpfgjh', previewVirtualBoard.current);\r\n\r\n        let squaresVirtualBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => squaresVirtualBoard.push(square));\r\n        });\r\n        \r\n        let kingSquare;\r\n\r\n        squaresVirtualBoard.forEach((square, totalIdx) => {\r\n            const iconColor = square && square < 0 ? -1 : 1;\r\n            if (square === currentMove * 6 && !checkOppositeColor(iconColor, currentMove)) kingSquare = totalIdx;\r\n        });  \r\n\r\n        console.log(kingSquare, currentMove);\r\n        const check = checkCheckOptimised(kingSquare, currentMove * 6);\r\n        console.log(check);\r\n\r\n        if (sameIndex !== undefined && !check && winner == null) {  \r\n\r\n            // Sound of piece moving\r\n            pieceSound.play();\r\n\r\n            const squareDOM = currSquareElement.current[idx];\r\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\r\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\r\n            squareRef.current = null;\r\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\r\n            console.log(cloneIcon, prevMoves);\r\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\r\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\r\n                // squareDOM.innerHTML = '';\r\n                pieceSound.pause();\r\n                pieceCapture.play();\r\n            }\r\n    \r\n\r\n            // Piece being moved to new square\r\n            if ((squareDOM && pieceCode === 1 && currentX === 0) || (squareDOM && pieceCode === -1 && currentX === 7)) {\r\n                \r\n                console.log('here'); \r\n                \r\n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\r\n                const leftContainers = containers;  \r\n                console.log(leftContainers);\r\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\r\n                    return (\r\n                        <div \r\n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\r\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\r\n                        >\r\n                            <FontAwesomeIcon \r\n                                icon={piece} \r\n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \r\n                                code={pieceCode}\r\n                                \r\n                            />\r\n                        </div>\r\n                    );\r\n                }) : activePiece;\r\n\r\n                setPawnTransform({\r\n                    idx: idx,\r\n                    elements: elements\r\n                });\r\n\r\n            } else { \r\n                setPawnTransform(null);\r\n            }\r\n\r\n            setPrevMoves([...prevMoves, \r\n                {\r\n                    oldIdx: oldIdx, \r\n                    newIdx: idx, \r\n                    pieceCode: pieceCode,\r\n                    oldPieceCode: newVirtualBoard[currentX][currentY],\r\n                }\r\n            ]);\r\n\r\n            setNextMoves([]);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\r\n                    move.removeChild(oldPreviewMoves);\r\n                }\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n\r\n            if (rocade) {\r\n                if (rocade.rocade === 's') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                } else if (rocade.rocade === 'b') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                }\r\n            }\r\n\r\n            if (Math.abs(dropPiecer) === 6) {\r\n                kingsMoved.current[dropPiecer] = true;\r\n                console.log(kingsMoved.current[dropPiecer])\r\n            } else if (dropPiecer === 2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\r\n                console.log(rookMoved.current[2][\"right\"]);\r\n            } else if (dropPiecer === -2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\r\n            }\r\n   \r\n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\r\n\r\n            console.log(oldX, oldY, currentX, currentY);\r\n\r\n            console.log(cloneVirtualBoard);\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\r\n\r\n            console.log(cloneVirtualBoard);\r\n            \r\n            // Checking if it's giving checkmate to the opponent\r\n            let oppositeKingSquare, newBoard = [];\r\n\r\n            cloneVirtualBoard.forEach(row => {\r\n                row.forEach(square => newBoard.push(square));\r\n            });\r\n\r\n            newBoard.forEach((square, totalIdx) => {\r\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\r\n            });\r\n\r\n            console.log(oppositeKingSquare);\r\n            \r\n            const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\r\n            console.log(checkMateOpponent);\r\n            if (checkMateOpponent) {\r\n                console.log(\"IM HERE\");\r\n                setGameRunning(false);\r\n                gameEnd(currentMove);\r\n            }\r\n\r\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\r\n            console.log(checkEqual);\r\n            if (checkEqual) {\r\n                setGameRunning(false);\r\n                gameEnd(0);\r\n            }\r\n            localStorage.setItem(\"classic-current-move\", -currentMove);\r\n            let move = currentMove;\r\n            setCurrentMove(-currentMove);\r\n\r\n            localStorage.setItem(\"classic-board\", JSON.stringify(cloneVirtualBoard));\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n           \r\n            console.log(cloneVirtualBoard);\r\n\r\n            // Stopping & starting timer\r\n\r\n            stopTimer(move === 1 ? true : move === -1 ? false : null);\r\n\r\n            // console.log(checkMateOpponent);\r\n            \r\n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\r\n        \r\n    };\r\n\r\n    // const getContainers = (elements, piece) => {\r\n\r\n    //     let currBoard = [];\r\n    //     console.log(piece);\r\n    //     newVirtualBoard.forEach(row => {\r\n    //         row.forEach(square => currBoard.push(square));\r\n    //     });\r\n\r\n    //     const mySquaresClone = currBoard.filter((square, idx) => {\r\n    //         return (!checkOppositeColor(square, piece) && square !== 0);\r\n    //     });\r\n\r\n    //     const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n\r\n    //     console.log(mySquares);\r\n\r\n    //     const result = elements.filter((element, elementIdx) => {\r\n    //         let count = 0;\r\n    //         mySquares.forEach(square => {\r\n    //             if (square - 2 === elementIdx) count++;\r\n    //         });\r\n\r\n    //         console.log(count, elementIdx);\r\n\r\n    //         if (count < 1 && elementIdx === 3) {\r\n    //             console.log('queen not working')\r\n    //             return element;\r\n    //         }\r\n    //         else if (count < 2 && elementIdx !== 3) return element;\r\n\r\n    //         return null;\r\n    //     });\r\n\r\n    //     return result;\r\n    // };\r\n\r\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\r\n\r\n        // Get transformed piece's code\r\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\r\n        const newBoard = cloneDeep(newVirtualBoard);\r\n        const currentX = parseInt(idx / 8);\r\n        const currentY = idx % 8;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n        newBoard[currentX][currentY] = transformPieceCode;\r\n        newBoard[oldX][oldY] = 0;\r\n        setNewVirtualBoard(newBoard);\r\n        console.log(newBoard);\r\n        previewVirtualBoard.current = newBoard;\r\n        console.log(newBoard);\r\n        \r\n        setPawnTransform({\r\n            idx: idx,\r\n            piece: transformPieceCode,\r\n            elements: []\r\n        });\r\n\r\n        localStorage.setItem(\"classic-board\", JSON.stringify(newBoard));\r\n    };\r\n\r\n    const checkOppositeColor = (piece1, piece2) => {\r\n        if (piece1 < 0 && piece2 > 0) return true;\r\n        else if (piece1 > 0 && piece2 < 0) return true;\r\n        return false;\r\n    }\r\n\r\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        if (!isFromCheckMate) console.log(previewVirtualBoard.current);\r\n\r\n        // Getting coords\r\n        const currentX = parseInt(kingSquare / 8);\r\n        const currentY = kingSquare % 8;\r\n        const pieceCode = kCode / (-6);\r\n\r\n        let check = false;\r\n\r\n        const kingPossibleSquares = [\r\n            [currentX - 1, currentY - 1],\r\n            [currentX - 1, currentY],\r\n            [currentX - 1, currentY + 1],\r\n            [currentX, currentY - 1],\r\n            [currentX, currentY + 1],\r\n            [currentX + 1, currentY - 1],\r\n            [currentX + 1, currentY],\r\n            [currentX + 1, currentY + 1]\r\n        ];\r\n\r\n        console.log(previewVirtualBoard.current, pieceCode);\r\n\r\n        kingPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === -kCode && square !== null) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        // Pawns \r\n\r\n        const pawnPossibleSquares = [\r\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\r\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\r\n        ];\r\n        \r\n        console.log(pawnPossibleSquares);\r\n\r\n        pawnPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                console.log('check');\r\n                check = true;\r\n            }\r\n        });\r\n        \r\n        // Rows\r\n\r\n        if (currentX > 0) {\r\n            for (let i = currentX - 1; i >= 0; i--) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n                \r\n                console.log(5 * pieceCode, rowSquare);\r\n\r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentX < ROWS - 1) {\r\n            for (let i = currentX + 1; i < ROWS; i++) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n\r\n                console.log(5 * pieceCode, rowSquare);\r\n               \r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                   \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\r\n                        console.log(checkMate);\r\n                        if (checkMate) {\r\n                            setGameRunning(false);\r\n                            gameEnd(kCode / 6);\r\n                        }\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    console.log(\"here in if\")\r\n                    \r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Columns \r\n\r\n        if (currentY > 0) {\r\n            for (let i = currentY - 1; i >= 0; i--) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                        \r\n                    }\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentY < COLUMNS - 1) {\r\n            for (let i = currentX + 1; i < COLUMNS; i++) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top left\r\n        \r\n        if (currentX > 0 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top right\r\n\r\n        if (currentX > 0 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom left\r\n\r\n        if (currentX < ROWS - 1 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom right\r\n\r\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                console.log(newX, newY, square, 5 * pieceCode);\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    check = true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Knight moves\r\n\r\n        const knightPossibleMoves = [\r\n            [currentX - 2, currentY - 1],\r\n            [currentX - 2, currentY + 1],\r\n            [currentX + 2, currentY - 1],\r\n            [currentX + 2, currentY + 1],\r\n            [currentX - 1, currentY - 2],\r\n            [currentX - 1, currentY + 2],\r\n            [currentX + 1, currentY - 2],\r\n            [currentX + 1, currentY + 2]\r\n        ];\r\n\r\n        \r\n        \r\n        knightPossibleMoves.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode * 3) { \r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        return check;\r\n    };\r\n\r\n    const legalBoard = (board, kCode) => {\r\n        return board.some(row => {\r\n            return row.some(cell => cell === kCode);\r\n        });\r\n    };\r\n\r\n    // Checking the check-mate\r\n\r\n    const checkCheckmate = (kCode, board) => {\r\n\r\n        console.log(board);\r\n        const constantBoard = board;\r\n        let currBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            };\r\n            return undefined;\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n        console.log(mySquares);\r\n        let checkMate = true;\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        mySquares.forEach(square => {\r\n\r\n            // Next possible moves to check if it's checkmate\r\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            console.log(square.pieceCode, square.coords, possibleMovesCheckmate);\r\n\r\n            possibleMovesCheckmate.forEach(move => {\r\n                const currX = parseInt(square.coords / 8);\r\n                const currY = square.coords % 8;\r\n                const newX = parseInt(move / 8);\r\n                const newY = move % 8;\r\n                const newBoard = cloneDeep(constantBoard);\r\n\r\n                newBoard[currX][currY] = 0;\r\n                \r\n                if (newBoard != null && (newBoard[newX] != null) && (newBoard[newX][newY] != null)) {\r\n                  \r\n                    if (newBoard[newX][newY] !== 0) {\r\n                        const enemyPieceNumber = newBoard[newX][newY];\r\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\r\n                    } else {\r\n                        newBoard[newX][newY] = square.pieceCode;\r\n                    }\r\n                }\r\n\r\n                console.log(newBoard);\r\n                \r\n                previewVirtualBoard.current = cloneDeep(newBoard);\r\n\r\n                let allInOneBoard = [];\r\n\r\n                previewVirtualBoard.current.forEach(row => {\r\n                    row.forEach(square => allInOneBoard.push(square));\r\n                });\r\n\r\n\r\n                const possibleBoard = legalBoard(newBoard, kCode);\r\n                console.log(newBoard, newBoard[newX][newY], kCode);\r\n\r\n                console.log(allInOneBoard);\r\n\r\n                let kingSquare = -1;\r\n\r\n                allInOneBoard.forEach((square, idx) => {\r\n                    if (square === kCode) kingSquare = idx;\r\n                });\r\n\r\n\r\n                console.log(kingSquare);\r\n                \r\n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\r\n                console.log(previewVirtualBoard.current, newBoardCheck, possibleBoard, kingSquare, kCode);\r\n\r\n                if (!newBoardCheck && possibleBoard) checkMate = false;\r\n                \r\n            });\r\n        });\r\n        \r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n       if (checkMate) {\r\n           setGameRunning(false);\r\n           gameEnd(kCode / -6);\r\n       }\r\n       return checkMate;\r\n        \r\n    };\r\n\r\n    const checkPat = (pieceCode, board) => {\r\n        let currBoard = [];\r\n        console.log(board, pieceCode);\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\r\n            if (checkOppositeColor(pieceCode, square)) return {\r\n                pieceCode: square,\r\n                coords: coords\r\n            };\r\n\r\n            return undefined;\r\n        });\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        return oppositeSquares.every(square => {\r\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\r\n            console.log(oppPossibleMoves);\r\n            return oppPossibleMoves.length === 0;\r\n        });\r\n    };\r\n\r\n\r\n    const addSquares = () => {\r\n        let squareComponents = [];\r\n        console.log(virtualBoard);\r\n        const board = newVirtualBoard.map((row, rowIdx) => {\r\n\r\n            const rows = row.map((square, squareIdx) => {\r\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\r\n                const realIdx = rowIdx * 8 + squareIdx;\r\n               \r\n                const squareComponent = \r\n                    <div className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} key={squareIdx} ref={ref => { \r\n                        currSquareElement.current[realIdx] = ref;\r\n                    }}>\r\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\r\n                            pawnTransform.elements.length > 0 ? (<div \r\n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                key={totalIdx}\r\n                            >   \r\n                                {pawnTransform.elements}  \r\n                            </div>)\r\n                            : (\r\n                                <div \r\n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\r\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\r\n                                    onMouseMove={e => movePiece(e)}\r\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \r\n                                    key={totalIdx}\r\n                                >   \r\n                                    <FontAwesomeIcon \r\n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \r\n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \r\n                                        code={pawnTransform.piece}\r\n                                    />\r\n                                </div>\r\n                            )\r\n                        ) : square !== 0 ? (\r\n                            <div \r\n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\r\n                                onMouseMove={e => movePiece(e)}\r\n                                onMouseUp={e => dropPiece(e, square)} \r\n                                key={totalIdx}\r\n                            >   \r\n                                <FontAwesomeIcon \r\n                                    icon={piecesCode[Math.abs(square).toString()]} \r\n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \r\n                                    code={square}\r\n                                />\r\n                            </div>\r\n                        ) : \"\"}\r\n                    </div>;\r\n\r\n                return squareComponent;\r\n            });\r\n            return (\r\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\r\n                    {rows}\r\n                </div>\r\n            );\r\n        });\r\n\r\n        squareElements.current = squareComponents;\r\n\r\n        return board;\r\n    };\r\n\r\n    return (\r\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\r\n            {addSquares()}\r\n            <div className=\"letters\">\r\n                <p>A</p>\r\n                <p>B</p>\r\n                <p>C</p>\r\n                <p>D</p>\r\n                <p>E</p>\r\n                <p>F</p>\r\n                <p>G</p>\r\n                <p>H</p>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/ComputerBoard.jsx",["118","119","120","121","122","123"],"import React, { useState, useEffect, useRef } from \"react\";\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { isArray } from \"lodash\";\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\n\nimport '../styles/board.css';\n\nconst HEIGHT = 85 * window.innerHeight / 100;\nconst ROWS = 8;\nconst COLUMNS = 8;\n\nexport default function ComputerBoard({ color, prevButtons, random, difficulty }) {\n\n    const setColor = localStorage.getItem(\"set-color\") ? parseInt(localStorage.getItem(\"set-color\")) : parseInt(color);\n    localStorage.setItem(\"set-color\", setColor);\n    const currDifficulty = localStorage.getItem(\"computer-difficulty\") !== null ? difficulty : JSON.parse(localStorage.getItem(\"computer-difficulty\"));\n    localStorage.setItem(\"computer-difficulty\", JSON.stringify(difficulty));\n\n    const createVirtualBoard = () => {\n        let board = [];\n        for (let i = 0; i < 8; i++) {\n            let row = [];\n\n            for (let j = 0; j < 8; j++)\n                if (i === 1) row.push(-setColor * 1);\n                else if (i === 6) row.push(setColor * 1);\n                else if (i !== 7 && i !== 0) row.push(0);\n\n            if (color < 0) {\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 6, -setColor * 5, -setColor * 4, -setColor * 3, -setColor * 2);\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 6, setColor * 5, setColor * 4, setColor * 3, setColor * 2);    \n            } else {\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 5, -setColor * 6, -setColor * 4, -setColor * 3, -setColor * 2);\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 5, setColor * 6, setColor * 4, setColor * 3, setColor * 2);    \n            }         \n            board.push(row);\n        }\n\n        return board;\n    };\n\n    const boardRef = useRef(null);\n    const squareRef = useRef(null);\n    \n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"computer-current-move\") === null ? 1 : localStorage.getItem(\"computer-current-move\"));\n    const [oldIdx, setOldIdx] = useState(null);\n    const [possibleMoves, setPossibleMoves] = useState(null);\n    const [activePiece, setActivePiece] = useState(null);\n    const [dropPiecer, setActiveDrop] = useState(null);\n    const virtualBoard = localStorage.getItem(\"computer-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"computer-board\"));\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\n    const [previewMoves, setPreviewMoves] = useState([]);\n    const [gameRunning, setGameRunning] = useState(true);\n    const [pawnTransform, setPawnTransform] = useState(null);\n    const [prevMoves, setPrevMoves] = useState(localStorage.getItem(\"computer-prev-moves\") !== null ? JSON.parse(localStorage.getItem(\"computer-prev-moves\")) : []);\n    const [nextMoves, setNextMoves] = useState(localStorage.getItem(\"computer-next-moves\") !== null ? JSON.parse(localStorage.getItem(\"computer-next-moves\")) : []);\n\n    const previewVirtualBoard = useRef(virtualBoard);\n    const squareElements = useRef(null);\n    const currSquareElement = useRef([]);\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\n    const rookMoved = useRef({\n        \"2\": {\n            \"left\": false,\n            \"right\": false\n        },\n\n        \"-2\": {\n            \"left\": false,\n            \"right\": false\n        }\n    });\n\n    const piecesCode = {\n        1: faChessPawn,\n        2: faChessRook,\n        3: faChessKnight,\n        4: faChessBishop,\n        5: faChessQueen,\n        6: faChessKing\n    };\n\n    console.log(virtualBoard);\n\n    const pieceSound = new Audio(pieceMoveSound);\n    const pieceCapture = new Audio(pieceCaptureSound);\n    pieceCapture.volume = 0.3;\n\n    const minX = boardRef.current?.offsetLeft;\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\n\n    const minY = boardRef.current?.offsetTop;\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\n\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\n\n    console.log(squareWidth, squareHeight);\n\n    // Checking everytime prev/next button is pressed\n    \n    useEffect(() => {\n       \n        if (!prevButtons) return;\n        if (prevButtons.classList.contains('prev-button') && prevMoves.length === 0) return;\n        if (prevButtons.classList.contains('next-button') && nextMoves.length === 0) return;\n        \n        const lastMove = prevButtons.classList.contains('prev-button') ? prevMoves[prevMoves.length - 1] : nextMoves[nextMoves.length - 1];\n        console.log(prevButtons, prevMoves, lastMove.pieceCode);\n        const currBoard = cloneDeep(newVirtualBoard);\n        const oldX = parseInt(lastMove.oldIdx / 8);\n        const oldY = lastMove.oldIdx % 8;\n        const newX = parseInt(lastMove.newIdx / 8);\n        const newY = lastMove.newIdx % 8;\n        currBoard[oldX][oldY] = prevButtons.classList.contains('prev-button') ? lastMove.pieceCode : 0;\n        currBoard[newX][newY] = lastMove.oldPieceCode;\n    \n        setNewVirtualBoard(currBoard);\n\n        if (prevButtons.classList.contains('prev-button')) {\n            const newNextMoves = [...nextMoves,\n                {\n                    oldIdx: lastMove.oldIdx,\n                    newIdx: lastMove.newIdx,\n                    oldPieceCode: lastMove.pieceCode,\n                    pieceCode: lastMove.oldPieceCode\n                }\n            ];\n            localStorage.setItem(\"computer-prev-moves\", JSON.stringify(prevMoves.slice(0, -1)));\n            localStorage.setItem(\"computer-next-moves\", JSON.stringify(newNextMoves));\n\n            setPrevMoves(prevMoves.slice(0, -1));\n            setNextMoves(newNextMoves);\n\n        } else  {\n            console.log('ok from here');\n            const newPrevMoves = [...prevMoves,\n                {\n                    oldIdx: lastMove.oldIdx,\n                    newIdx: lastMove.newIdx,\n                    oldPieceCode: lastMove.pieceCode,\n                    pieceCode: lastMove.oldPieceCode\n                }\n            ];\n\n            localStorage.setItem(\"computer-prev-moves\", JSON.stringify(newPrevMoves));\n            localStorage.setItem(\"computer-next-moves\", JSON.stringify(nextMoves.slice(0, -1)));\n        \n            setNextMoves(nextMoves.slice(0, -1));\n            setPrevMoves(newPrevMoves);\n        }\n\n        localStorage.setItem(\"computer-current-move\", -currentMove);\n        localStorage.setItem(\"computer-board\", JSON.stringify(currBoard));\n        \n        setCurrentMove(-currentMove);\n\n    }, [random]);\n\n    // Function for checking the check \n\n    const getPossibleMoves = (pieceCode, coords, board) => {\n        const piece = Math.abs(pieceCode);\n        let possibleMoves = [];\n\n        // Current coordonates\n        const currentX = parseInt(coords / 8);\n        const currentY = coords % 8; \n\n        console.log(currentX, currentY);\n\n        // Code for pawn\n        if (piece === 1) {\n\n            // Coordonates for possible moves\n            const newDiagX = currentX - (pieceCode * setColor);\n            const newDiagY = currentY + (pieceCode * setColor);\n            const newDiagY2 = currentY - (pieceCode * setColor);\n            \n            const newCoords = newDiagX * 8 + newDiagY;\n            const newCoords2 = newDiagX * 8 + newDiagY2;\n            const newFrontCoords = newDiagX * 8 + currentY;\n            const frontElement = board[newDiagX] &&\n                                 board[newDiagX][currentY] &&\n                                 board[newDiagX][currentY];\n\n            console.log(frontElement);\n\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\n\n            console.log(possibleMoves);\n            \n            const diagonalElement = board[newDiagX] &&\n                                    board[newDiagX][newDiagY] &&\n                                    board[newDiagX][newDiagY];\n\n            const diagonalElement2 = board[newDiagX] &&\n                                     board[newDiagX][newDiagY2] &&\n                                     board[newDiagX][newDiagY2];\n            \n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\n                console.log(newFrontX);\n                const newFrontCoords = newFrontX * 8 + currentY;\n\n                const newCoordsSquare = board[newFrontX][currentY];\n                if (newCoordsSquare === 0 && frontElement === 0) possibleMoves.push(newFrontCoords);\n            }\n\n            if (diagonalElement2 !== 0) {\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\n            }\n           \n            if (diagonalElement === 0) return possibleMoves;\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\n\n        } else if (piece === 2) {\n\n            if (currentY > 1) {\n                for (let i = currentY - 1; i >= 0; i--) {\n                    const newCoords = currentX * 8 + i;\n                    \n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);    \n \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentY < 7) {\n                for (let i = currentY + 1; i < 8; i++) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                             break;\n                        } else possibleMoves.push(newCoords);    \n\n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            } \n\n            if (currentX > 1) {\n                for (let i = currentX - 1; i >= 0; i--) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                                           \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentX < 7) {\n                for (let i = currentX + 1; i < 8; i++) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n                        \n                        console.log('empty text just for fun', newSquare);\n                    }\n\n                }\n            } \n        } else if (piece === 3) {\n\n            const pieceMoves = [\n                {\n                    x: currentX - 2,\n                    y: currentY - 1\n                },\n                \n                {\n                    x: currentX - 2,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX + 2,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX + 2,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY - 2\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY + 2\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY - 2\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY + 2\n                }\n            ];\n\n            pieceMoves.forEach(pieceMove => {\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\n                const newSquare = board[pieceMove.x] &&\n                                  board[pieceMove.x][pieceMove.y] &&\n                                  board[pieceMove.x][pieceMove.y];\n\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\n                    if (newSquare !== 0) {\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                    }\n                    else possibleMoves.push(newCoords);\n\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\n                }\n            });\n        } else if (piece === 4) {\n            if (currentX >= 1 && currentY >= 1) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n                }\n            }\n\n            if (currentX >= 1 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n\n                }\n            } \n\n            if (currentX <= 7 && currentY >= 0) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n  \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n                }\n            }\n\n            if (currentX <= 7 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                       \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves, newSquare, board, newX, newY);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n\n                }\n            } \n        } else if (piece === 5) {\n            console.log(board); \n\n            if (currentY > 1) {\n                for (let i = currentY - 1; i >= 0; i--) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);   \n                                         \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentY < 7) {\n                for (let i = currentY + 1; i < 8; i++) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {   \n\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n        \n                        console.log('empty text just for fun', possibleMoves);\n                    }\n                }\n            } \n\n            if (currentX > 1) {\n                for (let i = currentX - 1; i >= 0; i--) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newCoords, possibleMoves);\n                    }   \n                }\n            }\n\n            if (currentX < 7) {\n                for (let i = currentX + 1; i < 8; i++) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n        \n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n\n                }\n            }\n            \n            if (currentX >= 1 && currentY >= 1) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    console.log(newSquare, newX, newY, pieceCode);\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            }\n\n            if (currentX >= 1 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    console.log(newSquare, newX, newY);\n                    if (newSquare !== undefined) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            } \n\n            if (currentX <= 7 && currentY >= 0) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n        \n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            }\n\n            if (currentX <= 7 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                   \n                    if (newSquare !== undefined) {\n                        console.log(newX, newY);\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n\n                }\n            } \n        } else if (piece === 6) {\n            const pieceMoves = [\n                {\n                    x: currentX,\n                    y: currentY - 1\n                },\n                \n                {\n                    x: currentX,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY \n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY + 1\n                }\n            ];\n\n            pieceMoves.forEach(pieceMove => {\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\n                const newSquare = board[pieceMove.x] &&\n                                  board[pieceMove.x][pieceMove.y] &&\n                                  board[pieceMove.x][pieceMove.y];\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\n                    if (newSquare !== 0) {\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                    } else possibleMoves.push(newCoords);\n\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\n                }\n            });\n\n            // Movement for rocade\n            console.log(kingsMoved.current[pieceCode]);\n            if (!kingsMoved.current[pieceCode]) {\n                console.log('rocade', rookMoved);\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\n\n                const smallRocadeSquare = board[currentX] &&\n                                          board[currentX][currentY + 2] &&\n                                          board[currentX][currentY + 2];\n\n                const bigRocadeSquare = board[currentX] &&\n                                        board[currentX][currentY - 3] &&\n                                        board[currentX][currentY - 3];\n\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\n\n                // Checking if the squares between king and rook are empty \n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\n                    const rocadeX = parseInt(i / 8);\n                    const rocadeY = i % 8;\n                   \n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\n                } \n\n                for (let i = bigRocadeCoords; i < coords; i++) {\n                    const rocadeX = parseInt(i / 8);\n                    const rocadeY = i % 8;\n                    console.log('gdjigdfjhh');\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\n                } \n\n                console.log(smallRocadeEmpty, bigRocadeEmpty)\n\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\n                    possibleMoves.push({\n                        king: smallRocadeCoords,\n                        rook: smallRocadeRookCoords,\n                        rocade: \"s\"\n                    });\n                } \n\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\n                    possibleMoves.push({\n                        king: bigRocadeCoords,\n                        rook: bigRocadeRookCoords,\n                        rocade: \"b\"\n                    });\n                }\n\n                \n\n                // possibleMoves.push(smallRocade);\n                // possibleMoves.push(bigRocade);\n            }\n        }\n      \n        return possibleMoves;\n    };\n\n    const dragPiece = (e, square) => {\n        \n        if (!gameRunning) return;\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\n\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\n        const containerElement = element.parentElement;\n        console.log(containerElement, square);\n        const x = e.clientX - 20;\n        const y = e.clientY - 20;\n        console.log(x, y, square, currentMove);\n        containerElement.style.position = 'absolute';\n        containerElement.style.left = `${x}px`;\n        containerElement.style.top = `${y}px`;\n\n        \n        \n        setActivePiece(containerElement);\n        setActiveDrop(parseInt(containerElement.classList[2]));\n        let newTotalCoords;\n        currSquareElement.current.forEach((square, idx) => {\n            if (square === containerElement.parentElement) newTotalCoords = idx;\n        });\n\n        setOldIdx(newTotalCoords);\n\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\n        console.log(currPossibleMoves, newVirtualBoard, square, currentMove, newTotalCoords);\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\n        else {\n            setPossibleMoves(currPossibleMoves);\n\n            // Removing old preview dots\n            previewMoves && previewMoves.forEach(move => {\n                const oldPreviewMoves = move.firstChild;\n                console.log(move, oldPreviewMoves);\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\n            });\n        \n            let newPreviewMoves = [];\n            currPossibleMoves.forEach((move, idx) => {\n                setTimeout(() => {\n                    const currSquare = currSquareElement.current[move];\n\n                    if (currSquare && currSquare.firstChild == null) {\n                        const dotElement = document.createElement('div');\n                        dotElement.classList.add('possible-move')\n\n                        currSquare.appendChild(dotElement);\n                        console.log(currSquare);\n                        newPreviewMoves.push(currSquare);\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\n                        currSquare.firstChild.firstChild.classList.add('attacked');\n                        newPreviewMoves.push(currSquare);\n                    }\n                }, idx * 0);\n            });\n\n            setPreviewMoves(newPreviewMoves);\n        }\n       \n    };\n    \n    const movePiece = e => {\n        \n        if (!activePiece) return;\n        const x = e.clientX - 15;\n        const y = e.clientY - 15;\n        activePiece.style.position = 'absolute';\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\n        activePiece.style.zIndex = 3;\n\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\n        \n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\n        console.log(squareRef.current);\n    };\n    \n    const dropPiece = (e, pieceCode) => {\n        \n        if (!activePiece || !squareRef.current || oldIdx === null) return;\n        if (!possibleMoves) return;\n        setActivePiece(null);\n        console.log(squareRef.current?.x, squareRef.current?.y)\n        const currentX = squareRef.current?.x;\n        const currentY = squareRef.current?.y;\n        let rocade = false;\n        const idx = currentX * 8 + currentY;\n        const oldX = parseInt(oldIdx / 8);\n        const oldY = oldIdx % 8;\n\n        const sameIndex = possibleMoves.find(move => {\n            if (typeof move === 'object') rocade = move;\n            return idx === (typeof move === 'object' ? move.king : move);\n        });\n\n        activePiece.style.left = 'initial';\n        activePiece.style.top= 'initial';\n        activePiece.position = 'relative';\n        activePiece.style.zIndex = 'initial';\n        console.log(previewVirtualBoard.current);\n\n        if (setColor !== parseInt(currentMove)) {\n            console.log('here', setColor, currentMove);\n            return;\n        }\n\n        const oldBoard = cloneDeep(newVirtualBoard);\n        const otherBoard = cloneDeep(newVirtualBoard);\n        otherBoard[oldX][oldY] = 0;\n        otherBoard[currentX][currentY] = pieceCode; \n        previewVirtualBoard.current = otherBoard;\n        console.log('afdsokogjfdjjhihijhpjhijhipfghjpifjhpgjhpijhpfgjh', previewVirtualBoard.current);\n\n        let squaresVirtualBoard = [];\n\n        previewVirtualBoard.current.forEach(row => {\n            row.forEach(square => squaresVirtualBoard.push(square));\n        });\n        \n        let kingSquare;\n\n        squaresVirtualBoard.forEach((square, totalIdx) => {\n            const iconColor = square && square < 0 ? -1 : 1;\n\n            if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) kingSquare = totalIdx;\n        });  \n\n        console.log(kingSquare, currentMove,  previewVirtualBoard.current);\n        const check = checkCheckOptimised(kingSquare, setColor * 6);\n        console.log(check);\n\n        if (sameIndex !== undefined && !check) {  \n\n            // Sound of piece moving\n            pieceSound.play();\n\n            const squareDOM = currSquareElement.current[idx];\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\n            squareRef.current = null;\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\n            console.log(cloneIcon, prevMoves);\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\n                // squareDOM.innerHTML = '';\n                pieceSound.pause();\n                pieceCapture.play();\n            }\n  \n            let skipComputerMove = false;\n\n            // Piece being moved to new square\n            if ((squareDOM && pieceCode === 1 && currentX === 0 && setColor === 1) || (squareDOM && pieceCode === -1 && currentX === 7 && setColor === 1) || (squareDOM && pieceCode === 1 && currentX === 7 && setColor === -1) || (squareDOM && pieceCode === -1 && currentX === 0 && setColor === -1)) {\n                \n                console.log('here'); \n                \n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\n                const leftContainers = containers;  \n                console.log(leftContainers);\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\n                    return (\n                        <div \n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\n                        >\n                            <FontAwesomeIcon \n                                icon={piece} \n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \n                                code={pieceCode}\n                                \n                            />\n                        </div>\n                    );\n                }) : activePiece;\n\n                setPawnTransform({\n                    idx: idx,\n                    elements: elements\n                });\n\n                skipComputerMove = true;\n\n            } else setPawnTransform(null);\n\n            setPrevMoves([...prevMoves, \n                {\n                    oldIdx: oldIdx, \n                    newIdx: idx, \n                    pieceCode: pieceCode,\n                    oldPieceCode: newVirtualBoard[currentX][currentY],\n                }\n            ]);\n\n            setNextMoves([]);\n\n            // Removing old preview dots\n            previewMoves && previewMoves.forEach(move => {\n                const oldPreviewMoves = move.firstChild;\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\n                    move.removeChild(oldPreviewMoves);\n                }\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\n            });\n\n            if (rocade) {\n                if (rocade.rocade === 's') {\n                    const rookSquare = currSquareElement.current[rocade.rook];\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\n                    rookSquare.appendChild(rookInit);\n                } else if (rocade.rocade === 'b') {\n                    const rookSquare = currSquareElement.current[rocade.rook];\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\n                    rookSquare.appendChild(rookInit);\n                }\n            }\n\n            if (Math.abs(dropPiecer) === 6) {\n                kingsMoved.current[dropPiecer] = true;\n                console.log(kingsMoved.current[dropPiecer])\n            } else if (dropPiecer === 2) {\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\n                console.log(rookMoved.current[2][\"right\"]);\n            } else if (dropPiecer === -2) {\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\n            }\n   \n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\n            console.log(oldX, oldY, currentX, currentY);\n            console.log(cloneVirtualBoard);\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\n\n            console.log(cloneVirtualBoard);\n            \n            // Checking if it's giving checkmate to the opponent\n            let oppositeKingSquare, newBoard = [];\n\n            cloneVirtualBoard.forEach(row => {\n                row.forEach(square => newBoard.push(square));\n            });\n\n            newBoard.forEach((square, totalIdx) => {\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\n            });\n\n            console.log(oppositeKingSquare);\n            \n            // const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\n            // console.log(checkMateOpponent);\n            // if (checkMateOpponent) setGameRunning(false);\n\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\n            console.log(checkEqual);\n            if (checkEqual) setGameRunning(false);\n            localStorage.setItem(\"computer-current-move\", -currentMove);\n            // setCurrentMove(-currentMove);\n\n            localStorage.setItem(\"computer-board\", JSON.stringify(cloneVirtualBoard));\n            setNewVirtualBoard(cloneVirtualBoard);\n\n            if (!skipComputerMove) computerMove(cloneVirtualBoard);\n           \n            console.log(cloneVirtualBoard);\n\n            // console.log(checkMateOpponent);\n            \n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\n        \n    };\n\n    const computerMove = (newBoard) => {\n        console.log('none', currentMove);\n        let currMove = currentMove, checkmate = false;\n        setCurrentMove(-currMove);\n\n        const possibleMoves = getAllMoves(-currMove, newBoard);\n        console.log(possibleMoves)\n        if (possibleMoves.length === 0) {\n            setGameRunning(false);\n            return;\n        }\n\n        let newPossibleMoves, newMove;\n\n        if (currDifficulty === \"easy\") {\n            newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n            newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n           \n        } else if (currDifficulty === \"medium\") {\n            \n            let minNum = { number: Number.POSITIVE_INFINITY };\n            possibleMoves.forEach(move => {\n                move.moves.forEach(possMove => {\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\n                        minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                        newMove = possMove;\n                        newPossibleMoves = move; \n                    }\n                });\n            });\n\n            if (minNum.number === Number.POSITIVE_INFINITY) {\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n            }\n            \n        } else if (currDifficulty === \"hard\") {\n            \n            let minNum = { number: Number.POSITIVE_INFINITY };\n            possibleMoves.forEach(move => {\n                move.moves.forEach(possMove => {\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\n                            console.log('no, is not defensed');\n\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        }\n                    }\n                });\n            });\n\n            if (minNum.number === Number.POSITIVE_INFINITY) {\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n            }\n\n        } else if (currDifficulty === \"very hard\") {\n            let minNum = { number: Number.POSITIVE_INFINITY };\n            possibleMoves.forEach(move => {\n                move.moves.forEach(possMove => {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    \n                    previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\n                    previewVirtualBoard.current[parseInt(possMove / 8)][possMove % 8] = move.piece;\n                    console.log(previewVirtualBoard.current);\n                    let squaresVirtualBoard = [];\n\n                    previewVirtualBoard.current.forEach(row => {\n                        row.forEach(square => squaresVirtualBoard.push(square));\n                    });\n                    \n                    let kingSquare;\n\n                    squaresVirtualBoard.forEach((square, totalIdx) => {\n                        const iconColor = square && square < 0 ? -1 : 1;\n                        if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) \n                            kingSquare = totalIdx;\n                    });  \n                    console.log(kingSquare, setColor * 6);\n                    if (!isDefensed(newBoard, move.idx, possMove) && checkCheckOptimised(kingSquare, setColor * 6)) {\n                        \n                        if (checkCheckmate(kingSquare, previewVirtualBoard.current)) checkmate = true;\n        \n                        minNum.number = -1;\n                        newMove = possMove;\n                        newPossibleMoves = move;\n                    } else if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\n                            console.log('no, is not defensed');\n\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        }\n                    }\n\n                    previewVirtualBoard.current = oldBoard;\n                });\n            });\n\n            if (minNum.number === Number.POSITIVE_INFINITY) {\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n            }\n        }\n       \n        console.log(newMove);\n        let cloneVirtualBoard = cloneDeep(newBoard);\n\n        const oldX = parseInt(newPossibleMoves.idx / 8);\n        const oldY = newPossibleMoves.idx % 8;\n        const newX = parseInt(newMove / 8);\n        const newY = newMove % 8;\n\n        const iconContainerElement = currSquareElement.current[newPossibleMoves.idx].firstChild;\n        iconContainerElement.classList.add('opponent');\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\n        iconContainerElement.classList.add('changed-move');\n        \n        setTimeout(() => {\n            // iconContainerElement.classList.remove('opponent');\n            iconContainerElement.style.zIndex = 'initial';\n            iconContainerElement.style.position = 'initial';\n            iconContainerElement.style.left = `initial`;\n            iconContainerElement.style.top = `initial`;\n            iconContainerElement.style.transform = 'initial';\n           \n            let sound;\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\n            else sound = pieceSound;\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[newX][newY] = newPossibleMoves.piece;\n\n            localStorage.setItem(\"computer-current-move\", setColor);\n            localStorage.setItem(\"computer-board\", JSON.stringify(cloneVirtualBoard));\n\n            setNewVirtualBoard(cloneVirtualBoard);\n            sound.play();\n            if (checkmate) setGameRunning(false);\n            setCurrentMove(currMove);\n\n        }, 750);\n    };\n\n    // Computer check if any piece is attacked and can defense it\n\n    // const isAttacked = (board, computerIdx, playerIdx) => {\n    //     const computerPiece = board[parseInt(computerIdx / 8)][computerIdx % 8];\n    //     const playerPiece = board[parseInt(playerIdx / 8)][playerIdx % 8];\n\n    //     let squareBoard = [];\n    //     board.forEach(row => {\n    //         row.forEach(square => squareBoard.push(square));\n    //     });\n\n    //     const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\n    //         if (!checkOppositeColor(square, setColor) && square !== 0) return {\n    //             piece: square,\n    //             idx: idx\n    //         }\n    //     });\n\n    //     const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\n\n    //     playerPieces.forEach(piece => {\n            \n    //     });\n    // };\n\n    // Check if player move is defensed\n\n    const isDefensed = (board, computerIdx, playerIdx) => {\n        \n        let squareBoard = [];\n\n        board.forEach(row => {\n            row.forEach(square => squareBoard.push(square));\n        });\n\n        const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, setColor) && square !== 0) return {\n                piece: square,\n                idx: idx\n            };\n\n            return undefined;\n        });\n\n        const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\n\n        console.log(playerPieces);\n\n        let cloneBoard = cloneDeep(board);\n        cloneBoard[parseInt(playerIdx / 8)][playerIdx % 8] = 0;\n\n        // Get possible moves for each piece\n\n        return playerPieces.some(piece => {\n            const playerPossibleMoves = getPossibleMoves(piece.piece, piece.idx, cloneBoard);\n            return playerPossibleMoves.some(move => move === playerIdx);\n        });\n    };\n\n\n    const getAllMoves = (color, newBoard) => {\n        let currBoard = [];\n\n        newBoard.forEach(row => {\n            row.forEach(square => {\n                currBoard.push(square);\n            });\n        });\n\n        let possibleMoves = [], allMoves = [];\n\n        currBoard.forEach((square, idx) => {\n            if (!checkOppositeColor(color, square) && square !== 0) possibleMoves.push({\n                piece: square, \n                idx: idx\n            });\n        });\n\n        possibleMoves.length !== 0 && possibleMoves.forEach(move => {\n            const currPossMoves = getPossibleMoves(move.piece, move.idx, newBoard);\n            console.log(move);\n            const currMoves = currPossMoves.length !== 0 && isArray(currPossMoves) ? currPossMoves.filter(currPieceMove => {\n                if (currPieceMove.rocade != null) return false;\n                let oldPreviewVirtualBoard = cloneDeep(previewVirtualBoard.current);\n                console.log(move.idx, currPieceMove);\n                previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\n                previewVirtualBoard.current[parseInt(currPieceMove / 8)][currPieceMove % 8] = move.piece;\n                let kingSquare;\n                console.log(newVirtualBoard);\n                previewVirtualBoard.current.forEach((row, rowIdx) => {\n                    row.forEach((square, squareIdx) => {\n                        if (square === -setColor * 6) kingSquare = rowIdx * 8 + squareIdx;\n                    });\n                });\n                \n                const isCheck = checkCheckOptimised(kingSquare, -setColor * 6);\n                previewVirtualBoard.current = cloneDeep(oldPreviewVirtualBoard);\n                \n                return !isCheck;\n            }) : [];\n\n            console.log(currMoves);\n            \n            if (currMoves.length !== 0) {\n                allMoves.push({\n                    piece: move.piece,\n                    idx: move.idx, \n                    moves: currMoves\n                });\n            }\n        });\n\n        console.log(allMoves);\n\n        return allMoves;\n    };\n\n    const computerMoveFirst = () => {\n        let newBoard1 = cloneDeep(newVirtualBoard);\n        newBoard1[2][0] = 0;\n        newBoard1[0][1] = 3;\n        setNewVirtualBoard(newBoard1);\n        const possibleMoves = getAllMoves(currentMove, newBoard1);\n        console.log(possibleMoves, Math.random() * possibleMoves.length);\n        const randomPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n        const randomMove = randomPossibleMoves.moves[Math.floor(Math.random() * randomPossibleMoves.moves.length)];\n        console.log(randomMove);\n        let cloneVirtualBoard = cloneDeep(newBoard1);\n\n        const oldX = parseInt(randomPossibleMoves.idx / 8);\n        const oldY = randomPossibleMoves.idx % 8;\n        const newX = parseInt(randomMove / 8);\n        const newY = randomMove % 8;\n        console.log(newX, newY);\n\n        const iconContainerElement = currSquareElement.current[randomPossibleMoves.idx].firstChild;\n        iconContainerElement.classList.add('opponent');\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\n        iconContainerElement.classList.add('changed-move');\n        \n        setTimeout(() => {\n            // iconContainerElement.classList.remove('opponent');\n            iconContainerElement.style.zIndex = 'initial';\n            iconContainerElement.style.position = 'initial';\n            iconContainerElement.style.left = `initial`;\n            iconContainerElement.style.top = `initial`;\n            iconContainerElement.style.transform = 'initial';\n            \n           \n            let sound;\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\n            else sound = pieceSound;\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[newX][newY] = randomPossibleMoves.piece;\n\n            localStorage.setItem(\"computer-current-move\", setColor);\n            localStorage.setItem(\"computer-board\", JSON.stringify(cloneVirtualBoard));\n\n            setNewVirtualBoard(cloneVirtualBoard);\n            sound.play();\n            setCurrentMove(setColor);\n\n          \n        }, 750);\n    };\n\n    useEffect(() => {\n        if (setColor === -1) computerMoveFirst();\n    }, [setColor]);\n    \n       \n \n\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\n\n        // Get transformed piece's code\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\n        const newBoard = cloneDeep(newVirtualBoard);\n        const currentX = parseInt(idx / 8);\n        const currentY = idx % 8;\n        const oldX = parseInt(oldIdx / 8);\n        const oldY = oldIdx % 8;\n        newBoard[currentX][currentY] = transformPieceCode;\n        newBoard[oldX][oldY] = 0;\n        setNewVirtualBoard(newBoard);\n        console.log(newBoard);\n        previewVirtualBoard.current = newBoard;\n        console.log(newBoard);\n        \n        setPawnTransform({\n            idx: idx,\n            piece: transformPieceCode,\n            elements: []\n        });\n\n        localStorage.setItem(\"computer-board\", JSON.stringify(newBoard));\n    };\n\n    const checkOppositeColor = (piece1, piece2) => {\n        if (piece1 < 0 && piece2 > 0) return true;\n        else if (piece1 > 0 && piece2 < 0) return true;\n        return false;\n    }\n\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\n\n        // Getting coords\n        const currentX = parseInt(kingSquare / 8);\n        const currentY = kingSquare % 8;\n        const pieceCode = kCode / (-6);\n\n        let check = false;\n\n        const kingPossibleSquares = [\n            [currentX - 1, currentY - 1],\n            [currentX - 1, currentY],\n            [currentX - 1, currentY + 1],\n            [currentX, currentY - 1],\n            [currentX, currentY + 1],\n            [currentX + 1, currentY - 1],\n            [currentX + 1, currentY],\n            [currentX + 1, currentY + 1]\n        ];\n\n        console.log(previewVirtualBoard.current, pieceCode);\n\n        kingPossibleSquares.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === -kCode && square !== null) {\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                check = true;\n            }\n        });\n\n        // Pawns \n\n        const pawnPossibleSquares = [\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\n        ];\n        \n        console.log(pawnPossibleSquares);\n\n        pawnPossibleSquares.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === pieceCode) {\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                console.log('check');\n                check = true;\n            }\n        });\n        \n        // Rows\n\n        if (currentX > 0) {\n            for (let i = currentX - 1; i >= 0; i--) {\n                const rowSquare =   previewVirtualBoard.current[i] && \n                                    previewVirtualBoard.current[i][currentY] &&\n                                    previewVirtualBoard.current[i][currentY];\n                \n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (rowSquare !== 0) break;\n            }\n        }\n\n        if (currentX < ROWS - 1) {\n            for (let i = currentX + 1; i < ROWS; i++) {\n                const rowSquare =   previewVirtualBoard.current[i] && \n                                    previewVirtualBoard.current[i][currentY] &&\n                                    previewVirtualBoard.current[i][currentY];\n\n                console.log(rowSquare, pieceCode, previewVirtualBoard.current);\n                \n                if (rowSquare === 2 * pieceCode || rowSquare * pieceCode === 5) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) {\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\n                        console.log(checkMate);\n                    }\n                    console.log(\"here in if\")\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (rowSquare !== 0) break;\n            }\n        }\n\n        // Columns \n\n        if (currentY > 0) {\n            for (let i = currentY - 1; i >= 0; i--) {\n                const columnSquare = previewVirtualBoard.current[currentX] &&\n                                     previewVirtualBoard.current[currentX][i] && \n                                     previewVirtualBoard.current[currentX][i];\n                \n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (columnSquare !== 0) break;\n            }\n        }\n\n        if (currentY < COLUMNS - 1) {\n            for (let i = currentX + 1; i < COLUMNS; i++) {\n                const columnSquare = previewVirtualBoard.current[currentX] &&\n                                     previewVirtualBoard.current[currentX][i] && \n                                     previewVirtualBoard.current[currentX][i];\n                \n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (columnSquare !== 0) break;\n            }\n        }\n\n        // Diagonal top left\n        \n        if (currentX > 0 && currentY > 0) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX - i;\n                const newY = currentY - i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal top right\n\n        if (currentX > 0 && currentY < COLUMNS - 1) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX - i;\n                const newY = currentY + i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal bottom left\n\n        if (currentX < ROWS - 1 && currentY > 0) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX + i;\n                const newY = currentY - i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal bottom right\n\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX + i;\n                const newY = currentY + i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Knight moves\n\n        const knightPossibleMoves = [\n            [currentX - 2, currentY - 1],\n            [currentX - 2, currentY + 1],\n            [currentX + 2, currentY - 1],\n            [currentX + 2, currentY + 1],\n            [currentX - 1, currentY - 2],\n            [currentX - 1, currentY + 2],\n            [currentX + 1, currentY - 2],\n            [currentX + 1, currentY + 2]\n        ];\n\n        \n        \n        knightPossibleMoves.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === pieceCode * 3) { \n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                check = true;\n            }\n        });\n\n        return check;\n    };\n\n    const legalBoard = (board, kCode) => {\n        return board.some(row => {\n            return row.some(cell => cell === kCode);\n        });\n    };\n\n    // Checking the check-mate\n\n    const checkCheckmate = (kCode, board) => {\n\n        console.log(board);\n        const constantBoard = board;\n        let currBoard = [];\n\n        board.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const mySquaresClone = currBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\n                pieceCode: square,\n                coords: idx\n            }\n        });\n\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\n        console.log(mySquares);\n        let checkMate = true;\n\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\n\n        mySquares.forEach(square => {\n\n            // Next possible moves to check if it's checkmate\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\n            console.log(possibleMovesCheckmate);\n\n            possibleMovesCheckmate.forEach(move => {\n                const currX = parseInt(square.coords / 8);\n                const currY = square.coords % 8;\n                const newX = parseInt(move / 8);\n                const newY = move % 8;\n                const newBoard = cloneDeep(constantBoard);\n\n                newBoard[currX][currY] = 0;\n                \n                if (newBoard != null && (newBoard[newX] != null) && (newBoard[newX][newY] != null)) {\n                    if (newBoard[newX][newY] !== 0) {\n                        const enemyPieceNumber = newBoard[newX][newY];\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\n                    } else newBoard[newX][newY] = square.pieceCode;\n                }\n\n                \n                previewVirtualBoard.current = cloneDeep(newBoard);\n\n                let allInOneBoard = [];\n\n                previewVirtualBoard.current.forEach(row => {\n                    row.forEach(square => allInOneBoard.push(square));\n                });\n\n                console.log(newBoard, kCode);\n\n                console.log(allInOneBoard);\n\n                let kingSquare = -1;\n\n                allInOneBoard.forEach((square, idx) => {\n                    if (square === kCode) kingSquare = idx;\n                });\n\n                console.log(kingSquare);\n                const possibleBoard = legalBoard(newBoard, kCode);\n                \n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\n                console.log(newBoardCheck, kingSquare, kCode);\n                if (!newBoardCheck && possibleBoard) checkMate = false;\n                \n            });\n        });\n        \n\n        previewVirtualBoard.current = oldBoard;\n       if (checkMate) setGameRunning(false);\n       return checkMate;\n        \n    };\n\n    const checkPat = (pieceCode, board) => {\n        let currBoard = [];\n        console.log(board, pieceCode);\n        board.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\n            if (checkOppositeColor(pieceCode, square)) return {\n                pieceCode: square,\n                coords: coords\n            };\n        });\n\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\n\n        return oppositeSquares.every(square => {\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\n            console.log(oppPossibleMoves);\n            return oppPossibleMoves.length === 0;\n        });\n    };\n\n\n    const addSquares = () => {\n        let squareComponents = [];\n        console.log(virtualBoard);\n        const board = newVirtualBoard.map((row, rowIdx) => {\n\n            const rows = row.map((square, squareIdx) => {\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\n                const realIdx = rowIdx * 8 + squareIdx;\n               \n                const squareComponent = \n                    <div className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} key={squareIdx} ref={ref => { \n                        currSquareElement.current[realIdx] = ref;\n                    }}>\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\n                            pawnTransform.elements.length > 0 ? (<div \n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\n                                key={totalIdx}\n                            >   \n                                {pawnTransform.elements}  \n                            </div>)\n                            : (\n                                <div \n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\n                                    onMouseMove={e => movePiece(e)}\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \n                                    key={totalIdx}\n                                >   \n                                    <FontAwesomeIcon \n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \n                                        code={pawnTransform.piece}\n                                    />\n                                </div>\n                            )\n                        ) : square !== 0 ? (\n                            <div \n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\n                                onMouseMove={e => movePiece(e)}\n                                onMouseUp={e => dropPiece(e, square)} \n                                key={totalIdx}\n                            >   \n                                <FontAwesomeIcon \n                                    icon={piecesCode[Math.abs(square).toString()]} \n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \n                                    code={square}\n                                />\n                            </div>\n                        ) : \"\"}\n                    </div>;\n\n                return squareComponent;\n            });\n            return (\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\n                    {rows}\n                </div>\n            );\n        });\n\n        squareElements.current = squareComponents;\n\n        return board;\n    };\n\n    return (\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\n            {addSquares()}\n            <div className=\"letters\">\n                <p>A</p>\n                <p>B</p>\n                <p>C</p>\n                <p>D</p>\n                <p>E</p>\n                <p>F</p>\n                <p>G</p>\n                <p>H</p>\n            </div>\n        </div>\n    );\n};\n","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/OnlineBoard.jsx",["124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147"],"import React, { useState, useEffect, useRef } from \"react\";\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\nimport cloneDeep from 'lodash/cloneDeep';\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\n\nimport '../styles/board.css';\nimport OnlineSocket from \"./OnlineSocket\";\n\nconst HEIGHT = 85 * window.innerHeight / 100;\nconst SQUARES = 64;\nconst ROWS = 8;\nconst COLUMNS = 8;\n\nexport default function OnlineBoard({ color, prevButtons, random, socket, oppId, players, stopTimer }) {\n\n    const setColor = color;\n   \n    const createVirtualBoard = () => {\n        let board = [];\n        for (let i = 0; i < 8; i++) {\n            let row = [];\n\n            for (let j = 0; j < 8; j++)\n                if (i === 1) row.push(-setColor * 1);\n                else if (i === 6) row.push(setColor * 1);\n                else if (i !== 7 && i !== 0) row.push(0);\n\n            if (color < 0) {\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 6, -setColor * 5, -setColor * 4, -setColor * 3, -setColor * 2);\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 6, setColor * 5, setColor * 4, setColor * 3, setColor * 2);    \n            } else {\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 5, -setColor * 6, -setColor * 4, -setColor * 3, -setColor * 2);\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 5, setColor * 6, setColor * 4, setColor * 3, setColor * 2);    \n            }         \n            board.push(row);\n        }\n\n        return board;\n    };\n\n    const boardRef = useRef(null);\n    const squareRef = useRef(null);\n    \n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"online-current-move\") === null ? 1 : localStorage.getItem(\"online-current-move\"));\n    const [currentTotalCoords, setCurrentTotalCoords] = useState(null);\n    const [oldIdx, setOldIdx] = useState(null);\n    const [possibleMoves, setPossibleMoves] = useState(null);\n    const [activePiece, setActivePiece] = useState(null);\n    const [dropPiecer, setActiveDrop] = useState(null);\n    const [virtualBoard, setVirtualBoard] = useState(localStorage.getItem(\"online-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"online-board\")));\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\n    const [previewMoves, setPreviewMoves] = useState([]);\n    const [gameRunning, setGameRunning] = useState(true);\n    const [pawnTransform, setPawnTransform] = useState(null);\n   \n    const [sendPiece, setSendPiece] = useState(null);\n\n    const previewVirtualBoard = useRef(virtualBoard);\n    const squareElements = useRef(null);\n    const currSquareElement = useRef([]);\n    const oldChildren = useRef([]);\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\n    const rookMoved = useRef({\n        \"2\": {\n            \"left\": false,\n            \"right\": false\n        },\n\n        \"-2\": {\n            \"left\": false,\n            \"right\": false\n        }\n    });\n\n    const piecesCode = {\n        1: faChessPawn,\n        2: faChessRook,\n        3: faChessKnight,\n        4: faChessBishop,\n        5: faChessQueen,\n        6: faChessKing\n    };\n\n    const pieceSound = new Audio(pieceMoveSound);\n    const pieceCapture = new Audio(pieceCaptureSound);\n    pieceCapture.volume = 0.3;\n\n\n    const minX = boardRef.current?.offsetLeft;\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\n\n    const minY = boardRef.current?.offsetTop;\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\n\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\n\n    const player2Color = virtualBoard[0][0] > 0 ? \"white\" : \"black\";\n    const player1Color = player2Color === \"white\" ? \"black\" : \"white\";\n\n    // Function for checking the check \n\n    const getPossibleMoves = (pieceCode, coords, board) => {\n        const piece = Math.abs(pieceCode);\n        let possibleMoves = [];\n\n        // Current coordonates\n        const currentX = parseInt(coords / 8);\n        const currentY = coords % 8; \n\n\n        // Code for pawn\n        if (piece === 1) {\n\n            // Coordonates for possible moves\n            const newDiagX = currentX - (pieceCode * setColor);\n            const newDiagY = currentY + (pieceCode * setColor);\n            const newDiagY2 = currentY - (pieceCode * setColor);\n            \n            const newCoords = newDiagX * 8 + newDiagY;\n            const newCoords2 = newDiagX * 8 + newDiagY2;\n            const newFrontCoords = newDiagX * 8 + currentY;\n            const frontElement = board[newDiagX] &&\n                                 board[newDiagX][currentY] &&\n                                 board[newDiagX][currentY];\n\n\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\n\n           \n            \n            const diagonalElement = board[newDiagX] &&\n                                    board[newDiagX][newDiagY] &&\n                                    board[newDiagX][newDiagY];\n\n            const diagonalElement2 = board[newDiagX] &&\n                                     board[newDiagX][newDiagY2] &&\n                                     board[newDiagX][newDiagY2];\n            \n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\n               \n                const newFrontCoords = newFrontX * 8 + currentY;\n\n                const newCoordsSquare = board[newFrontX][currentY];\n                if (newCoordsSquare === 0) possibleMoves.push(newFrontCoords);\n                \n            }\n\n            if (diagonalElement2 !== 0) {\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\n            }\n           \n            if (diagonalElement === 0) return possibleMoves;\n            \n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\n\n        } else if (piece === 2) {\n\n            if (currentY > 1) {\n                for (let i = currentY - 1; i >= 0; i--) {\n                    const newCoords = currentX * 8 + i;\n                    \n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);    \n \n                       \n                    }\n                }\n            }\n\n            if (currentY < 7) {\n                for (let i = currentY + 1; i < 8; i++) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                             break;\n                        } else possibleMoves.push(newCoords);    \n\n                       \n                    }\n                }\n            } \n\n            if (currentX > 1) {\n                for (let i = currentX - 1; i >= 0; i--) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                                           \n                       \n                    }\n                }\n            }\n\n            if (currentX < 7) {\n                for (let i = currentX + 1; i < 8; i++) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n                        \n                      \n                    }\n\n                }\n            } \n        } else if (piece === 3) {\n\n            const pieceMoves = [\n                {\n                    x: currentX - 2,\n                    y: currentY - 1\n                },\n                \n                {\n                    x: currentX - 2,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX + 2,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX + 2,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY - 2\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY + 2\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY - 2\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY + 2\n                }\n            ];\n\n            pieceMoves.forEach(pieceMove => {\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\n                const newSquare = board[pieceMove.x] &&\n                                  board[pieceMove.x][pieceMove.y] &&\n                                  board[pieceMove.x][pieceMove.y];\n\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\n                    if (newSquare !== 0) {\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                    }\n                    else possibleMoves.push(newCoords);\n\n                   \n                }\n            });\n        } else if (piece === 4) {\n            if (currentX >= 1 && currentY >= 1) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            \n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n                }\n            }\n\n            if (currentX >= 1 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n\n                }\n            } \n\n            if (currentX <= 7 && currentY >= 0) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n  \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n                }\n            }\n\n            if (currentX <= 7 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                       \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves, newSquare, board, newX, newY);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n\n                }\n            } \n        } else if (piece === 5) {\n            console.log(board); \n\n            if (currentY > 1) {\n                for (let i = currentY - 1; i >= 0; i--) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);   \n                                         \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentY < 7) {\n                for (let i = currentY + 1; i < 8; i++) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {   \n\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n        \n                        console.log('empty text just for fun', possibleMoves);\n                    }\n                }\n            } \n\n            if (currentX > 1) {\n                for (let i = currentX - 1; i >= 0; i--) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newCoords, possibleMoves);\n                    }   \n                }\n            }\n\n            if (currentX < 7) {\n                for (let i = currentX + 1; i < 8; i++) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n        \n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n\n                }\n            }\n            \n            if (currentX >= 1 && currentY >= 1) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    console.log(newSquare, newX, newY, pieceCode);\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            }\n\n            if (currentX >= 1 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    console.log(newSquare, newX, newY);\n                    if (newSquare !== undefined) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            } \n\n            if (currentX <= 7 && currentY >= 0) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n        \n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            }\n\n            if (currentX <= 7 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                   \n                    if (newSquare !== undefined) {\n                        console.log(newX, newY);\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n\n                }\n            } \n        } else if (piece === 6) {\n            const pieceMoves = [\n                {\n                    x: currentX,\n                    y: currentY - 1\n                },\n                \n                {\n                    x: currentX,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY \n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY + 1\n                }\n            ];\n\n            pieceMoves.forEach(pieceMove => {\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\n                const newSquare = board[pieceMove.x] &&\n                                  board[pieceMove.x][pieceMove.y] &&\n                                  board[pieceMove.x][pieceMove.y];\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\n                    if (newSquare !== 0) {\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                    } else possibleMoves.push(newCoords);\n\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\n                }\n            });\n\n            // Movement for rocade\n            console.log(kingsMoved.current[pieceCode]);\n            if (!kingsMoved.current[pieceCode]) {\n                console.log('rocade', rookMoved);\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\n\n                const smallRocadeSquare = board[currentX] &&\n                                          board[currentX][currentY + 2] &&\n                                          board[currentX][currentY + 2];\n\n                const bigRocadeSquare = board[currentX] &&\n                                        board[currentX][currentY - 3] &&\n                                        board[currentX][currentY - 3];\n\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\n\n                // Checking if the squares between king and rook are empty \n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\n                    const rocadeX = parseInt(i / 8);\n                    const rocadeY = i % 8;\n                   \n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\n                } \n\n                for (let i = bigRocadeCoords; i < coords; i++) {\n                    const rocadeX = parseInt(i / 8);\n                    const rocadeY = i % 8;\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\n                } \n\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\n                    possibleMoves.push({\n                        king: smallRocadeCoords,\n                        rook: smallRocadeRookCoords,\n                        rocade: \"s\"\n                    });\n                } \n\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\n                    possibleMoves.push({\n                        king: bigRocadeCoords,\n                        rook: bigRocadeRookCoords,\n                        rocade: \"b\"\n                    });\n                }\n\n                \n\n                // possibleMoves.push(smallRocade);\n                // possibleMoves.push(bigRocade);\n            }\n        }\n      \n        return possibleMoves;\n    };\n\n    const dragPiece = (e, square) => {\n        \n        if (!gameRunning) return;\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\n\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\n        const containerElement = element.parentElement;\n     \n        const x = e.clientX - 20;\n        const y = e.clientY - 20;\n        \n        containerElement.style.position = 'absolute';\n        containerElement.style.left = `${x}px`;\n        containerElement.style.top = `${y}px`;\n        \n        setActivePiece(containerElement);\n        setActiveDrop(parseInt(containerElement.classList[2]));\n        let newTotalCoords;\n        currSquareElement.current.forEach((square, idx) => {\n            if (square === containerElement.parentElement) newTotalCoords = idx;\n        });\n\n        setOldIdx(newTotalCoords);\n\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\n      \n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\n        else {\n            setPossibleMoves(currPossibleMoves);\n\n            // Removing old preview dots\n            previewMoves && previewMoves.forEach(move => {\n                const oldPreviewMoves = move.firstChild;\n               \n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\n            });\n        \n            let newPreviewMoves = [];\n            currPossibleMoves.forEach((move, idx) => {\n                setTimeout(() => {\n                    const currSquare = currSquareElement.current[move];\n\n                    if (currSquare && currSquare.firstChild == null) {\n                        const dotElement = document.createElement('div');\n                        dotElement.classList.add('possible-move')\n\n                        currSquare.appendChild(dotElement);\n                       \n                        newPreviewMoves.push(currSquare);\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\n                        currSquare.firstChild.firstChild.classList.add('attacked');\n                        newPreviewMoves.push(currSquare);\n                    }\n                }, idx * 0);\n            });\n\n            setPreviewMoves(newPreviewMoves);\n        }\n       \n    };\n    \n    const movePiece = e => {\n        \n        if (!activePiece) return;\n        const x = e.clientX - 20;\n        const y = e.clientY - 20;\n        activePiece.style.position = 'absolute';\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\n        activePiece.style.zIndex = 3;\n\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\n        \n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\n       \n    };\n    \n    const dropPiece = (e, pieceCode) => {\n        \n        if (!activePiece || !squareRef.current || oldIdx === null) return;\n        if (!possibleMoves) return;\n        \n        \n        setActivePiece(null);\n       \n        const currentX = squareRef.current?.x;\n        const currentY = squareRef.current?.y;\n        let rocade = false;\n        const idx = currentX * 8 + currentY;\n        const oldX = parseInt(oldIdx / 8);\n        const oldY = oldIdx % 8;\n\n        const sameIndex = possibleMoves.find(move => {\n            if (typeof move === 'object') rocade = move;\n            return idx === (typeof move === 'object' ? move.king : move);\n        });\n\n        activePiece.style.left = 'initial';\n        activePiece.style.top= 'initial';\n        activePiece.position = 'relative';\n        activePiece.style.zIndex = 'initial';\n        if (currentMove != setColor) return;\n        if (players !== 2) return;\n\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\n        const otherBoard = cloneDeep(previewVirtualBoard.current);\n        otherBoard[oldX][oldY] = 0;\n        otherBoard[currentX][currentY] = pieceCode; \n        previewVirtualBoard.current = otherBoard;\n      \n\n        let squaresVirtualBoard = [];\n\n        previewVirtualBoard.current.forEach(row => {\n            row.forEach(square => squaresVirtualBoard.push(square));\n        });\n        \n        let kingSquare;\n\n        squaresVirtualBoard.forEach((square, totalIdx) => {\n            const iconColor = square && square < 0 ? -1 : 1;\n\n            const x = parseInt(totalIdx / 8);\n            const y = parseInt(totalIdx % 8);\n\n            if (square === currentMove * 6 && !checkOppositeColor(iconColor, currentMove)) kingSquare = totalIdx;\n        });  \n\n\n        const check = checkCheckOptimised(kingSquare, currentMove * 6);\n        console.log(check, previewVirtualBoard.current);\n\n        let sound = \"move\";\n\n        if (sameIndex !== undefined && !check) {  \n\n            // Sound of piece moving\n            pieceSound.play();\n\n            const squareDOM = currSquareElement.current[idx];\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\n            squareRef.current = null;\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\n         \n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\n                // squareDOM.innerHTML = '';\n                pieceSound.pause();\n                pieceCapture.play();\n                sound = \"take\";\n            }\n            \n            let newPiece = pieceCode;\n    \n\n            // Piece being moved to new square\n            if ((squareDOM && pieceCode === 1 && currentX === 0) || (squareDOM && pieceCode === -1 && currentX === 7)) {\n                \n               \n                \n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\n                const leftContainers = containers;  \n              \n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\n                    return (\n                        <div \n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\n                        >\n                            <FontAwesomeIcon \n                                icon={piece} \n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \n                                code={pieceCode}\n                                \n                            />\n                        </div>\n                    );\n                }) : activePiece;\n\n                setPawnTransform({\n                    idx: idx,\n                    elements: elements\n                });\n\n            } else { \n                setPawnTransform(null);\n            }\n\n            // Removing old preview dots\n            previewMoves && previewMoves.forEach(move => {\n                const oldPreviewMoves = move.firstChild;\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\n                    move.removeChild(oldPreviewMoves);\n                }\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\n            });\n\n            // Checking if it's rocade\n\n            if (rocade) {\n                if (rocade.rocade === 's') {\n                    const rookSquare = currSquareElement.current[rocade.rook];\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\n                    rookSquare.appendChild(rookInit);\n                } else if (rocade.rocade === 'b') {\n                    const rookSquare = currSquareElement.current[rocade.rook];\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\n                    rookSquare.appendChild(rookInit);\n                }\n            }\n\n            if (Math.abs(dropPiecer) === 6) {\n                kingsMoved.current[dropPiecer] = true;\n                \n            } else if (dropPiecer === 2) {\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\n              \n            } else if (dropPiecer === -2) {\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\n            }\n   \n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\n            \n            // Checking if it's giving checkmate to the opponent\n            let oppositeKingSquare, newBoard = [];\n\n            cloneVirtualBoard.forEach(row => {\n                row.forEach(square => newBoard.push(square));\n            });\n\n            newBoard.forEach((square, totalIdx) => {\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\n            });\n            \n            const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\n         \n            if (checkMateOpponent) setGameRunning(false);\n\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\n            console.log(checkEqual);\n            if (checkEqual) setGameRunning(false);\n            \n            const mirrorOldX = 7 - oldX;\n            const mirrorOldY = 7 - oldY;\n            const mirrorOldIdx = mirrorOldX * 8 + mirrorOldY;\n           \n            const mirrorNewX = 7 - currentX;\n            const mirrorNewY = 7 - currentY;\n            const mirrorNewIdx = mirrorNewX * 8 + mirrorNewY;\n            \n            setSendPiece(mirrorOldIdx + mirrorNewIdx + pieceCode);\n            socket.emit(\"move-piece\", mirrorOldIdx, mirrorNewIdx, pieceCode, sound);\n            \n            \n\n            localStorage.setItem(\"online-current-move\", -currentMove);\n            \n            stopTimer(currentMove === 1 ? true : currentMove === -1 ? false : null);\n            setCurrentMove(-currentMove);\n\n\n            localStorage.setItem(\"online-board\", JSON.stringify(cloneVirtualBoard));\n            setNewVirtualBoard(cloneVirtualBoard);\n\n            // console.log(checkMateOpponent);\n           \n            \n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\n        \n    };\n\n    const getContainers = (elements, piece) => {\n\n        let currBoard = [];\n        console.log(piece);\n        newVirtualBoard.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const mySquaresClone = currBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, piece) && square !== 0) return square;\n        });\n\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\n\n      \n\n        const result = elements.filter((element, elementIdx) => {\n            let count = 0;\n            mySquares.forEach(square => {\n                if (square - 2 === elementIdx) count++;\n            });\n\n           \n\n            if (count < 1 && elementIdx === 3) {\n                console.log('queen not working')\n                return element;\n            }\n            else if (count < 2 && elementIdx !== 3) return element;\n        });\n\n        return result;\n    };\n\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\n\n        // Get transformed piece's code\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\n        const newBoard = cloneDeep(newVirtualBoard);\n        const currentX = parseInt(idx / 8);\n        const currentY = idx % 8;\n        const oldX = parseInt(oldIdx / 8);\n        const oldY = oldIdx % 8;\n        const totalIdx = currentX * 8 + currentY + + (currentX % 2 !== 0 ? 1 : 0)\n        newBoard[currentX][currentY] = transformPieceCode;\n        newBoard[oldX][oldY] = 0;\n        setNewVirtualBoard(newBoard);\n        \n        previewVirtualBoard.current = newBoard;\n    \n        \n        setPawnTransform({\n            idx: idx,\n            piece: transformPieceCode,\n            elements: []\n        });\n\n        localStorage.setItem(\"online-board\", JSON.stringify(newBoard));\n    };\n\n    const checkOppositeColor = (piece1, piece2) => {\n        if (piece1 < 0 && piece2 > 0) return true;\n        else if (piece1 > 0 && piece2 < 0) return true;\n        return false;\n    }\n\n    const checkCheck = (kingSquare, kCode, isFromCheckMate = false) => {\n\n        // console.log('lalalalaalaallapgdkkdfpgogjodjfgjdp', previewVirtualBoard.current, kingSquare);\n        let currBoard = [];\n\n        previewVirtualBoard.current.forEach(row => {\n            row.forEach(square => {\n                currBoard.push(square);\n            });\n        });\n\n        const oppositeSquaresClone = currBoard.map((square, idx) => {\n            if (checkOppositeColor(kCode, square)) return {\n                pieceCode: square,\n                coords: idx\n            };\n        });\n\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\n\n        // Checking if king is attacked\n\n        const check = oppositeSquares.some(square => {\n         \n            const possibleMovesCheck = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\n          \n            return possibleMovesCheck.some(currSquare => {\n               \n                return currSquare === kingSquare;\n            });\n        });\n\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\n\n        if (check && !isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n\n        previewVirtualBoard.current = oldBoard;\n\n        return check;\n    };\n\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\n\n        // Getting coords\n        const currentX = parseInt(kingSquare / 8);\n        const currentY = kingSquare % 8;\n        const pieceCode = kCode / (-6);\n\n        let check = false;\n\n        const kingPossibleSquares = [\n            [currentX - 1, currentY - 1],\n            [currentX - 1, currentY],\n            [currentX - 1, currentY + 1],\n            [currentX, currentY - 1],\n            [currentX, currentY + 1],\n            [currentX + 1, currentY - 1],\n            [currentX + 1, currentY],\n            [currentX + 1, currentY + 1]\n        ];\n\n        console.log(previewVirtualBoard.current, pieceCode);\n\n        kingPossibleSquares.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === -kCode && square !== null) {\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                check = true;\n            }\n        });\n\n        // Pawns \n\n        const pawnPossibleSquares = [\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\n        ];\n        \n        console.log(pawnPossibleSquares);\n\n        pawnPossibleSquares.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === pieceCode) {\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                console.log('check');\n                check = true;\n            }\n        });\n        \n        // Rows\n\n        if (currentX > 0) {\n            for (let i = currentX - 1; i >= 0; i--) {\n                const rowSquare =   previewVirtualBoard.current[i] && \n                                    previewVirtualBoard.current[i][currentY] &&\n                                    previewVirtualBoard.current[i][currentY];\n                \n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (rowSquare !== 0) break;\n            }\n        }\n\n        if (currentX < ROWS - 1) {\n            for (let i = currentX + 1; i < ROWS; i++) {\n                const rowSquare =   previewVirtualBoard.current[i] && \n                                    previewVirtualBoard.current[i][currentY] &&\n                                    previewVirtualBoard.current[i][currentY];\n\n                console.log(rowSquare, pieceCode, previewVirtualBoard.current);\n                \n                if (rowSquare === 2 * pieceCode || rowSquare * pieceCode === 5) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) {\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\n                        console.log(checkMate);\n                    }\n                    console.log(\"here in if\")\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (rowSquare !== 0) break;\n            }\n        }\n\n        // Columns \n\n        if (currentY > 0) {\n            for (let i = currentY - 1; i >= 0; i--) {\n                const columnSquare = previewVirtualBoard.current[currentX] &&\n                                     previewVirtualBoard.current[currentX][i] && \n                                     previewVirtualBoard.current[currentX][i];\n                \n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (columnSquare !== 0) break;\n            }\n        }\n\n        if (currentY < COLUMNS - 1) {\n            for (let i = currentX + 1; i < COLUMNS; i++) {\n                const columnSquare = previewVirtualBoard.current[currentX] &&\n                                     previewVirtualBoard.current[currentX][i] && \n                                     previewVirtualBoard.current[currentX][i];\n                \n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (columnSquare !== 0) break;\n            }\n        }\n\n        // Diagonal top left\n        \n        if (currentX > 0 && currentY > 0) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX - i;\n                const newY = currentY - i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal top right\n\n        if (currentX > 0 && currentY < COLUMNS - 1) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX - i;\n                const newY = currentY + i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal bottom left\n\n        if (currentX < ROWS - 1 && currentY > 0) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX + i;\n                const newY = currentY - i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal bottom right\n\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX + i;\n                const newY = currentY + i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Knight moves\n\n        const knightPossibleMoves = [\n            [currentX - 2, currentY - 1],\n            [currentX - 2, currentY + 1],\n            [currentX + 2, currentY - 1],\n            [currentX + 2, currentY + 1],\n            [currentX - 1, currentY - 2],\n            [currentX - 1, currentY + 2],\n            [currentX + 1, currentY - 2],\n            [currentX + 1, currentY + 2]\n        ];\n\n        \n        \n        knightPossibleMoves.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === pieceCode * 3) { \n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                check = true;\n            }\n        });\n\n        return check;\n    };\n\n    const legalBoard = (board, kCode) => {\n        return board.some(row => {\n            return row.some(cell => cell === kCode);\n        });\n    };\n\n    // Checking the check-mate\n\n    const checkCheckmate = (kCode, board) => {\n\n        console.log(board);\n        const constantBoard = board;\n        let currBoard = [];\n\n        board.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const mySquaresClone = currBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\n                pieceCode: square,\n                coords: idx\n            }\n        });\n\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\n        console.log(mySquares);\n        let checkMate = true;\n\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\n\n        mySquares.forEach(square => {\n\n            // Next possible moves to check if it's checkmate\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\n            console.log(possibleMovesCheckmate);\n\n            possibleMovesCheckmate.forEach(move => {\n                const currX = parseInt(square.coords / 8);\n                const currY = square.coords % 8;\n                const newX = parseInt(move / 8);\n                const newY = move % 8;\n                const newBoard = cloneDeep(constantBoard);\n\n                newBoard[currX][currY] = 0;\n                \n                if (newBoard != null && (newBoard[newX] != null) && (newBoard[newX][newY] != null)) {\n                    if (newBoard[newX][newY] !== 0) {\n                        const enemyPieceNumber = newBoard[newX][newY];\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\n                    } else newBoard[newX][newY] = square.pieceCode;\n                }\n\n                \n                previewVirtualBoard.current = cloneDeep(newBoard);\n\n                let allInOneBoard = [];\n\n                previewVirtualBoard.current.forEach(row => {\n                    row.forEach(square => allInOneBoard.push(square));\n                });\n\n\n\n                console.log(newBoard, kCode);\n\n                console.log(allInOneBoard);\n\n                let kingSquare = -1;\n\n                allInOneBoard.forEach((square, idx) => {\n                    if (square === kCode) kingSquare = idx;\n                });\n\n\n                console.log(kingSquare);\n\n                const possibleBoard = legalBoard(newBoard, kCode);\n                \n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\n                console.log(newBoardCheck, kingSquare, kCode);\n                if (!newBoardCheck && possibleBoard) checkMate = false;\n                \n            });\n        });\n        \n\n        previewVirtualBoard.current = oldBoard;\n        if (checkMate) setGameRunning(false);\n        return checkMate;\n        \n    };\n\n    const checkPat = (pieceCode, board) => {\n        let currBoard = [];\n       \n        board.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\n            if (checkOppositeColor(pieceCode, square)) return {\n                pieceCode: square,\n                coords: coords\n            };\n        });\n\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\n\n        return oppositeSquares.every(square => {\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\n         \n            return oppPossibleMoves.length === 0;\n        });\n    };\n\n\n    const addSquares = () => {\n        let squareComponents = [];\n\n        const board = newVirtualBoard.map((row, rowIdx) => {\n\n\n            const rows = row.map((square, squareIdx) => {\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\n                const realIdx = rowIdx * 8 + squareIdx;\n               \n                const squareComponent = \n                    <div className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} key={squareIdx} ref={ref => { \n                        currSquareElement.current[realIdx] = ref;\n                    }}>\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\n                            pawnTransform.elements.length > 0 ? (<div \n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\n                                key={totalIdx}\n                            >   \n                                {pawnTransform.elements}  \n                            </div>)\n                            : (\n                                <div \n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\n                                    onMouseMove={e => movePiece(e)}\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \n                                    key={totalIdx}\n                                >   \n                                    <FontAwesomeIcon \n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \n                                        code={pawnTransform.piece}\n                                    />\n                                </div>\n                            )\n                        ) : square !== 0 ? (\n                            <div \n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\n                                onMouseMove={e => movePiece(e)}\n                                onMouseUp={e => dropPiece(e, square)} \n                                key={totalIdx}\n                            >   \n                                <FontAwesomeIcon \n                                    icon={piecesCode[Math.abs(square).toString()]} \n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \n                                    code={square}\n                                />\n                            </div>\n                        ) : \"\"}\n                    </div>;\n\n                return squareComponent;\n            });\n            return (\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\n                    {rows}\n                </div>\n            );\n        });\n\n        squareElements.current = squareComponents;\n\n        return board;\n    };\n\n    const addLetters = () => {\n        const letterComponent = parseInt(setColor) === 1 ? (\n            <div className=\"letters\"> \n                <p>A</p> \n                <p>B</p> \n                <p>C</p> \n                <p>D</p> \n                <p>E</p> \n                <p>F</p> \n                <p>G</p> \n                <p>H</p> \n            </div>\n        ) : (\n            <div className=\"letters\"> \n                <p>H</p> \n                <p>G</p> \n                <p>F</p> \n                <p>E</p> \n                <p>D</p> \n                <p>C</p> \n                <p>B</p> \n                <p>A</p> \n            </div>\n        );\n\n        return letterComponent;\n    };\n\n    \n    useEffect(() => {\n        socket.on('send-piece', (oldIdx, newIdx, pieceCode, sound) => {\n            const iconContainerElement = currSquareElement.current[oldIdx].firstChild;\n            console.log('use effect', newVirtualBoard, sendPiece);\n            const cloneVirtualBoard = cloneDeep(newVirtualBoard);\n            const serverOldX = parseInt(oldIdx / 8);\n            const serverOldY = oldIdx % 8;\n            cloneVirtualBoard[serverOldX][serverOldY] = 0;\n            const serverNewX = parseInt(newIdx / 8);\n            const serverNewY = newIdx % 8;\n            cloneVirtualBoard[serverNewX][serverNewY] = pieceCode;\n            stopTimer(pieceCode < 0 ? false : true);\n            pieceSound.pause();\n            pieceCapture.pause();\n            pieceSound.currentTime = 0;\n            pieceCapture.currentTime = 0;\n            iconContainerElement.classList.add('opponent');\n            iconContainerElement.style.setProperty(\"--element-left\", `${(serverNewY - serverOldY) * 100}px`);\n            iconContainerElement.style.setProperty(\"--element-top\", `${(serverNewX - serverOldX) * 100}px`)\n            iconContainerElement.classList.add('changed-move');\n\n            previewVirtualBoard.current = cloneDeep(cloneVirtualBoard);\n\n\n            iconContainerElement.addEventListener(\"transitionend\", () => {\n                if (sound === \"move\") pieceSound.play();\n                else pieceCapture.play();\n                iconContainerElement.style.zIndex = 'initial';\n                iconContainerElement.style.position = 'initial';\n                iconContainerElement.style.left = `initial`;\n                iconContainerElement.style.top = `initial`;\n                iconContainerElement.style.transform = 'initial';\n                localStorage.setItem(\"online-current-move\", -currentMove);\n                setCurrentMove(-currentMove);\n                localStorage.setItem(\"online-board\", JSON.stringify(cloneVirtualBoard));\n                setNewVirtualBoard(cloneVirtualBoard);      \n            });\n        });\n        \n    }, [sendPiece]);\n\n    return (\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\n            {addSquares()}\n            {addLetters()}\n        </div>\n    );\n};\n","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/PracticeBoard.jsx",["148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175"],"import React, { useState, useEffect, useRef } from \"react\";\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { isArray } from \"lodash\";\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\n\nimport '../styles/board.css';\nimport \"../styles/practice.css\";\n\nconst HEIGHT = 85 * window.innerHeight / 100;\nconst ROWS = 8;\nconst COLUMNS = 8;\n\nexport default function PracticeBoard({ color, prevButtons, random, difficulty, choosePiece, deleteIcon }) {\n\n    const setColor = localStorage.getItem(\"set-color\") ? parseInt(localStorage.getItem(\"set-color\")) : color;\n    localStorage.setItem(\"set-color\", setColor);\n    const currDifficulty = localStorage.getItem(\"practice-difficulty\") !== null ? difficulty : JSON.parse(localStorage.getItem(\"practice-difficulty\"));\n    localStorage.setItem(\"practice-difficulty\", JSON.stringify(difficulty));\n\n    const createVirtualBoard = () => {\n        let board = [];\n        for (let i = 0; i < 8; i++) {\n            let row = [];\n\n            for (let j = 0; j < 8; j++)\n                row.push(0);\n                \n            board.push(row);\n        }\n\n        return board;\n    };\n\n    const boardRef = useRef(null);\n    const squareRef = useRef(null);\n    \n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"practice-current-move\") === null ? 1 : localStorage.getItem(\"practice-current-move\"));\n    const [oldIdx, setOldIdx] = useState(null);\n    const [possibleMoves, setPossibleMoves] = useState(null);\n    const [activePiece, setActivePiece] = useState(null);\n    const [dropPiecer, setActiveDrop] = useState(null);\n    const [virtualBoard, setVirtualBoard] = useState(localStorage.getItem(\"practice-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"practice-board\")));\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\n    const [previewMoves, setPreviewMoves] = useState([]);\n    const [gameRunning, setGameRunning] = useState(true);\n    const [pawnTransform, setPawnTransform] = useState(null);\n    const [prevMoves, setPrevMoves] = useState(localStorage.getItem(\"practice-prev-moves\") !== null ? JSON.parse(localStorage.getItem(\"practice-prev-moves\")) : []);\n    const [nextMoves, setNextMoves] = useState(localStorage.getItem(\"practice-next-moves\") !== null ? JSON.parse(localStorage.getItem(\"practice-next-moves\")) : []);\n\n    const previewVirtualBoard = useRef(virtualBoard);\n    const squareElements = useRef(null);\n    const currSquareElement = useRef([]);\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\n    const rookMoved = useRef({\n        \"2\": {\n            \"left\": false,\n            \"right\": false\n        },\n\n        \"-2\": {\n            \"left\": false,\n            \"right\": false\n        }\n    });\n\n    const piecesCode = {\n        1: faChessPawn,\n        2: faChessRook,\n        3: faChessKnight,\n        4: faChessBishop,\n        5: faChessQueen,\n        6: faChessKing\n    };\n\n    console.log(virtualBoard);\n\n    const pieceSound = new Audio(pieceMoveSound);\n    const pieceCapture = new Audio(pieceCaptureSound);\n    pieceCapture.volume = 0.3;\n\n    const minX = boardRef.current?.offsetLeft;\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\n\n    const minY = boardRef.current?.offsetTop;\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\n\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\n\n    console.log(squareWidth, squareHeight);\n    const player2Color = virtualBoard[0][0] > 0 ? \"white\" : \"black\";\n    const player1Color = player2Color === \"white\" ? \"black\" : \"white\";\n\n    // Checking everytime prev/next button is pressed\n    \n    useEffect(() => {\n       \n        if (!prevButtons) return;\n        if (prevButtons.classList.contains('prev-button') && prevMoves.length === 0) return;\n        if (prevButtons.classList.contains('next-button') && nextMoves.length === 0) return;\n        \n        const lastMove = prevButtons.classList.contains('prev-button') ? prevMoves[prevMoves.length - 1] : nextMoves[nextMoves.length - 1];\n        console.log(prevButtons, prevMoves, lastMove.pieceCode);\n        const currBoard = cloneDeep(newVirtualBoard);\n        const oldX = parseInt(lastMove.oldIdx / 8);\n        const oldY = lastMove.oldIdx % 8;\n        const newX = parseInt(lastMove.newIdx / 8);\n        const newY = lastMove.newIdx % 8;\n        currBoard[oldX][oldY] = prevButtons.classList.contains('prev-button') ? lastMove.pieceCode : 0;\n        currBoard[newX][newY] = lastMove.oldPieceCode;\n    \n        setNewVirtualBoard(currBoard);\n\n        if (prevButtons.classList.contains('prev-button')) {\n            const newNextMoves = [...nextMoves,\n                {\n                    oldIdx: lastMove.oldIdx,\n                    newIdx: lastMove.newIdx,\n                    oldPieceCode: lastMove.pieceCode,\n                    pieceCode: lastMove.oldPieceCode\n                }\n            ];\n            localStorage.setItem(\"practice-prev-moves\", JSON.stringify(prevMoves.slice(0, -1)));\n            localStorage.setItem(\"practice-next-moves\", JSON.stringify(newNextMoves));\n\n            setPrevMoves(prevMoves.slice(0, -1));\n            setNextMoves(newNextMoves);\n\n        } else  {\n            console.log('ok from here');\n            const newPrevMoves = [...prevMoves,\n                {\n                    oldIdx: lastMove.oldIdx,\n                    newIdx: lastMove.newIdx,\n                    oldPieceCode: lastMove.pieceCode,\n                    pieceCode: lastMove.oldPieceCode\n                }\n            ];\n\n            localStorage.setItem(\"practice-prev-moves\", JSON.stringify(newPrevMoves));\n            localStorage.setItem(\"practice-next-moves\", JSON.stringify(nextMoves.slice(0, -1)));\n        \n            setNextMoves(nextMoves.slice(0, -1));\n            setPrevMoves(newPrevMoves);\n        }\n\n        localStorage.setItem(\"practice-current-move\", -currentMove);\n        localStorage.setItem(\"practice-board\", JSON.stringify(currBoard));\n        \n        setCurrentMove(-currentMove);\n\n    }, [random]);\n\n    useEffect(() => {\n        if (typeof choosePiece !== \"number\") return;\n        let idx;\n        currSquareElement.current.forEach((square, squareIdx) => square.classList.contains('selected') ? idx = squareIdx : null);\n        if (!idx) return;\n        let cloneBoard = cloneDeep(newVirtualBoard);\n        cloneBoard[parseInt(idx / 8)][idx % 8] = choosePiece;\n        setNewVirtualBoard(cloneBoard);\n        previewVirtualBoard.current = cloneBoard;\n        console.log(cloneBoard);\n\n    }, [choosePiece]);\n\n    useEffect(() => {\n        if (deleteIcon === null) return;\n    \n        let idx;\n        currSquareElement.current.forEach((square, squareIdx) => square.classList.contains('selected') ? idx = squareIdx : null);\n        if (!idx) return;\n\n        let cloneBoard = cloneDeep(newVirtualBoard);\n        cloneBoard[parseInt(idx / 8)][idx % 8] = 0;\n        setNewVirtualBoard(cloneBoard);\n        previewVirtualBoard.current = cloneBoard;\n\n    }, [deleteIcon]);\n\n    const selectSquare = (square) => {\n        const currSelected = currSquareElement.current.find(squareElement => squareElement.classList.contains('selected'));\n        currSelected && currSelected.classList.remove('selected');\n        currSquareElement.current.forEach(currSquare => currSquare.classList.remove('selected'));\n        if (square !== currSelected)  square.classList.add('selected');\n    }\n\n    const isKing = (piece) => {\n        \n    }\n\n\n    // Function for checking the check \n\n    const getPossibleMoves = (pieceCode, coords, board) => {\n        const piece = Math.abs(pieceCode);\n        let possibleMoves = [];\n\n        // Current coordonates\n        const currentX = parseInt(coords / 8);\n        const currentY = coords % 8; \n\n        console.log(currentX, currentY);\n\n        // Code for pawn\n        if (piece === 1) {\n\n            // Coordonates for possible moves\n            const newDiagX = currentX - (pieceCode * setColor);\n            const newDiagY = currentY + (pieceCode * setColor);\n            const newDiagY2 = currentY - (pieceCode * setColor);\n            \n            const newCoords = newDiagX * 8 + newDiagY;\n            const newCoords2 = newDiagX * 8 + newDiagY2;\n            const newFrontCoords = newDiagX * 8 + currentY;\n            const frontElement = board[newDiagX] &&\n                                 board[newDiagX][currentY] &&\n                                 board[newDiagX][currentY];\n\n            console.log(frontElement);\n\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\n\n            console.log(possibleMoves);\n            \n            const diagonalElement = board[newDiagX] &&\n                                    board[newDiagX][newDiagY] &&\n                                    board[newDiagX][newDiagY];\n\n            const diagonalElement2 = board[newDiagX] &&\n                                     board[newDiagX][newDiagY2] &&\n                                     board[newDiagX][newDiagY2];\n            \n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\n                console.log(newFrontX);\n                const newFrontCoords = newFrontX * 8 + currentY;\n\n                const newCoordsSquare = board[newFrontX][currentY];\n                if (newCoordsSquare === 0 && frontElement === 0) possibleMoves.push(newFrontCoords);\n            }\n\n            if (diagonalElement2 !== 0) {\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\n            }\n           \n            if (diagonalElement === 0) return possibleMoves;\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\n\n        } else if (piece === 2) {\n\n            if (currentY > 1) {\n                for (let i = currentY - 1; i >= 0; i--) {\n                    const newCoords = currentX * 8 + i;\n                    \n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);    \n \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentY < 7) {\n                for (let i = currentY + 1; i < 8; i++) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                             break;\n                        } else possibleMoves.push(newCoords);    \n\n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            } \n\n            if (currentX > 1) {\n                for (let i = currentX - 1; i >= 0; i--) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                                           \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentX < 7) {\n                for (let i = currentX + 1; i < 8; i++) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n                        \n                        console.log('empty text just for fun', newSquare);\n                    }\n\n                }\n            } \n        } else if (piece === 3) {\n\n            const pieceMoves = [\n                {\n                    x: currentX - 2,\n                    y: currentY - 1\n                },\n                \n                {\n                    x: currentX - 2,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX + 2,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX + 2,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY - 2\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY + 2\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY - 2\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY + 2\n                }\n            ];\n\n            pieceMoves.forEach(pieceMove => {\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\n                const newSquare = board[pieceMove.x] &&\n                                  board[pieceMove.x][pieceMove.y] &&\n                                  board[pieceMove.x][pieceMove.y];\n\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\n                    if (newSquare !== 0) {\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                    }\n                    else possibleMoves.push(newCoords);\n\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\n                }\n            });\n        } else if (piece === 4) {\n            if (currentX >= 1 && currentY >= 1) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n                }\n            }\n\n            if (currentX >= 1 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n\n                }\n            } \n\n            if (currentX <= 7 && currentY >= 0) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n  \n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n                }\n            }\n\n            if (currentX <= 7 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\n                       \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            console.log(possibleMoves, newSquare, board, newX, newY);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, newCoords);\n                    }\n\n                }\n            } \n        } else if (piece === 5) {\n            console.log(board); \n\n            if (currentY > 1) {\n                for (let i = currentY - 1; i >= 0; i--) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);   \n                                         \n                        console.log('empty text just for fun', newSquare);\n                    }\n                }\n            }\n\n            if (currentY < 7) {\n                for (let i = currentY + 1; i < 8; i++) {\n                    const newCoords = currentX * 8 + i;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {   \n\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n        \n                        console.log('empty text just for fun', possibleMoves);\n                    }\n                }\n            } \n\n            if (currentX > 1) {\n                for (let i = currentX - 1; i >= 0; i--) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newCoords, possibleMoves);\n                    }   \n                }\n            }\n\n            if (currentX < 7) {\n                for (let i = currentX + 1; i < 8; i++) {\n                    const newCoords = i * 8 + currentY;\n                    const newX = parseInt(newCoords / 8);\n                    const newY = parseInt(newCoords % 8);\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    \n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n        \n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n\n                }\n            }\n            \n            if (currentX >= 1 && currentY >= 1) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    console.log(newSquare, newX, newY, pieceCode);\n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            }\n\n            if (currentX >= 1 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX - i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                    console.log(newSquare, newX, newY);\n                    if (newSquare !== undefined) {\n                        \n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            } \n\n            if (currentX <= 7 && currentY >= 0) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY - i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n        \n                    if (newSquare !== undefined) {\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n                }\n            }\n\n            if (currentX <= 7 && currentY <= 7) {\n                for (let i = 1; i < 8; i++) {\n                    const newX = currentX + i;\n                    const newY = currentY + i;\n                    const newCoords = newX * 8 + newY;\n                    const newSquare = board[newX] &&\n                                      board[newX][newY] &&\n                                      board[newX][newY];\n                   \n                    if (newSquare !== undefined) {\n                        console.log(newX, newY);\n                        if (newSquare !== 0) {\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                            break;\n                        } else possibleMoves.push(newCoords);\n\n                        console.log('empty text just for fun', newSquare, possibleMoves);\n                    }\n\n                }\n            } \n        } else if (piece === 6) {\n            const pieceMoves = [\n                {\n                    x: currentX,\n                    y: currentY - 1\n                },\n                \n                {\n                    x: currentX,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY \n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX - 1,\n                    y: currentY + 1\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY - 1\n                },\n\n                {\n                    x: currentX + 1,\n                    y: currentY + 1\n                }\n            ];\n\n            pieceMoves.forEach(pieceMove => {\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\n                const newSquare = board[pieceMove.x] &&\n                                  board[pieceMove.x][pieceMove.y] &&\n                                  board[pieceMove.x][pieceMove.y];\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\n                    if (newSquare !== 0) {\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\n                    } else possibleMoves.push(newCoords);\n\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\n                }\n            });\n\n            // Movement for rocade\n            console.log(kingsMoved.current[pieceCode]);\n            if (!kingsMoved.current[pieceCode]) {\n                console.log('rocade', rookMoved);\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\n\n                const smallRocadeSquare = board[currentX] &&\n                                          board[currentX][currentY + 2] &&\n                                          board[currentX][currentY + 2];\n\n                const bigRocadeSquare = board[currentX] &&\n                                        board[currentX][currentY - 3] &&\n                                        board[currentX][currentY - 3];\n\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\n\n                // Checking if the squares between king and rook are empty \n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\n                    const rocadeX = parseInt(i / 8);\n                    const rocadeY = i % 8;\n                   \n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\n                } \n\n                for (let i = bigRocadeCoords; i < coords; i++) {\n                    const rocadeX = parseInt(i / 8);\n                    const rocadeY = i % 8;\n                    console.log('gdjigdfjhh');\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\n                } \n\n                console.log(smallRocadeEmpty, bigRocadeEmpty)\n\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\n                    possibleMoves.push({\n                        king: smallRocadeCoords,\n                        rook: smallRocadeRookCoords,\n                        rocade: \"s\"\n                    });\n                } \n\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\n                    possibleMoves.push({\n                        king: bigRocadeCoords,\n                        rook: bigRocadeRookCoords,\n                        rocade: \"b\"\n                    });\n                }\n\n                \n\n                // possibleMoves.push(smallRocade);\n                // possibleMoves.push(bigRocade);\n            }\n        }\n      \n        return possibleMoves;\n    };\n\n    const dragPiece = (e, square) => {\n        \n        if (!gameRunning) return;\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\n\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\n        const containerElement = element.parentElement;\n        console.log(containerElement, square);\n        const x = e.clientX - 20;\n        const y = e.clientY - 20;\n        console.log(x, y, square, currentMove);\n        containerElement.style.position = 'absolute';\n        containerElement.style.left = `${x}px`;\n        containerElement.style.top = `${y}px`;\n\n        \n        \n        setActivePiece(containerElement);\n        setActiveDrop(parseInt(containerElement.classList[2]));\n        let newTotalCoords;\n        currSquareElement.current.forEach((square, idx) => {\n            if (square === containerElement.parentElement) newTotalCoords = idx;\n        });\n\n        setOldIdx(newTotalCoords);\n\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\n        console.log(currPossibleMoves, newVirtualBoard, square, currentMove, newTotalCoords);\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\n        else {\n            setPossibleMoves(currPossibleMoves);\n\n            // Removing old preview dots\n            previewMoves && previewMoves.forEach(move => {\n                const oldPreviewMoves = move.firstChild;\n                console.log(move, oldPreviewMoves);\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\n            });\n        \n            let newPreviewMoves = [];\n            currPossibleMoves.forEach((move, idx) => {\n                setTimeout(() => {\n                    const currSquare = currSquareElement.current[move];\n\n                    if (currSquare && currSquare.firstChild == null) {\n                        const dotElement = document.createElement('div');\n                        dotElement.classList.add('possible-move')\n\n                        currSquare.appendChild(dotElement);\n                        console.log(currSquare);\n                        newPreviewMoves.push(currSquare);\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\n                        currSquare.firstChild.firstChild.classList.add('attacked');\n                        newPreviewMoves.push(currSquare);\n                    }\n                }, idx * 0);\n            });\n\n            setPreviewMoves(newPreviewMoves);\n        }\n       \n    };\n    \n    const movePiece = e => {\n        \n        if (!activePiece) return;\n        const x = e.clientX - 15;\n        const y = e.clientY - 15;\n        activePiece.style.position = 'absolute';\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\n        activePiece.style.zIndex = 3;\n\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\n        \n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\n        console.log(squareRef.current);\n    };\n    \n    const dropPiece = (e, pieceCode) => {\n        \n        if (!activePiece || !squareRef.current || oldIdx === null) return;\n        if (!possibleMoves) return;\n        setActivePiece(null);\n        console.log(squareRef.current?.x, squareRef.current?.y)\n        const currentX = squareRef.current?.x;\n        const currentY = squareRef.current?.y;\n        let rocade = false;\n        const idx = currentX * 8 + currentY;\n        const oldX = parseInt(oldIdx / 8);\n        const oldY = oldIdx % 8;\n\n        const sameIndex = possibleMoves.find(move => {\n            if (typeof move === 'object') rocade = move;\n            return idx === (typeof move === 'object' ? move.king : move);\n        });\n\n        activePiece.style.left = 'initial';\n        activePiece.style.top= 'initial';\n        activePiece.position = 'relative';\n        activePiece.style.zIndex = 'initial';\n        console.log(previewVirtualBoard.current);\n\n        if (setColor != currentMove) {\n            console.log('here', setColor, currentMove);\n            return;\n        }\n\n        const oldBoard = cloneDeep(newVirtualBoard);\n        const otherBoard = cloneDeep(newVirtualBoard);\n        otherBoard[oldX][oldY] = 0;\n        otherBoard[currentX][currentY] = pieceCode; \n        previewVirtualBoard.current = otherBoard;\n        console.log('afdsokogjfdjjhihijhpjhijhipfghjpifjhpgjhpijhpfgjh', previewVirtualBoard.current);\n\n        let squaresVirtualBoard = [];\n\n        previewVirtualBoard.current.forEach(row => {\n            row.forEach(square => {\n                squaresVirtualBoard.push(square);\n            });\n        });\n\n        const kingPiece = squaresVirtualBoard.some(piece => {\n            if (pieceCode < 0) return piece === -6;\n            else return piece === 6;\n        });\n\n        const opponentKingPiece = squaresVirtualBoard.some(piece => {\n            if (pieceCode < 0) return piece === 6;\n            else return piece === -6;\n        \n        });\n\n        if (!kingPiece || !opponentKingPiece) return;\n        \n        let kingSquare;\n\n        squaresVirtualBoard.forEach((square, totalIdx) => {\n            const iconColor = square && square < 0 ? -1 : 1;\n\n            const x = parseInt(totalIdx / 8);\n            const y = parseInt(totalIdx % 8);\n\n            if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) kingSquare = totalIdx;\n        });  \n\n        console.log(kingSquare, currentMove,  previewVirtualBoard.current);\n        const check = checkCheckOptimised(kingSquare, setColor * 6);\n        console.log(check);\n\n        if (sameIndex !== undefined && !check) {  \n\n            // Sound of piece moving\n            pieceSound.play();\n\n            const squareDOM = currSquareElement.current[idx];\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\n            squareRef.current = null;\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\n            console.log(cloneIcon, prevMoves);\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\n                // squareDOM.innerHTML = '';\n                pieceSound.pause();\n                pieceCapture.play();\n            }\n            \n            let newPiece = pieceCode;\n            let skipComputerMove = false;\n\n            // Piece being moved to new square\n            if ((squareDOM && pieceCode === 1 && currentX === 0 && setColor === 1) || (squareDOM && pieceCode === -1 && currentX === 7 && setColor === 1) || (squareDOM && pieceCode === 1 && currentX === 7 && setColor === -1) || (squareDOM && pieceCode === -1 && currentX === 0 && setColor === -1)) {\n                \n                console.log('here'); \n                \n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\n                const leftContainers = containers;  \n                console.log(leftContainers);\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\n                    return (\n                        <div \n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\n                        >\n                            <FontAwesomeIcon \n                                icon={piece} \n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \n                                code={pieceCode}\n                                \n                            />\n                        </div>\n                    );\n                }) : activePiece;\n\n                setPawnTransform({\n                    idx: idx,\n                    elements: elements\n                });\n\n                skipComputerMove = true;\n\n            } else setPawnTransform(null);\n\n            setPrevMoves([...prevMoves, \n                {\n                    oldIdx: oldIdx, \n                    newIdx: idx, \n                    pieceCode: pieceCode,\n                    oldPieceCode: newVirtualBoard[currentX][currentY],\n                }\n            ]);\n\n            setNextMoves([]);\n\n            // Removing old preview dots\n            previewMoves && previewMoves.forEach(move => {\n                const oldPreviewMoves = move.firstChild;\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\n                    move.removeChild(oldPreviewMoves);\n                }\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\n            });\n\n            if (rocade) {\n                if (rocade.rocade === 's') {\n                    const rookSquare = currSquareElement.current[rocade.rook];\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\n                    rookSquare.appendChild(rookInit);\n                } else if (rocade.rocade === 'b') {\n                    const rookSquare = currSquareElement.current[rocade.rook];\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\n                    rookSquare.appendChild(rookInit);\n                }\n            }\n\n            if (Math.abs(dropPiecer) === 6) {\n                kingsMoved.current[dropPiecer] = true;\n                console.log(kingsMoved.current[dropPiecer])\n            } else if (dropPiecer === 2) {\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\n                console.log(rookMoved.current[2][\"right\"]);\n            } else if (dropPiecer === -2) {\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\n            }\n   \n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\n            console.log(oldX, oldY, currentX, currentY);\n            console.log(cloneVirtualBoard);\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\n\n            console.log(cloneVirtualBoard);\n            \n            // Checking if it's giving checkmate to the opponent\n            let oppositeKingSquare, newBoard = [];\n\n            cloneVirtualBoard.forEach(row => {\n                row.forEach(square => newBoard.push(square));\n            });\n\n            newBoard.forEach((square, totalIdx) => {\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\n            });\n\n            console.log(oppositeKingSquare);\n            \n            // const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\n            // console.log(checkMateOpponent);\n            // if (checkMateOpponent) setGameRunning(false);\n\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\n            console.log(checkEqual);\n            if (checkEqual) setGameRunning(false);\n            localStorage.setItem(\"practice-current-move\", -currentMove);\n            // setCurrentMove(-currentMove);\n\n            localStorage.setItem(\"practice-board\", JSON.stringify(cloneVirtualBoard));\n            setNewVirtualBoard(cloneVirtualBoard);\n\n            if (!skipComputerMove) computerMove(cloneVirtualBoard);\n           \n            console.log(cloneVirtualBoard);\n\n            // console.log(checkMateOpponent);\n            \n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\n        \n    };\n\n    const getContainers = (elements, piece) => {\n\n        let currBoard = [];\n        console.log(piece);\n        newVirtualBoard.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const mySquaresClone = currBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, piece) && square !== 0) return square;\n        });\n\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\n\n        console.log(mySquares);\n\n        const result = elements.filter((element, elementIdx) => {\n            let count = 0;\n            mySquares.forEach(square => {\n                if (square - 2 === elementIdx) count++;\n            });\n\n            console.log(count, elementIdx);\n\n            if (count < 1 && elementIdx === 3) {\n                console.log('queen not working')\n                return element;\n            }\n            else if (count < 2 && elementIdx !== 3) return element;\n        });\n\n        return result;\n    };\n\n    const computerMove = (newBoard) => {\n        console.log('none', currentMove);\n        let currMove = currentMove, checkmate = false;\n        setCurrentMove(-currMove);\n\n        const possibleMoves = getAllMoves(-currMove, newBoard);\n        console.log(possibleMoves)\n        if (possibleMoves.length === 0) {\n            setGameRunning(false);\n            return;\n        }\n\n        let newPossibleMoves, newMove;\n\n        if (currDifficulty === \"easy\") {\n            newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n            newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n           \n        } else if (currDifficulty === \"medium\") {\n            \n            let minNum = { number: Number.POSITIVE_INFINITY };\n            possibleMoves.forEach(move => {\n                move.moves.forEach(possMove => {\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\n                        minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                        newMove = possMove;\n                        newPossibleMoves = move; \n                    }\n                });\n            });\n\n            if (minNum.number === Number.POSITIVE_INFINITY) {\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n            }\n            \n        } else if (currDifficulty === \"hard\") {\n            \n            let minNum = { number: Number.POSITIVE_INFINITY };\n            possibleMoves.forEach(move => {\n                move.moves.forEach(possMove => {\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\n                            console.log('no, is not defensed');\n\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        }\n                    }\n                });\n            });\n\n            if (minNum.number === Number.POSITIVE_INFINITY) {\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n            }\n\n        } else if (currDifficulty === \"very hard\") {\n            let minNum = { number: Number.POSITIVE_INFINITY };\n            possibleMoves.forEach(move => {\n                move.moves.forEach(possMove => {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    \n                    previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\n                    previewVirtualBoard.current[parseInt(possMove / 8)][possMove % 8] = move.piece;\n                    console.log(previewVirtualBoard.current);\n                    let squaresVirtualBoard = [];\n\n                    previewVirtualBoard.current.forEach(row => {\n                        row.forEach(square => squaresVirtualBoard.push(square));\n                    });\n                    \n                    let kingSquare;\n\n                    squaresVirtualBoard.forEach((square, totalIdx) => {\n                        const iconColor = square && square < 0 ? -1 : 1;\n                        if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) \n                            kingSquare = totalIdx;\n                    });  \n                    console.log(kingSquare, setColor * 6);\n                    if (!isDefensed(newBoard, move.idx, possMove) && checkCheckOptimised(kingSquare, setColor * 6)) {\n                        \n                        if (checkCheckmate(kingSquare, previewVirtualBoard.current)) checkmate = true;\n        \n                        minNum.number = -1;\n                        newMove = possMove;\n                        newPossibleMoves = move;\n                    } else if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\n                            console.log('no, is not defensed');\n\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \n                            newMove = possMove;\n                            newPossibleMoves = move;\n                        }\n                    }\n\n                    previewVirtualBoard.current = oldBoard;\n                });\n            });\n\n            if (minNum.number === Number.POSITIVE_INFINITY) {\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\n            }\n        }\n       \n        console.log(newMove);\n        let cloneVirtualBoard = cloneDeep(newBoard);\n\n        const oldX = parseInt(newPossibleMoves.idx / 8);\n        const oldY = newPossibleMoves.idx % 8;\n        const newX = parseInt(newMove / 8);\n        const newY = newMove % 8;\n\n        const iconContainerElement = currSquareElement.current[newPossibleMoves.idx].firstChild;\n        iconContainerElement.classList.add('opponent');\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\n        iconContainerElement.classList.add('changed-move');\n        \n        setTimeout(() => {\n            // iconContainerElement.classList.remove('opponent');\n            iconContainerElement.style.zIndex = 'initial';\n            iconContainerElement.style.position = 'initial';\n            iconContainerElement.style.left = `initial`;\n            iconContainerElement.style.top = `initial`;\n            iconContainerElement.style.transform = 'initial';\n           \n            let sound;\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\n            else sound = pieceSound;\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[newX][newY] = newPossibleMoves.piece;\n\n            localStorage.setItem(\"practice-current-move\", setColor);\n            localStorage.setItem(\"practice-board\", JSON.stringify(cloneVirtualBoard));\n\n            setNewVirtualBoard(cloneVirtualBoard);\n            sound.play();\n            if (checkmate) setGameRunning(false);\n            setCurrentMove(currMove);\n\n        }, 750);\n    };\n\n    // Computer check if any piece is attacked and can defense it\n\n    const isAttacked = (board, computerIdx, playerIdx) => {\n        const computerPiece = board[parseInt(computerIdx / 8)][computerIdx % 8];\n        const playerPiece = board[parseInt(playerIdx / 8)][playerIdx % 8];\n\n        let squareBoard = [];\n        board.forEach(row => {\n            row.forEach(square => squareBoard.push(square));\n        });\n\n        const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, setColor) && square !== 0) return {\n                piece: square,\n                idx: idx\n            }\n        });\n\n        const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\n\n        playerPieces.forEach(piece => {\n            \n        });\n    };\n\n    // Check if player move is defensed\n\n    const isDefensed = (board, computerIdx, playerIdx) => {\n        const computerPiece = board[parseInt(computerIdx / 8)][computerIdx % 8];\n        const playerPiece = board[parseInt(playerIdx / 8)][playerIdx % 8];\n        \n        let squareBoard = [];\n\n        board.forEach(row => {\n            row.forEach(square => squareBoard.push(square));\n        });\n\n        const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, setColor) && square !== 0) return {\n                piece: square,\n                idx: idx\n            };\n        });\n\n        const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\n\n        console.log(playerPieces);\n\n        let cloneBoard = cloneDeep(board);\n        cloneBoard[parseInt(playerIdx / 8)][playerIdx % 8] = 0;\n\n        // Get possible moves for each piece\n\n        return playerPieces.some(piece => {\n            const playerPossibleMoves = getPossibleMoves(piece.piece, piece.idx, cloneBoard);\n            return playerPossibleMoves.some(move => move === playerIdx);\n        });\n    };\n\n\n    const getAllMoves = (color, newBoard) => {\n        let currBoard = [];\n\n        newBoard.forEach(row => {\n            row.forEach(square => {\n                currBoard.push(square);\n            });\n        });\n\n        let possibleMoves = [], allMoves = [];\n\n        currBoard.forEach((square, idx) => {\n            if (!checkOppositeColor(color, square) && square !== 0) possibleMoves.push({\n                piece: square, \n                idx: idx\n            });\n        });\n\n        possibleMoves.length !== 0 && possibleMoves.forEach(move => {\n            const currPossMoves = getPossibleMoves(move.piece, move.idx, newBoard);\n            console.log(move);\n            const currMoves = currPossMoves.length !== 0 && isArray(currPossMoves) ? currPossMoves.filter(currPieceMove => {\n                if (currPieceMove.rocade != null) return false;\n                let oldPreviewVirtualBoard = cloneDeep(previewVirtualBoard.current);\n                console.log(move.idx, currPieceMove);\n                previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\n                previewVirtualBoard.current[parseInt(currPieceMove / 8)][currPieceMove % 8] = move.piece;\n                let kingSquare;\n                console.log(newVirtualBoard);\n                previewVirtualBoard.current.forEach((row, rowIdx) => {\n                    row.forEach((square, squareIdx) => {\n                        if (square === -setColor * 6) kingSquare = rowIdx * 8 + squareIdx;\n                    });\n                });\n                \n                const isCheck = checkCheckOptimised(kingSquare, -setColor * 6);\n                previewVirtualBoard.current = cloneDeep(oldPreviewVirtualBoard);\n                \n                return !isCheck;\n            }) : [];\n\n            console.log(currMoves);\n            \n            if (currMoves.length !== 0) {\n                allMoves.push({\n                    piece: move.piece,\n                    idx: move.idx, \n                    moves: currMoves\n                });\n            }\n        });\n\n        console.log(allMoves);\n\n        return allMoves;\n    };\n\n    const computerMoveFirst = () => {\n        let newBoard1 = cloneDeep(newVirtualBoard);\n        newBoard1[2][0] = 0;\n        newBoard1[0][1] = 3;\n        setNewVirtualBoard(newBoard1);\n        const possibleMoves = getAllMoves(currentMove, newBoard1);\n        console.log(possibleMoves, Math.random() * possibleMoves.length);\n        const randomPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n        const randomMove = randomPossibleMoves.moves[Math.floor(Math.random() * randomPossibleMoves.moves.length)];\n        console.log(randomMove);\n        let cloneVirtualBoard = cloneDeep(newBoard1);\n\n        const oldX = parseInt(randomPossibleMoves.idx / 8);\n        const oldY = randomPossibleMoves.idx % 8;\n        const newX = parseInt(randomMove / 8);\n        const newY = randomMove % 8;\n        console.log(newX, newY);\n\n        const iconContainerElement = currSquareElement.current[randomPossibleMoves.idx].firstChild;\n        iconContainerElement.classList.add('opponent');\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\n        iconContainerElement.classList.add('changed-move');\n        \n        setTimeout(() => {\n            // iconContainerElement.classList.remove('opponent');\n            iconContainerElement.style.zIndex = 'initial';\n            iconContainerElement.style.position = 'initial';\n            iconContainerElement.style.left = `initial`;\n            iconContainerElement.style.top = `initial`;\n            iconContainerElement.style.transform = 'initial';\n            \n           \n            let sound;\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\n            else sound = pieceSound;\n\n            cloneVirtualBoard[oldX][oldY] = 0;\n            cloneVirtualBoard[newX][newY] = randomPossibleMoves.piece;\n\n            localStorage.setItem(\"practice-current-move\", setColor);\n            localStorage.setItem(\"practice-board\", JSON.stringify(cloneVirtualBoard));\n\n            setNewVirtualBoard(cloneVirtualBoard);\n            sound.play();\n            setCurrentMove(setColor);\n\n          \n        }, 750);\n    };\n\n    useEffect(() => {\n        if (setColor === -1) computerMoveFirst();\n    }, []);\n    \n       \n \n\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\n\n        // Get transformed piece's code\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\n        const newBoard = cloneDeep(newVirtualBoard);\n        const currentX = parseInt(idx / 8);\n        const currentY = idx % 8;\n        const oldX = parseInt(oldIdx / 8);\n        const oldY = oldIdx % 8;\n        const totalIdx = currentX * 8 + currentY + + (currentX % 2 !== 0 ? 1 : 0)\n        newBoard[currentX][currentY] = transformPieceCode;\n        newBoard[oldX][oldY] = 0;\n        setNewVirtualBoard(newBoard);\n        console.log(newBoard);\n        previewVirtualBoard.current = newBoard;\n        console.log(newBoard);\n        \n        setPawnTransform({\n            idx: idx,\n            piece: transformPieceCode,\n            elements: []\n        });\n\n        localStorage.setItem(\"practice-board\", JSON.stringify(newBoard));\n    };\n\n    const checkOppositeColor = (piece1, piece2) => {\n        if (piece1 < 0 && piece2 > 0) return true;\n        else if (piece1 > 0 && piece2 < 0) return true;\n        return false;\n    }\n\n    const checkCheck = (kingSquare, kCode, isFromCheckMate = false) => {\n\n        console.log('lalalalaalaallapgdkkdfpgogjodjfgjdp', previewVirtualBoard.current, kingSquare);\n        console.log(kingSquare);\n        let currBoard = [];\n\n        previewVirtualBoard.current.forEach(row => {\n            row.forEach(square => {\n                currBoard.push(square);\n            });\n        });\n\n        const oppositeSquaresClone = currBoard.map((square, idx) => {\n            if (checkOppositeColor(kCode, square)) return {\n                pieceCode: square,\n                coords: idx\n            };\n        });\n\n        console.log(oppositeSquaresClone);\n\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\n\n        console.log(oppositeSquares, kingSquare);\n\n        // Checking if king is attacked\n\n        const check = oppositeSquares.some(square => {\n            console.log(square.pieceCode, square.coords, previewVirtualBoard.current);\n            const possibleMovesCheck = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\n            console.log(possibleMoves);\n            return possibleMovesCheck.some(currSquare => {\n                \n                console.log(currSquare, kingSquare);\n                return currSquare === kingSquare;\n            });\n        });\n\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\n\n        if (check && !isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n\n        previewVirtualBoard.current = oldBoard;\n\n        return check;\n    };\n\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\n\n        // Getting coords\n        const currentX = parseInt(kingSquare / 8);\n        const currentY = kingSquare % 8;\n        const pieceCode = kCode / (-6);\n\n        let check = false;\n\n        const kingPossibleSquares = [\n            [currentX - 1, currentY - 1],\n            [currentX - 1, currentY],\n            [currentX - 1, currentY + 1],\n            [currentX, currentY - 1],\n            [currentX, currentY + 1],\n            [currentX + 1, currentY - 1],\n            [currentX + 1, currentY],\n            [currentX + 1, currentY + 1]\n        ];\n\n        console.log(previewVirtualBoard.current, pieceCode);\n\n        kingPossibleSquares.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === -kCode && square !== null) {\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                check = true;\n            }\n        });\n\n        // Pawns \n\n        const pawnPossibleSquares = [\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\n        ];\n        \n        console.log(pawnPossibleSquares);\n\n        pawnPossibleSquares.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === pieceCode) {\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                console.log('check');\n                check = true;\n            }\n        });\n        \n        // Rows\n\n        if (currentX > 0) {\n            for (let i = currentX - 1; i >= 0; i--) {\n                const rowSquare =   previewVirtualBoard.current[i] && \n                                    previewVirtualBoard.current[i][currentY] &&\n                                    previewVirtualBoard.current[i][currentY];\n                \n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (rowSquare !== 0) break;\n            }\n        }\n\n        if (currentX < ROWS - 1) {\n            for (let i = currentX + 1; i < ROWS; i++) {\n                const rowSquare =   previewVirtualBoard.current[i] && \n                                    previewVirtualBoard.current[i][currentY] &&\n                                    previewVirtualBoard.current[i][currentY];\n\n                console.log(rowSquare, pieceCode, previewVirtualBoard.current);\n                \n                if (rowSquare === 2 * pieceCode || rowSquare * pieceCode === 5) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) {\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\n                        console.log(checkMate);\n                    }\n                    console.log(\"here in if\")\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (rowSquare !== 0) break;\n            }\n        }\n\n        // Columns \n\n        if (currentY > 0) {\n            for (let i = currentY - 1; i >= 0; i--) {\n                const columnSquare = previewVirtualBoard.current[currentX] &&\n                                     previewVirtualBoard.current[currentX][i] && \n                                     previewVirtualBoard.current[currentX][i];\n                \n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (columnSquare !== 0) break;\n            }\n        }\n\n        if (currentY < COLUMNS - 1) {\n            for (let i = currentX + 1; i < COLUMNS; i++) {\n                const columnSquare = previewVirtualBoard.current[currentX] &&\n                                     previewVirtualBoard.current[currentX][i] && \n                                     previewVirtualBoard.current[currentX][i];\n                \n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (columnSquare !== 0) break;\n            }\n        }\n\n        // Diagonal top left\n        \n        if (currentX > 0 && currentY > 0) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX - i;\n                const newY = currentY - i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal top right\n\n        if (currentX > 0 && currentY < COLUMNS - 1) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX - i;\n                const newY = currentY + i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal bottom left\n\n        if (currentX < ROWS - 1 && currentY > 0) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX + i;\n                const newY = currentY - i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Diagonal bottom right\n\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\n            for (let i = 1; i < 8; i++) {\n                const newX = currentX + i;\n                const newY = currentY + i;\n                const square = previewVirtualBoard.current[newX] &&\n                               previewVirtualBoard.current[newX][newY] && \n                               previewVirtualBoard.current[newX][newY];\n                if (square == null) break;\n                \n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                    previewVirtualBoard.current = oldBoard;\n                    return true;\n                }\n                else if (square !== 0) break;\n            }\n        }\n\n        // Knight moves\n\n        const knightPossibleMoves = [\n            [currentX - 2, currentY - 1],\n            [currentX - 2, currentY + 1],\n            [currentX + 2, currentY - 1],\n            [currentX + 2, currentY + 1],\n            [currentX - 1, currentY - 2],\n            [currentX - 1, currentY + 2],\n            [currentX + 1, currentY - 2],\n            [currentX + 1, currentY + 2]\n        ];\n\n        \n        \n        knightPossibleMoves.forEach(move => {\n            const square = previewVirtualBoard.current[move[0]] && \n                           previewVirtualBoard.current[move[0]][move[1]] &&\n                           previewVirtualBoard.current[move[0]][move[1]];\n\n            if (square === pieceCode * 3) { \n                const oldBoard = cloneDeep(previewVirtualBoard.current);\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\n                previewVirtualBoard.current = oldBoard;\n                check = true;\n            }\n        });\n\n        return check;\n    };\n\n\n    // Checking the check-mate\n\n    const checkCheckmate = (kCode, board) => {\n\n        console.log(board);\n        const constantBoard = board;\n        let currBoard = [];\n\n        board.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const mySquaresClone = currBoard.map((square, idx) => {\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\n                pieceCode: square,\n                coords: idx\n            }\n        });\n\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\n        console.log(mySquares);\n        let checkMate = true;\n\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\n\n        mySquares.forEach(square => {\n\n            // Next possible moves to check if it's checkmate\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\n            console.log(possibleMovesCheckmate);\n\n            possibleMovesCheckmate.forEach(move => {\n                const currX = parseInt(square.coords / 8);\n                const currY = square.coords % 8;\n                const newX = parseInt(move / 8);\n                const newY = move % 8;\n                const newBoard = cloneDeep(constantBoard);\n\n                newBoard[currX][currY] = 0;\n                \n                if (newBoard && newBoard[newX] && newBoard[newX][newY]) {\n                    if (newBoard[newX][newY] !== 0) {\n                        const enemyPieceNumber = newBoard[newX][newY];\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\n                    } else newBoard[newX][newY] = square.pieceCode;\n                }\n\n                \n                previewVirtualBoard.current = cloneDeep(newBoard);\n\n                let allInOneBoard = [];\n\n                previewVirtualBoard.current.forEach(row => {\n                    row.forEach(square => allInOneBoard.push(square));\n                });\n\n                console.log(newBoard, kCode);\n\n                console.log(allInOneBoard);\n\n                let kingSquare = -1;\n\n                allInOneBoard.forEach((square, idx) => {\n                    if (square === kCode) kingSquare = idx;\n                });\n\n                console.log(kingSquare);\n                \n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\n                console.log(newBoardCheck, kingSquare, kCode);\n                if (!newBoardCheck) checkMate = false;\n                \n            });\n        });\n        \n\n        previewVirtualBoard.current = oldBoard;\n       if (checkMate) setGameRunning(false);\n       return checkMate;\n        \n    };\n\n    const checkPat = (pieceCode, board) => {\n        let currBoard = [];\n        console.log(board, pieceCode);\n        board.forEach(row => {\n            row.forEach(square => currBoard.push(square));\n        });\n\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\n            if (checkOppositeColor(pieceCode, square)) return {\n                pieceCode: square,\n                coords: coords\n            };\n        });\n\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\n\n        return oppositeSquares.every(square => {\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\n            console.log(oppPossibleMoves);\n            return oppPossibleMoves.length === 0;\n        });\n    };\n\n\n    const addSquares = () => {\n        let squareComponents = [];\n       \n        const board = newVirtualBoard.map((row, rowIdx) => {\n\n            const rows = row.map((square, squareIdx) => {\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\n                const realIdx = rowIdx * 8 + squareIdx;\n               \n                const squareComponent = \n                    <div \n                        className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} \n                        key={squareIdx} \n                        ref={ref => { \n                            currSquareElement.current[realIdx] = ref;\n                        }}\n                        onClick={() => selectSquare(currSquareElement.current[realIdx])}\n                    >\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\n                            pawnTransform.elements.length > 0 ? (<div \n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\n                                key={totalIdx}\n                            >   \n                                {pawnTransform.elements}  \n                            </div>)\n                            : (\n                                <div \n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\n                                    onMouseMove={e => movePiece(e)}\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \n                                    key={totalIdx}\n                                >   \n                                    <FontAwesomeIcon \n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \n                                        code={pawnTransform.piece}\n                                    />\n                                </div>\n                            )\n                        ) : square !== 0 ? (\n                            <div \n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\n                                onMouseMove={e => movePiece(e)}\n                                onMouseUp={e => dropPiece(e, square)} \n                                key={totalIdx}\n                            >   \n                                <FontAwesomeIcon \n                                    icon={piecesCode[Math.abs(square).toString()]} \n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \n                                    code={square}\n                                />\n                            </div>\n                        ) : \"\"}\n                    </div>;\n\n                return squareComponent;\n            });\n            return (\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\n                    {rows}\n                </div>\n            );\n        });\n\n        squareElements.current = squareComponents;\n\n        return board;\n    };\n\n    return (\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\n            {addSquares()}\n            <div className=\"letters\">\n                <p>A</p>\n                <p>B</p>\n                <p>C</p>\n                <p>D</p>\n                <p>E</p>\n                <p>F</p>\n                <p>G</p>\n                <p>H</p>\n            </div>\n        </div>\n    );\n};\n","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/PreviousButton.jsx",[],"/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/ResetButton.jsx",["176"],"import React, { Component } from \"react\";\r\n\r\nexport default class ResetButton extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.computerGame = this.props.computerGame;\r\n        this.lang = localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\";\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        console.log(\"set\")\r\n        this.lang = localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\";\r\n    }\r\n\r\n    resetGame() {\r\n        if (this.computerGame) { \r\n            for (let i = 0, len = localStorage.length; i < len; i++) {\r\n                const key = localStorage.key(i);\r\n                console.log(key);\r\n                if (key === null) continue;\r\n                if (key.search(\"computer-\") !== -1) localStorage.removeItem(key);\r\n            }\r\n        }\r\n        else localStorage.clear();\r\n        window.location.reload();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"reset-button\" onClick={() => this.resetGame()}>\r\n                <h2>{this.lang === \"en\" ? \"Reset Game\" : this.lang === \"ro\" ? \"Reseteaza Jocul\" : \"Reset játék\"}</h2>\r\n            </div>\r\n        );\r\n    }\r\n \r\n};","/Users/mihaibarbu/Desktop/Projects/chess-game/chess/src/Components/OnlineSocket.jsx",[],{"ruleId":"177","severity":1,"message":"178","line":34,"column":11,"nodeType":"179","messageId":"180","endLine":34,"endColumn":23},{"ruleId":"177","severity":1,"message":"181","line":16,"column":18,"nodeType":"179","messageId":"180","endLine":16,"endColumn":25},{"ruleId":"177","severity":1,"message":"182","line":17,"column":12,"nodeType":"179","messageId":"180","endLine":17,"endColumn":19},{"ruleId":"177","severity":1,"message":"183","line":17,"column":21,"nodeType":"179","messageId":"180","endLine":17,"endColumn":31},{"ruleId":"177","severity":1,"message":"184","line":3,"column":8,"nodeType":"179","messageId":"180","endLine":3,"endColumn":10},{"ruleId":"177","severity":1,"message":"185","line":5,"column":8,"nodeType":"179","messageId":"180","endLine":5,"endColumn":13},{"ruleId":"177","severity":1,"message":"186","line":23,"column":12,"nodeType":"179","messageId":"180","endLine":23,"endColumn":16},{"ruleId":"177","severity":1,"message":"187","line":23,"column":18,"nodeType":"179","messageId":"180","endLine":23,"endColumn":25},{"ruleId":"177","severity":1,"message":"188","line":26,"column":12,"nodeType":"179","messageId":"180","endLine":26,"endColumn":18},{"ruleId":"177","severity":1,"message":"189","line":28,"column":12,"nodeType":"179","messageId":"180","endLine":28,"endColumn":19},{"ruleId":"177","severity":1,"message":"190","line":30,"column":9,"nodeType":"179","messageId":"180","endLine":30,"endColumn":16},{"ruleId":"191","severity":1,"message":"192","line":34,"column":72,"nodeType":"193","messageId":"194","endLine":34,"endColumn":74},{"ruleId":"195","severity":1,"message":"196","line":98,"column":8,"nodeType":"197","endLine":98,"endColumn":25,"suggestions":"198"},{"ruleId":"177","severity":1,"message":"199","line":1,"column":27,"nodeType":"179","messageId":"180","endLine":1,"endColumn":36},{"ruleId":"177","severity":1,"message":"200","line":1,"column":38,"nodeType":"179","messageId":"180","endLine":1,"endColumn":44},{"ruleId":"177","severity":1,"message":"201","line":1,"column":16,"nodeType":"179","messageId":"180","endLine":1,"endColumn":24},{"ruleId":"177","severity":1,"message":"199","line":1,"column":26,"nodeType":"179","messageId":"180","endLine":1,"endColumn":35},{"ruleId":"177","severity":1,"message":"202","line":9,"column":7,"nodeType":"179","messageId":"180","endLine":9,"endColumn":13},{"ruleId":"195","severity":1,"message":"203","line":111,"column":8,"nodeType":"197","endLine":111,"endColumn":28,"suggestions":"204"},{"ruleId":"177","severity":1,"message":"205","line":3,"column":102,"nodeType":"179","messageId":"180","endLine":3,"endColumn":114},{"ruleId":"195","severity":1,"message":"206","line":32,"column":8,"nodeType":"197","endLine":32,"endColumn":10,"suggestions":"207"},{"ruleId":"195","severity":1,"message":"208","line":159,"column":8,"nodeType":"197","endLine":159,"endColumn":16,"suggestions":"209"},{"ruleId":"210","severity":1,"message":"211","line":883,"column":138,"nodeType":"212","messageId":"213","endLine":883,"endColumn":140},{"ruleId":"210","severity":1,"message":"211","line":883,"column":158,"nodeType":"212","messageId":"213","endLine":883,"endColumn":160},{"ruleId":"195","severity":1,"message":"208","line":161,"column":8,"nodeType":"197","endLine":161,"endColumn":16,"suggestions":"214"},{"ruleId":"210","severity":1,"message":"211","line":887,"column":138,"nodeType":"212","messageId":"213","endLine":887,"endColumn":140},{"ruleId":"210","severity":1,"message":"211","line":887,"column":158,"nodeType":"212","messageId":"213","endLine":887,"endColumn":160},{"ruleId":"195","severity":1,"message":"215","line":1342,"column":8,"nodeType":"197","endLine":1342,"endColumn":18,"suggestions":"216"},{"ruleId":"217","severity":1,"message":"218","line":1644,"column":60,"nodeType":"219","messageId":"220","endLine":1644,"endColumn":62},{"ruleId":"217","severity":1,"message":"218","line":1722,"column":69,"nodeType":"219","messageId":"220","endLine":1722,"endColumn":71},{"ruleId":"177","severity":1,"message":"221","line":9,"column":8,"nodeType":"179","messageId":"180","endLine":9,"endColumn":20},{"ruleId":"177","severity":1,"message":"222","line":12,"column":7,"nodeType":"179","messageId":"180","endLine":12,"endColumn":14},{"ruleId":"177","severity":1,"message":"223","line":47,"column":12,"nodeType":"179","messageId":"180","endLine":47,"endColumn":30},{"ruleId":"177","severity":1,"message":"224","line":47,"column":32,"nodeType":"179","messageId":"180","endLine":47,"endColumn":53},{"ruleId":"177","severity":1,"message":"225","line":52,"column":26,"nodeType":"179","messageId":"180","endLine":52,"endColumn":41},{"ruleId":"177","severity":1,"message":"226","line":63,"column":11,"nodeType":"179","messageId":"180","endLine":63,"endColumn":22},{"ruleId":"177","severity":1,"message":"227","line":101,"column":11,"nodeType":"179","messageId":"180","endLine":101,"endColumn":23},{"ruleId":"191","severity":1,"message":"228","line":780,"column":25,"nodeType":"193","messageId":"194","endLine":780,"endColumn":27},{"ruleId":"177","severity":1,"message":"229","line":801,"column":19,"nodeType":"179","messageId":"180","endLine":801,"endColumn":20},{"ruleId":"177","severity":1,"message":"230","line":802,"column":19,"nodeType":"179","messageId":"180","endLine":802,"endColumn":20},{"ruleId":"177","severity":1,"message":"231","line":822,"column":19,"nodeType":"179","messageId":"180","endLine":822,"endColumn":28},{"ruleId":"210","severity":1,"message":"211","line":825,"column":138,"nodeType":"212","messageId":"213","endLine":825,"endColumn":140},{"ruleId":"210","severity":1,"message":"211","line":825,"column":158,"nodeType":"212","messageId":"213","endLine":825,"endColumn":160},{"ruleId":"177","severity":1,"message":"232","line":832,"column":17,"nodeType":"179","messageId":"180","endLine":832,"endColumn":25},{"ruleId":"177","severity":1,"message":"233","line":908,"column":17,"nodeType":"179","messageId":"180","endLine":908,"endColumn":35},{"ruleId":"177","severity":1,"message":"234","line":955,"column":11,"nodeType":"179","messageId":"180","endLine":955,"endColumn":24},{"ruleId":"217","severity":1,"message":"218","line":963,"column":60,"nodeType":"219","messageId":"220","endLine":963,"endColumn":62},{"ruleId":"217","severity":1,"message":"235","line":971,"column":62,"nodeType":"219","messageId":"220","endLine":971,"endColumn":64},{"ruleId":"177","severity":1,"message":"236","line":998,"column":15,"nodeType":"179","messageId":"180","endLine":998,"endColumn":23},{"ruleId":"177","severity":1,"message":"237","line":1021,"column":11,"nodeType":"179","messageId":"180","endLine":1021,"endColumn":21},{"ruleId":"217","severity":1,"message":"218","line":1032,"column":66,"nodeType":"219","messageId":"220","endLine":1032,"endColumn":68},{"ruleId":"217","severity":1,"message":"218","line":1328,"column":60,"nodeType":"219","messageId":"220","endLine":1328,"endColumn":62},{"ruleId":"217","severity":1,"message":"218","line":1410,"column":69,"nodeType":"219","messageId":"220","endLine":1410,"endColumn":71},{"ruleId":"195","severity":1,"message":"238","line":1564,"column":8,"nodeType":"197","endLine":1564,"endColumn":19,"suggestions":"239"},{"ruleId":"177","severity":1,"message":"225","line":45,"column":26,"nodeType":"179","messageId":"180","endLine":45,"endColumn":41},{"ruleId":"177","severity":1,"message":"227","line":95,"column":11,"nodeType":"179","messageId":"180","endLine":95,"endColumn":23},{"ruleId":"195","severity":1,"message":"208","line":155,"column":8,"nodeType":"197","endLine":155,"endColumn":16,"suggestions":"240"},{"ruleId":"195","severity":1,"message":"241","line":168,"column":8,"nodeType":"197","endLine":168,"endColumn":21,"suggestions":"242"},{"ruleId":"195","severity":1,"message":"241","line":182,"column":8,"nodeType":"197","endLine":182,"endColumn":20,"suggestions":"243"},{"ruleId":"177","severity":1,"message":"244","line":191,"column":11,"nodeType":"179","messageId":"180","endLine":191,"endColumn":17},{"ruleId":"191","severity":1,"message":"228","line":878,"column":22,"nodeType":"193","messageId":"194","endLine":878,"endColumn":24},{"ruleId":"177","severity":1,"message":"229","line":916,"column":19,"nodeType":"179","messageId":"180","endLine":916,"endColumn":20},{"ruleId":"177","severity":1,"message":"230","line":917,"column":19,"nodeType":"179","messageId":"180","endLine":917,"endColumn":20},{"ruleId":"210","severity":1,"message":"211","line":938,"column":138,"nodeType":"212","messageId":"213","endLine":938,"endColumn":140},{"ruleId":"210","severity":1,"message":"211","line":938,"column":158,"nodeType":"212","messageId":"213","endLine":938,"endColumn":160},{"ruleId":"177","severity":1,"message":"232","line":944,"column":17,"nodeType":"179","messageId":"180","endLine":944,"endColumn":25},{"ruleId":"177","severity":1,"message":"234","line":1068,"column":11,"nodeType":"179","messageId":"180","endLine":1068,"endColumn":24},{"ruleId":"217","severity":1,"message":"218","line":1076,"column":60,"nodeType":"219","messageId":"220","endLine":1076,"endColumn":62},{"ruleId":"217","severity":1,"message":"235","line":1084,"column":62,"nodeType":"219","messageId":"220","endLine":1084,"endColumn":64},{"ruleId":"177","severity":1,"message":"245","line":1260,"column":11,"nodeType":"179","messageId":"180","endLine":1260,"endColumn":21},{"ruleId":"177","severity":1,"message":"246","line":1261,"column":15,"nodeType":"179","messageId":"180","endLine":1261,"endColumn":28},{"ruleId":"177","severity":1,"message":"247","line":1262,"column":15,"nodeType":"179","messageId":"180","endLine":1262,"endColumn":26},{"ruleId":"217","severity":1,"message":"218","line":1269,"column":70,"nodeType":"219","messageId":"220","endLine":1269,"endColumn":72},{"ruleId":"177","severity":1,"message":"246","line":1286,"column":15,"nodeType":"179","messageId":"180","endLine":1286,"endColumn":28},{"ruleId":"177","severity":1,"message":"247","line":1287,"column":15,"nodeType":"179","messageId":"180","endLine":1287,"endColumn":26},{"ruleId":"217","severity":1,"message":"218","line":1295,"column":70,"nodeType":"219","messageId":"220","endLine":1295,"endColumn":72},{"ruleId":"195","severity":1,"message":"248","line":1428,"column":8,"nodeType":"197","endLine":1428,"endColumn":10,"suggestions":"249"},{"ruleId":"177","severity":1,"message":"236","line":1442,"column":15,"nodeType":"179","messageId":"180","endLine":1442,"endColumn":23},{"ruleId":"177","severity":1,"message":"237","line":1465,"column":11,"nodeType":"179","messageId":"180","endLine":1465,"endColumn":21},{"ruleId":"217","severity":1,"message":"218","line":1477,"column":66,"nodeType":"219","messageId":"220","endLine":1477,"endColumn":68},{"ruleId":"217","severity":1,"message":"218","line":1773,"column":60,"nodeType":"219","messageId":"220","endLine":1773,"endColumn":62},{"ruleId":"217","severity":1,"message":"218","line":1850,"column":69,"nodeType":"219","messageId":"220","endLine":1850,"endColumn":71},{"ruleId":"177","severity":1,"message":"250","line":1,"column":17,"nodeType":"179","messageId":"180","endLine":1,"endColumn":26},"no-unused-vars","'colorButtons' is assigned a value but never used.","Identifier","unusedVar","'setLang' is assigned a value but never used.","'content' is assigned a value but never used.","'setContent' is assigned a value but never used.","'io' is defined but never used.","'Board' is defined but never used.","'done' is assigned a value but never used.","'setDone' is assigned a value but never used.","'winner' is assigned a value but never used.","'message' is assigned a value but never used.","'players' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'buttonsTarget', 'color', 'random', 'socket', and 'stopRealTimer'. Either include them or remove the dependency array.","ArrayExpression",["251"],"'useEffect' is defined but never used.","'useRef' is defined but never used.","'useState' is defined but never used.","'HEIGHT' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'downTimer', 'onlineGame', and 'upTimer'. Either include them or remove the dependency array.",["252"],"'faPaperPlane' is defined but never used.","React Hook useEffect has missing dependencies: 'online' and 'socket'. Either include them or remove the dependency array.",["253"],"React Hook useEffect has missing dependencies: 'currentMove', 'newVirtualBoard', 'nextMoves', 'prevButtons', and 'prevMoves'. Either include them or remove the dependency array. You can also do a functional update 'setPrevMoves(p => ...)' if you only need 'prevMoves' in the 'setPrevMoves' call.",["254"],"no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator",["255"],"React Hook useEffect has a missing dependency: 'computerMoveFirst'. Either include it or remove the dependency array.",["256"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'OnlineSocket' is defined but never used.","'SQUARES' is assigned a value but never used.","'currentTotalCoords' is assigned a value but never used.","'setCurrentTotalCoords' is assigned a value but never used.","'setVirtualBoard' is assigned a value but never used.","'oldChildren' is assigned a value but never used.","'player1Color' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'x' is assigned a value but never used.","'y' is assigned a value but never used.","'cloneIcon' is assigned a value but never used.","'newPiece' is assigned a value but never used.","'oppositeKingSquare' is assigned a value but never used.","'getContainers' is assigned a value but never used.","Array.prototype.filter() expects a value to be returned at the end of arrow function.","'totalIdx' is assigned a value but never used.","'checkCheck' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'currentMove', 'newVirtualBoard', 'pieceCapture', 'pieceSound', 'socket', and 'stopTimer'. Either include them or remove the dependency array. If 'stopTimer' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["257"],["258"],"React Hook useEffect has a missing dependency: 'newVirtualBoard'. Either include it or remove the dependency array.",["259"],["260"],"'isKing' is assigned a value but never used.","'isAttacked' is assigned a value but never used.","'computerPiece' is assigned a value but never used.","'playerPiece' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'computerMoveFirst' and 'setColor'. Either include them or remove the dependency array.",["261"],"'Component' is defined but never used.",{"desc":"262","fix":"263"},{"desc":"264","fix":"265"},{"desc":"266","fix":"267"},{"desc":"268","fix":"269"},{"desc":"268","fix":"270"},{"desc":"271","fix":"272"},{"desc":"273","fix":"274"},{"desc":"268","fix":"275"},{"desc":"276","fix":"277"},{"desc":"278","fix":"279"},{"desc":"271","fix":"280"},"Update the dependencies array to be: [buttonsTarget, color, numberOfPlayers, random, socket, stopRealTimer]",{"range":"281","text":"282"},"Update the dependencies array to be: [stopTimer, players, downTimer, upTimer, onlineGame]",{"range":"283","text":"284"},"Update the dependencies array to be: [online, socket]",{"range":"285","text":"286"},"Update the dependencies array to be: [currentMove, newVirtualBoard, nextMoves, prevButtons, prevMoves, random]",{"range":"287","text":"288"},{"range":"289","text":"288"},"Update the dependencies array to be: [computerMoveFirst, setColor]",{"range":"290","text":"291"},"Update the dependencies array to be: [currentMove, newVirtualBoard, pieceCapture, pieceSound, sendPiece, socket, stopTimer]",{"range":"292","text":"293"},{"range":"294","text":"288"},"Update the dependencies array to be: [choosePiece, newVirtualBoard]",{"range":"295","text":"296"},"Update the dependencies array to be: [deleteIcon, newVirtualBoard]",{"range":"297","text":"298"},{"range":"299","text":"291"},[3701,3718],"[buttonsTarget, color, numberOfPlayers, random, socket, stopRealTimer]",[6752,6772],"[stopTimer, players, downTimer, upTimer, onlineGame]",[1091,1093],"[online, socket]",[6773,6781],"[currentMove, newVirtualBoard, nextMoves, prevButtons, prevMoves, random]",[7008,7016],[56569,56579],"[computerMoveFirst, setColor]",[61680,61691],"[currentMove, newVirtualBoard, pieceCapture, pieceSound, sendPiece, socket, stopTimer]",[6389,6397],[6895,6908],"[choosePiece, newVirtualBoard]",[7357,7369],"[deleteIcon, newVirtualBoard]",[59018,59020]]