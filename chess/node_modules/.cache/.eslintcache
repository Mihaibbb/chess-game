[{"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\index.js":"1","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\App.js":"2","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\reportWebVitals.js":"3","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Home.jsx":"4","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Computer.jsx":"5","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Online.jsx":"6","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Practice.jsx":"7","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Classic.jsx":"8","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\LeftSide.jsx":"9","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\ComputerBoard.jsx":"10","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\RightSide.jsx":"11","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Board.jsx":"12","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\OnlineBoard.jsx":"13","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\PracticeBoard.jsx":"14","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\ResetButton.jsx":"15","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\OnlineSocket.jsx":"16","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\PreviousButton.jsx":"17","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\DraggableIcon.jsx":"18","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Header.jsx":"19","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Tutorial.jsx":"20","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Lessons.jsx":"21"},{"size":524,"mtime":1636133587167,"results":"22","hashOfConfig":"23"},{"size":5030,"mtime":1649317198867,"results":"24","hashOfConfig":"23"},{"size":375,"mtime":1636133587168,"results":"25","hashOfConfig":"23"},{"size":15619,"mtime":1649427783582,"results":"26","hashOfConfig":"23"},{"size":2065,"mtime":1649317960381,"results":"27","hashOfConfig":"23"},{"size":4836,"mtime":1649536157819,"results":"28","hashOfConfig":"23"},{"size":1659,"mtime":1649321462942,"results":"29","hashOfConfig":"23"},{"size":2764,"mtime":1649352098476,"results":"30","hashOfConfig":"23"},{"size":5175,"mtime":1649538170806,"results":"31","hashOfConfig":"23"},{"size":77363,"mtime":1649352895610,"results":"32","hashOfConfig":"23"},{"size":7837,"mtime":1649352127367,"results":"33","hashOfConfig":"23"},{"size":64754,"mtime":1649355473547,"results":"34","hashOfConfig":"23"},{"size":63460,"mtime":1649353026855,"results":"35","hashOfConfig":"23"},{"size":81503,"mtime":1649275886761,"results":"36","hashOfConfig":"23"},{"size":1223,"mtime":1649182071868,"results":"37","hashOfConfig":"23"},{"size":833,"mtime":1638227062650,"results":"38","hashOfConfig":"23"},{"size":475,"mtime":1636201334185,"results":"39","hashOfConfig":"23"},{"size":584,"mtime":1648993428214,"results":"40","hashOfConfig":"23"},{"size":3208,"mtime":1649318579257,"results":"41","hashOfConfig":"23"},{"size":8909,"mtime":1649356198141,"results":"42","hashOfConfig":"23"},{"size":335,"mtime":1649357148707,"results":"43","hashOfConfig":"23"},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},"66q6br",{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"46"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"46"},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"63","messages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"65","messages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"46"},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"46"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"46"},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"46"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"46"},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"46"},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"89","messages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"91","messages":"92","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"46"},{"filePath":"94","messages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"46"},"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\index.js",[],["97","98"],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\App.js",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\reportWebVitals.js",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Home.jsx",["99"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faUser, faRobot, faCheck, faAngleDown, faWifi, faChessBoard } from '@fortawesome/free-solid-svg-icons';\r\n\r\nimport Header from \"./Header\";\r\nimport black_queen from \"../image/black_queen.png\";\r\nimport white_queen from \"../image/white_queen.png\";\r\nimport half_queen from \"../image/half_queen.png\";\r\nimport '../styles/game-modes.css';\r\nimport selectS from \"../sounds/select.mp3\";\r\nimport clickS from \"../sounds/click.mp3\";\r\n\r\nexport default function Home({id, getColor, getDifficulty}) {\r\n\r\n    \r\n    if (localStorage.length !== 0) {\r\n        for (let i = 0, len = localStorage.length; i < len; i++) {\r\n            const key = localStorage.key(i);\r\n            if (key === null) continue;\r\n            if (key.search(\"computer-\") === -1 && key.search(\"player\") === -1 && key.search(\"opponent\") === -1 && key !== 'language' && key.search(\"classic-\") === -1) localStorage.removeItem(key);\r\n            if (key.search(\"online-\") !== -1) localStorage.removeItem(key);\r\n        }\r\n    }\r\n\r\n    const [stop, setStop] = useState(false);\r\n    const [clickStop, setClickStop] = useState(false);\r\n    const [computerColor, setComputerColor] = useState(null);\r\n    const [lang, setLang] = useState(localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\");\r\n\r\n    const inputLinkRef = useRef(null);\r\n    const copyButtonRef = useRef(null);\r\n    const copyIconRef = useRef(null);\r\n    const colorButtons = useRef([]);\r\n    const difficultiesRef = useRef();\r\n    const difficultyRef = useRef();\r\n\r\n    const selectSound = new Audio(selectS);\r\n    const pointSound = new Audio(clickS);\r\n\r\n    const hoverSound = () => {\r\n        selectSound.pause();\r\n        selectSound.currentTime = 0;\r\n        selectSound.play();\r\n    };\r\n\r\n    const copyLink = (e) => {\r\n        setClickStop(false);\r\n        inputLinkRef?.current.select();\r\n        inputLinkRef?.current.setSelectionRange(0, 1000);\r\n\r\n        navigator.clipboard.writeText(inputLinkRef?.current.value);\r\n        copyButtonRef?.current.classList.add(\"sent\");\r\n        \r\n        setTimeout(() => copyButtonRef?.current.firstChild.classList.add('rotate'), 400);\r\n        // copyButtonRef?.current.addEventListener('transitionend', () => {\r\n        //     copyButtonRef?.current.classList.add('rotate');\r\n        // });\r\n\r\n        setTimeout(() => {\r\n            inputLinkRef?.current.blur();\r\n            setClickStop(true);\r\n        }, 150);\r\n    };\r\n\r\n    const clickSound = (path) => {\r\n        if (path === `/${id}` && (stop || !clickStop)) return;\r\n        pointSound.pause();\r\n        pointSound.currentTime = 0;\r\n        pointSound.play();\r\n        pointSound.addEventListener('ended', () => {\r\n            if (path === `/${id}`) {\r\n                localStorage.removeItem(\"board\");\r\n                localStorage.removeItem(\"current-move\")\r\n            }\r\n            window.location.href = path;\r\n        });\r\n    \r\n    };  \r\n\r\n    const playComputer = (e, color) => {\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('piece-button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n        setComputerColor(color);\r\n        getColor(color, \"computer-\");\r\n        // window.location.href = `${window.location.href}computer`;\r\n        [...newTarget.parentElement.childNodes].forEach(childNode => {\r\n            childNode.classList.remove('clicked');\r\n        });\r\n        newTarget.classList.add('clicked');\r\n    };\r\n\r\n    const playClassic = (e, color) => {\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('piece-button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n       \r\n        getColor(color, \"classic-\");\r\n        // window.location.href = `${window.location.href}computer`;\r\n        [...newTarget.parentElement.childNodes].forEach(childNode => {\r\n            childNode.classList.remove('clicked');\r\n        });\r\n        newTarget.classList.add('clicked');\r\n    };\r\n\r\n    const playOnline = (e, color) => {\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('piece-button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n        \r\n        getColor(color, \"online-\");\r\n        // window.location.href = `${window.location.href}computer`;\r\n        [...newTarget.parentElement.childNodes].forEach(childNode => {\r\n            childNode.classList.remove('clicked');\r\n        });\r\n        newTarget.classList.add('clicked');\r\n    };\r\n\r\n    const startComputerGame = () => {\r\n        console.log(computerColor);\r\n        // window.location.href = `${window.location.href}computer`;\r\n    };\r\n\r\n    const changeDifficulty = (e) => {\r\n        const difficulty = e.target.innerText.toLowerCase();\r\n        e.target.parentElement.childNodes.forEach(child => child.classList.remove('active'));\r\n        e.target.classList.add('active');\r\n        getDifficulty(difficulty);\r\n    };\r\n\r\n    const languageCallback = (language) => {\r\n        setLang(language);\r\n    };\r\n\r\n    useEffect(() => localStorage.setItem(\"language\", JSON.stringify(lang)), [lang]);\r\n\r\n    return (\r\n        <div className=\"container\">\r\n\r\n            <Header languageCallback={languageCallback}/>\r\n\r\n            <div className=\"home-content\">\r\n             \r\n                <div className=\"classic-mode game-mode\" onMouseEnter={() => hoverSound()} >\r\n                    <div className=\"title\">\r\n                        <h2>{lang === \"en\" ? \"Classic\" : lang === \"ro\" ? \"Clasic\" : \"Klasszikus\"}</h2>\r\n    \r\n                        <div className=\"icon\">\r\n                            <FontAwesomeIcon \r\n                                icon={faUser} \r\n                                color=\"#fff\"\r\n                                className=\"mode-icon\"\r\n                            />\r\n\r\n                            <FontAwesomeIcon \r\n                                className=\"mode-icon board-icon\"\r\n                                icon={faChessBoard}\r\n                            />\r\n\r\n                            <FontAwesomeIcon \r\n                            icon={faUser} \r\n                                color=\"#fff\"\r\n                                className=\"mode-icon\"\r\n                            />\r\n\r\n                        </div>\r\n                    </div>\r\n\r\n                    <div className=\"colors\">\r\n                        <div className=\"white piece-button clicked\" onClick={(e) => playClassic(e, 1)}>\r\n                            <img src={white_queen} className=\"color-img\" alt=\"white color play\"/>\r\n                        </div>\r\n                        <div className=\"black piece-button\" onClick={(e) => playClassic(e, -1)} >\r\n                            <img src={black_queen} className=\"color-img\" alt=\"black color play\"/>\r\n                        </div>\r\n                        <div className=\"random piece-button\" onClick={(e) => playClassic(e, Math.random() < 0.5 ? 1 : -1)}>\r\n                            <img src={half_queen} className=\"color-img\" alt=\"random color play\"/>\r\n                        </div>\r\n                    </div>\r\n\r\n                    <div></div>\r\n\r\n                    <div></div>\r\n\r\n                    <div className=\"start\">\r\n                            <button className=\"start-button\" onClick={() => clickSound(`/classic`)}>{lang === \"en\" ? \"Start game!\" : lang === \"ro\" ? \"Incepe jocul!\" : \"Játék kezdése!\"}</button>\r\n                    </div>\r\n    \r\n                </div>\r\n                \r\n                <div className=\"online-mode game-mode\" onMouseEnter={() => hoverSound()}>\r\n                    \r\n                    <div className=\"title\">\r\n                        <h2>Online</h2>\r\n    \r\n                        <div className=\"icon\">\r\n                            <FontAwesomeIcon \r\n                                icon={faUser} \r\n                                color=\"#fff\"\r\n                                className=\"mode-icon\"\r\n                            />\r\n\r\n                            <div className=\"icon-manager\">\r\n                                <FontAwesomeIcon\r\n                                    color=\"#fff\"\r\n                                    icon={faWifi}\r\n                                    className=\"mode-icon wifi\"\r\n                                    size={10}\r\n                                />\r\n                                <FontAwesomeIcon\r\n                                    color=\"#fff\"\r\n                                    icon={faWifi}\r\n                                    className=\"mode-icon\"\r\n                                />\r\n                                \r\n                            </div>\r\n                            <FontAwesomeIcon \r\n                                    icon={faUser} \r\n                                    color=\"#fff\"\r\n                                    className=\"mode-icon\"\r\n                            />\r\n                             \r\n                        </div>\r\n    \r\n                        \r\n                    </div>      \r\n                    <div className=\"colors\">\r\n                        <div className=\"white piece-button clicked\" onClick={(e) => playOnline(e, 1)}>\r\n                            <img src={white_queen} className=\"color-img\" alt=\"white color play\"/>\r\n                        </div>\r\n                        <div className=\"black piece-button\" onClick={(e) => playOnline(e, -1)} >\r\n                            <img src={black_queen} className=\"color-img\" alt=\"black color play\"/>\r\n                        </div>\r\n                        <div className=\"random piece-button\" onClick={(e) => playOnline(e, Math.random() < 0.5 ? 1 : -1)}>\r\n                            <img src={half_queen} className=\"color-img\" alt=\"random color play\"/>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"link-container\">\r\n                        <p className=\"link-text\">{lang === \"en\" ? \"Invite your friend to a match:\" : lang === \"ro\" ? \"Invită-ți prietenul la un meci:\" : \"Hívd meg a barátodat egy meccsre\"} </p>\r\n                        \r\n                        <div className=\"link\">\r\n                            <label htmlFor=\"link-input\">\r\n                                <input type=\"text\" className=\"link-input\" value={`${window.location.href}${id}`} ref={inputLinkRef} onFocus={e => setStop(true)} onBlur={e => setStop(false)} readOnly/>\r\n                            </label>\r\n    \r\n                            <div className=\"copy-button\" onClick={(e) => copyLink(e)} ref={copyButtonRef}>\r\n                                <FontAwesomeIcon \r\n                                    icon={faCheck}\r\n                                    className=\"fa copy-icon\"\r\n                                    ref={copyIconRef}\r\n                                />\r\n                                \r\n                            </div>\r\n                        </div>\r\n                        \r\n                    </div>\r\n\r\n                    <div className=\"icon\"></div>\r\n    \r\n                    {/* <div className=\"icon\">\r\n                        \r\n                    </div>\r\n    \r\n                    <div className=\"icon\">\r\n                        \r\n                    </div> */}\r\n\r\n                    <div className=\"start\">\r\n                        <button className=\"start-button\" onClick={() => clickSound(`/${id}`)}>{lang === \"en\" ? \"Start game!\" : lang === \"ro\" ? \"Incepe jocul!\" : \"Játék kezdése!\"}</button>\r\n                    </div>\r\n                    \r\n                </div>\r\n    \r\n                <div className=\"computer-mode game-mode\" onMouseEnter={() => hoverSound()}>\r\n                    <div className=\"title\">\r\n                            <h2>{lang === \"en\" ? \"Computer\" : lang === \"ro\" ? \"Calculator\" : \"Számítógép\"} </h2>\r\n    \r\n                            <div className=\"icon\">\r\n                                <FontAwesomeIcon \r\n                                    icon={faUser} \r\n                                    color=\"#fff\"\r\n                                    className=\"mode-icon\"\r\n                                />\r\n\r\n                                <FontAwesomeIcon \r\n                                    className=\"mode-icon board-icon\"\r\n                                    icon={faChessBoard}\r\n                                />\r\n                                \r\n                                <FontAwesomeIcon \r\n                                    className=\"mode-icon\"\r\n                                    icon={faRobot}\r\n                                />\r\n                            </div>\r\n                    </div>\r\n    \r\n                    <div className=\"colors\">\r\n                        <div className=\"white piece-button clicked\" onClick={(e) => playComputer(e, 1)}>\r\n                            <img src={white_queen} className=\"color-img\" alt=\"white color play\"/>\r\n                        </div>\r\n                        <div className=\"black piece-button\" onClick={(e) => playComputer(e, -1)} >\r\n                            <img src={black_queen} className=\"color-img\" alt=\"black color play\"/>\r\n                        </div>\r\n                        <div className=\"random piece-button\" onClick={(e) => playComputer(e, Math.random() < 0.5 ? 1 : -1)}>\r\n                            <img src={half_queen} className=\"color-img\" alt=\"random color play\"/>\r\n                        </div>\r\n                    </div>\r\n                  \r\n                    <div className=\"difficulty-selection\">\r\n                        <div ref={difficultyRef} className=\"difficulty\" onClick={(e) => {\r\n                            difficultiesRef.current.classList.toggle(\"show\");\r\n                            difficultyRef.current.classList.toggle(\"show\");\r\n                        }}>\r\n                            \r\n                            <p>{lang === \"en\" ? \"Choose your difficulty\" : lang === \"ro\" ? \"Alege-ți dificultatea\" : \"Válassza ki a nehézséget\"}</p>\r\n                            <FontAwesomeIcon\r\n                                icon={faAngleDown}\r\n                                color=\"#fff\"\r\n                                className=\"icon\"\r\n                            />\r\n                        </div>\r\n                       \r\n                    </div>\r\n    \r\n                    <div className=\"difficulties\" ref={difficultiesRef}>\r\n                        <div className=\"difficulty active\" onClick={(e) => changeDifficulty(e)}>{lang === \"en\" ? \"Easy\" : lang === \"ro\" ? \"Uşor\" : \"Könnyen\"}</div>\r\n                        <div className=\"difficulty\" onClick={(e) => changeDifficulty(e)}>{lang === \"en\" ? \"Medium\" : lang === \"ro\" ? \"Mediu\" : \"Közepes\"}</div>\r\n                        <div className=\"difficulty\" onClick={(e) => changeDifficulty(e)}>{lang === \"en\" ? \"Hard\" : lang === \"ro\" ? \"Greu\" : \"Kemény\"}</div>\r\n                        {/* <div className=\"difficulty\" onClick={(e) => changeDifficulty(e)}>Very Hard</div> */}\r\n                    </div>\r\n    \r\n                    <div className=\"start\">\r\n                        <Link to=\"/computer\">\r\n                            <button className=\"start-button\" onClick={() => startComputerGame()}>{lang === \"en\" ? \"Start game!\" : lang === \"ro\" ? \"Incepe jocul!\" : \"Játék kezdése!\"}</button>\r\n                        </Link>\r\n                        \r\n                    </div>\r\n                    \r\n                </div>\r\n \r\n            </div>\r\n        </div>\r\n        \r\n    );\r\n};","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Computer.jsx",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Online.jsx",["100","101","102","103","104","105","106","107","108"],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Practice.jsx",["109","110"],"import React, { useState, useEffect, useRef } from \"react\";\r\n\r\nimport PracticeBoard from \"./PracticeBoard\";\r\nimport RightSide from \"./RightSide\";\r\nimport LeftSide from \"./LeftSide\";\r\nimport Header from \"./Header\";\r\n\r\nimport '../styles/home.css';\r\n\r\nexport default function Classic() {\r\n\r\n    const [buttonsTarget, setButtonsTarget] = useState(null);\r\n    const [random, setRandom] = useState(null);\r\n    const [choosePiece, setChoosePiece] = useState(null);\r\n    const [deleteIcon, setDeleteIcon] = useState(null);\r\n\r\n    const returnButtonsClick = (e) => {\r\n\r\n        let newTarget = e.target;\r\n\r\n        while (!newTarget.classList.contains('button')) {\r\n            newTarget = newTarget.parentElement;\r\n        }\r\n\r\n        setButtonsTarget(newTarget);\r\n        setRandom(Math.random());\r\n    };\r\n\r\n    const handlePieceChoose = (idx) => {\r\n        console.log(idx)\r\n        setChoosePiece(idx);\r\n    };\r\n\r\n    const handleDelete = () => setDeleteIcon(Math.random());\r\n\r\n    const languageCallback = () => {\r\n        \r\n    };\r\n\r\n    \r\n    return (\r\n        <div className=\"content\">\r\n            <Header languageCallback={languageCallback}/>\r\n            <div className=\"game\">\r\n                <LeftSide practice={true} handlePieceChoose={handlePieceChoose} handleDelete={handleDelete} color={1}/>\r\n                <PracticeBoard color={1} prevButtons={buttonsTarget} random={random} difficulty=\"very hard\" choosePiece={choosePiece} deleteIcon={deleteIcon} />\r\n                <RightSide clickButton={returnButtonsClick} practiceGame={true} computerGame={false} onlineGame={false} timer={false}/>\r\n            </div>\r\n        </div>\r\n        \r\n    );\r\n};","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Classic.jsx",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\LeftSide.jsx",["111","112"],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\ComputerBoard.jsx",["113","114","115","116","117","118"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\r\nimport cloneDeep from 'lodash/cloneDeep';\r\nimport { isArray } from \"lodash\";\r\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\r\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\r\n\r\nimport '../styles/board.css';\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\nconst ROWS = 8;\r\nconst COLUMNS = 8;\r\n\r\nexport default function ComputerBoard({ color, prevButtons, random, difficulty }) {\r\n\r\n    const setColor = localStorage.getItem(\"set-color\") ? parseInt(localStorage.getItem(\"set-color\")) : parseInt(color);\r\n    localStorage.setItem(\"set-color\", setColor);\r\n    const currDifficulty = localStorage.getItem(\"computer-difficulty\") !== null ? difficulty : JSON.parse(localStorage.getItem(\"computer-difficulty\"));\r\n    localStorage.setItem(\"computer-difficulty\", JSON.stringify(difficulty));\r\n\r\n    const createVirtualBoard = () => {\r\n        let board = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            let row = [];\r\n\r\n            for (let j = 0; j < 8; j++)\r\n                if (i === 1) row.push(-setColor * 1);\r\n                else if (i === 6) row.push(setColor * 1);\r\n                else if (i !== 7 && i !== 0) row.push(0);\r\n\r\n            if (color < 0) {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 6, -setColor * 5, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 6, setColor * 5, setColor * 4, setColor * 3, setColor * 2);    \r\n            } else {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 5, -setColor * 6, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 5, setColor * 6, setColor * 4, setColor * 3, setColor * 2);    \r\n            }         \r\n            board.push(row);\r\n        }\r\n\r\n        return board;\r\n    };\r\n\r\n    const boardRef = useRef(null);\r\n    const squareRef = useRef(null);\r\n    \r\n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"computer-current-move\") === null ? 1 : localStorage.getItem(\"computer-current-move\"));\r\n    const [oldIdx, setOldIdx] = useState(null);\r\n    const [possibleMoves, setPossibleMoves] = useState(null);\r\n    const [activePiece, setActivePiece] = useState(null);\r\n    const [dropPiecer, setActiveDrop] = useState(null);\r\n    const virtualBoard = localStorage.getItem(\"computer-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"computer-board\"));\r\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\r\n    const [previewMoves, setPreviewMoves] = useState([]);\r\n    const [gameRunning, setGameRunning] = useState(true);\r\n    const [pawnTransform, setPawnTransform] = useState(null);\r\n    const [prevMoves, setPrevMoves] = useState(localStorage.getItem(\"computer-prev-moves\") !== null ? JSON.parse(localStorage.getItem(\"computer-prev-moves\")) : []);\r\n    const [nextMoves, setNextMoves] = useState(localStorage.getItem(\"computer-next-moves\") !== null ? JSON.parse(localStorage.getItem(\"computer-next-moves\")) : []);\r\n\r\n    const previewVirtualBoard = useRef(virtualBoard);\r\n    const squareElements = useRef(null);\r\n    const currSquareElement = useRef([]);\r\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\r\n    const rookMoved = useRef({\r\n        \"2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        },\r\n\r\n        \"-2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        }\r\n    });\r\n\r\n    const piecesCode = {\r\n        1: faChessPawn,\r\n        2: faChessRook,\r\n        3: faChessKnight,\r\n        4: faChessBishop,\r\n        5: faChessQueen,\r\n        6: faChessKing\r\n    };\r\n\r\n    console.log(virtualBoard);\r\n\r\n    const pieceSound = new Audio(pieceMoveSound);\r\n    const pieceCapture = new Audio(pieceCaptureSound);\r\n    pieceCapture.volume = 0.3;\r\n\r\n    const minX = boardRef.current?.offsetLeft;\r\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\r\n\r\n    const minY = boardRef.current?.offsetTop;\r\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\r\n\r\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\r\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\r\n\r\n    console.log(squareWidth, squareHeight);\r\n\r\n    // Checking everytime prev/next button is pressed\r\n    \r\n    useEffect(() => {\r\n       \r\n        if (!prevButtons) return;\r\n        if (prevButtons.classList.contains('prev-button') && prevMoves.length === 0) return;\r\n        if (prevButtons.classList.contains('next-button') && nextMoves.length === 0) return;\r\n        \r\n        const lastMove = prevButtons.classList.contains('prev-button') ? prevMoves[prevMoves.length - 1] : nextMoves[nextMoves.length - 1];\r\n        console.log(prevButtons, prevMoves, lastMove.pieceCode);\r\n        const currBoard = cloneDeep(newVirtualBoard);\r\n        const oldX = parseInt(lastMove.oldIdx / 8);\r\n        const oldY = lastMove.oldIdx % 8;\r\n        const newX = parseInt(lastMove.newIdx / 8);\r\n        const newY = lastMove.newIdx % 8;\r\n        currBoard[oldX][oldY] = prevButtons.classList.contains('prev-button') ? lastMove.pieceCode : 0;\r\n        currBoard[newX][newY] = lastMove.oldPieceCode;\r\n    \r\n        setNewVirtualBoard(currBoard);\r\n\r\n        if (prevButtons.classList.contains('prev-button')) {\r\n            const newNextMoves = [...nextMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n            localStorage.setItem(\"computer-prev-moves\", JSON.stringify(prevMoves.slice(0, -1)));\r\n            localStorage.setItem(\"computer-next-moves\", JSON.stringify(newNextMoves));\r\n\r\n            setPrevMoves(prevMoves.slice(0, -1));\r\n            setNextMoves(newNextMoves);\r\n\r\n        } else  {\r\n            console.log('ok from here');\r\n            const newPrevMoves = [...prevMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n\r\n            localStorage.setItem(\"computer-prev-moves\", JSON.stringify(newPrevMoves));\r\n            localStorage.setItem(\"computer-next-moves\", JSON.stringify(nextMoves.slice(0, -1)));\r\n        \r\n            setNextMoves(nextMoves.slice(0, -1));\r\n            setPrevMoves(newPrevMoves);\r\n        }\r\n\r\n        localStorage.setItem(\"computer-current-move\", -currentMove);\r\n        localStorage.setItem(\"computer-board\", JSON.stringify(currBoard));\r\n        \r\n        setCurrentMove(-currentMove);\r\n\r\n    }, [random]);\r\n\r\n    // Function for checking the check \r\n\r\n    const getPossibleMoves = (pieceCode, coords, board) => {\r\n        const piece = Math.abs(pieceCode);\r\n        let possibleMoves = [];\r\n\r\n        // Current coordonates\r\n        const currentX = parseInt(coords / 8);\r\n        const currentY = coords % 8; \r\n\r\n        console.log(currentX, currentY);\r\n\r\n        // Code for pawn\r\n        if (piece === 1) {\r\n\r\n            // Coordonates for possible moves\r\n            const newDiagX = currentX - (pieceCode * setColor);\r\n            const newDiagY = currentY + (pieceCode * setColor);\r\n            const newDiagY2 = currentY - (pieceCode * setColor);\r\n            \r\n            const newCoords = newDiagX * 8 + newDiagY;\r\n            const newCoords2 = newDiagX * 8 + newDiagY2;\r\n            const newFrontCoords = newDiagX * 8 + currentY;\r\n            const frontElement = board[newDiagX] &&\r\n                                 board[newDiagX][currentY] &&\r\n                                 board[newDiagX][currentY];\r\n\r\n            console.log(frontElement);\r\n\r\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\r\n\r\n            console.log(possibleMoves);\r\n            \r\n            const diagonalElement = board[newDiagX] &&\r\n                                    board[newDiagX][newDiagY] &&\r\n                                    board[newDiagX][newDiagY];\r\n\r\n            const diagonalElement2 = board[newDiagX] &&\r\n                                     board[newDiagX][newDiagY2] &&\r\n                                     board[newDiagX][newDiagY2];\r\n            \r\n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\r\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\r\n                console.log(newFrontX);\r\n                const newFrontCoords = newFrontX * 8 + currentY;\r\n\r\n                const newCoordsSquare = board[newFrontX][currentY];\r\n                if (newCoordsSquare === 0 && frontElement === 0) possibleMoves.push(newFrontCoords);\r\n            }\r\n\r\n            if (diagonalElement2 !== 0) {\r\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\r\n            }\r\n           \r\n            if (diagonalElement === 0) return possibleMoves;\r\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\r\n\r\n        } else if (piece === 2) {\r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    \r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);    \r\n \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                             break;\r\n                        } else possibleMoves.push(newCoords);    \r\n\r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                                           \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n                        \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 3) {\r\n\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 2\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    }\r\n                    else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n        } else if (piece === 4) {\r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n  \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                       \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves, newSquare, board, newX, newY);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 5) {\r\n            console.log(board); \r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);   \r\n                                         \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {   \r\n\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newCoords, possibleMoves);\r\n                    }   \r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            }\r\n            \r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY, pieceCode);\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY);\r\n                    if (newSquare !== undefined) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n        \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                   \r\n                    if (newSquare !== undefined) {\r\n                        console.log(newX, newY);\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 6) {\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY \r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 1\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    } else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n\r\n            // Movement for rocade\r\n            console.log(kingsMoved.current[pieceCode]);\r\n            if (!kingsMoved.current[pieceCode]) {\r\n                console.log('rocade', rookMoved);\r\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\r\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\r\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\r\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\r\n\r\n                const smallRocadeSquare = board[currentX] &&\r\n                                          board[currentX][currentY + 2] &&\r\n                                          board[currentX][currentY + 2];\r\n\r\n                const bigRocadeSquare = board[currentX] &&\r\n                                        board[currentX][currentY - 3] &&\r\n                                        board[currentX][currentY - 3];\r\n\r\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\r\n\r\n                // Checking if the squares between king and rook are empty \r\n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                   \r\n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\r\n                } \r\n\r\n                for (let i = bigRocadeCoords; i < coords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                    console.log('gdjigdfjhh');\r\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\r\n                } \r\n\r\n                console.log(smallRocadeEmpty, bigRocadeEmpty)\r\n\r\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\r\n                    possibleMoves.push({\r\n                        king: smallRocadeCoords,\r\n                        rook: smallRocadeRookCoords,\r\n                        rocade: \"s\"\r\n                    });\r\n                } \r\n\r\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\r\n                    possibleMoves.push({\r\n                        king: bigRocadeCoords,\r\n                        rook: bigRocadeRookCoords,\r\n                        rocade: \"b\"\r\n                    });\r\n                }\r\n\r\n                \r\n\r\n                // possibleMoves.push(smallRocade);\r\n                // possibleMoves.push(bigRocade);\r\n            }\r\n        }\r\n      \r\n        return possibleMoves;\r\n    };\r\n\r\n    const dragPiece = (e, square) => {\r\n        \r\n        if (!gameRunning) return;\r\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\r\n\r\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\r\n        const containerElement = element.parentElement;\r\n        console.log(containerElement, square);\r\n        const x = e.clientX - 20;\r\n        const y = e.clientY - 20;\r\n        console.log(x, y, square, currentMove);\r\n        containerElement.style.position = 'absolute';\r\n        containerElement.style.left = `${x}px`;\r\n        containerElement.style.top = `${y}px`;\r\n\r\n        \r\n        \r\n        setActivePiece(containerElement);\r\n        setActiveDrop(parseInt(containerElement.classList[2]));\r\n        let newTotalCoords;\r\n        currSquareElement.current.forEach((square, idx) => {\r\n            if (square === containerElement.parentElement) newTotalCoords = idx;\r\n        });\r\n\r\n        setOldIdx(newTotalCoords);\r\n\r\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\r\n        console.log(currPossibleMoves, newVirtualBoard, square, currentMove, newTotalCoords);\r\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\r\n        else {\r\n            setPossibleMoves(currPossibleMoves);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                console.log(move, oldPreviewMoves);\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n        \r\n            let newPreviewMoves = [];\r\n            currPossibleMoves.forEach((move, idx) => {\r\n                setTimeout(() => {\r\n                    const currSquare = currSquareElement.current[move];\r\n\r\n                    if (currSquare && currSquare.firstChild == null) {\r\n                        const dotElement = document.createElement('div');\r\n                        dotElement.classList.add('possible-move')\r\n\r\n                        currSquare.appendChild(dotElement);\r\n                        console.log(currSquare);\r\n                        newPreviewMoves.push(currSquare);\r\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\r\n                        currSquare.firstChild.firstChild.classList.add('attacked');\r\n                        newPreviewMoves.push(currSquare);\r\n                    }\r\n                }, idx * 0);\r\n            });\r\n\r\n            setPreviewMoves(newPreviewMoves);\r\n        }\r\n       \r\n    };\r\n    \r\n    const movePiece = e => {\r\n        \r\n        if (!activePiece) return;\r\n        const x = e.clientX - 15;\r\n        const y = e.clientY - 15;\r\n        activePiece.style.position = 'absolute';\r\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\r\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\r\n        activePiece.style.zIndex = 3;\r\n\r\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\r\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\r\n        \r\n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\r\n        console.log(squareRef.current);\r\n    };\r\n    \r\n    const dropPiece = (e, pieceCode) => {\r\n        \r\n        if (!activePiece || !squareRef.current || oldIdx === null) return;\r\n        if (!possibleMoves) return;\r\n        setActivePiece(null);\r\n        console.log(squareRef.current?.x, squareRef.current?.y)\r\n        const currentX = squareRef.current?.x;\r\n        const currentY = squareRef.current?.y;\r\n        let rocade = false;\r\n        const idx = currentX * 8 + currentY;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n\r\n        const sameIndex = possibleMoves.find(move => {\r\n            if (typeof move === 'object') rocade = move;\r\n            return idx === (typeof move === 'object' ? move.king : move);\r\n        });\r\n\r\n        activePiece.style.left = 'initial';\r\n        activePiece.style.top= 'initial';\r\n        activePiece.position = 'relative';\r\n        activePiece.style.zIndex = 'initial';\r\n        console.log(previewVirtualBoard.current);\r\n\r\n        if (setColor !== parseInt(currentMove)) {\r\n            console.log('here', setColor, currentMove);\r\n            return;\r\n        }\r\n\r\n        const oldBoard = cloneDeep(newVirtualBoard);\r\n        const otherBoard = cloneDeep(newVirtualBoard);\r\n        otherBoard[oldX][oldY] = 0;\r\n        otherBoard[currentX][currentY] = pieceCode; \r\n        previewVirtualBoard.current = otherBoard;\r\n        console.log('afdsokogjfdjjhihijhpjhijhipfghjpifjhpgjhpijhpfgjh', previewVirtualBoard.current);\r\n\r\n        let squaresVirtualBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => squaresVirtualBoard.push(square));\r\n        });\r\n        \r\n        let kingSquare;\r\n\r\n        squaresVirtualBoard.forEach((square, totalIdx) => {\r\n            const iconColor = square && square < 0 ? -1 : 1;\r\n\r\n            if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) kingSquare = totalIdx;\r\n        });  \r\n\r\n        console.log(kingSquare, currentMove,  previewVirtualBoard.current);\r\n        const check = checkCheckOptimised(kingSquare, setColor * 6);\r\n        console.log(check);\r\n\r\n        if (sameIndex !== undefined && !check) {  \r\n\r\n            // Sound of piece moving\r\n            pieceSound.play();\r\n\r\n            const squareDOM = currSquareElement.current[idx];\r\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\r\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\r\n            squareRef.current = null;\r\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\r\n            console.log(cloneIcon, prevMoves);\r\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\r\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\r\n                // squareDOM.innerHTML = '';\r\n                pieceSound.pause();\r\n                pieceCapture.play();\r\n            }\r\n  \r\n            let skipComputerMove = false;\r\n\r\n            // Piece being moved to new square\r\n            if ((squareDOM && pieceCode === 1 && currentX === 0 && setColor === 1) || (squareDOM && pieceCode === -1 && currentX === 7 && setColor === 1) || (squareDOM && pieceCode === 1 && currentX === 7 && setColor === -1) || (squareDOM && pieceCode === -1 && currentX === 0 && setColor === -1)) {\r\n                \r\n                console.log('here'); \r\n                \r\n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\r\n                const leftContainers = containers;  \r\n                console.log(leftContainers);\r\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\r\n                    return (\r\n                        <div \r\n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\r\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\r\n                        >\r\n                            <FontAwesomeIcon \r\n                                icon={piece} \r\n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \r\n                                code={pieceCode}\r\n                                \r\n                            />\r\n                        </div>\r\n                    );\r\n                }) : activePiece;\r\n\r\n                setPawnTransform({\r\n                    idx: idx,\r\n                    elements: elements\r\n                });\r\n\r\n                skipComputerMove = true;\r\n\r\n            } else setPawnTransform(null);\r\n\r\n            setPrevMoves([...prevMoves, \r\n                {\r\n                    oldIdx: oldIdx, \r\n                    newIdx: idx, \r\n                    pieceCode: pieceCode,\r\n                    oldPieceCode: newVirtualBoard[currentX][currentY],\r\n                }\r\n            ]);\r\n\r\n            setNextMoves([]);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\r\n                    move.removeChild(oldPreviewMoves);\r\n                }\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n\r\n            if (rocade) {\r\n                if (rocade.rocade === 's') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                } else if (rocade.rocade === 'b') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                }\r\n            }\r\n\r\n            if (Math.abs(dropPiecer) === 6) {\r\n                kingsMoved.current[dropPiecer] = true;\r\n                console.log(kingsMoved.current[dropPiecer])\r\n            } else if (dropPiecer === 2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\r\n                console.log(rookMoved.current[2][\"right\"]);\r\n            } else if (dropPiecer === -2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\r\n            }\r\n   \r\n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\r\n            console.log(oldX, oldY, currentX, currentY);\r\n            console.log(cloneVirtualBoard);\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\r\n\r\n            console.log(cloneVirtualBoard);\r\n            \r\n            // Checking if it's giving checkmate to the opponent\r\n            let oppositeKingSquare, newBoard = [];\r\n\r\n            cloneVirtualBoard.forEach(row => {\r\n                row.forEach(square => newBoard.push(square));\r\n            });\r\n\r\n            newBoard.forEach((square, totalIdx) => {\r\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\r\n            });\r\n\r\n            console.log(oppositeKingSquare);\r\n            \r\n            // const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\r\n            // console.log(checkMateOpponent);\r\n            // if (checkMateOpponent) setGameRunning(false);\r\n\r\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\r\n            console.log(checkEqual);\r\n            if (checkEqual) setGameRunning(false);\r\n            localStorage.setItem(\"computer-current-move\", -currentMove);\r\n            // setCurrentMove(-currentMove);\r\n\r\n            localStorage.setItem(\"computer-board\", JSON.stringify(cloneVirtualBoard));\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n\r\n            if (!skipComputerMove) computerMove(cloneVirtualBoard);\r\n           \r\n            console.log(cloneVirtualBoard);\r\n\r\n            // console.log(checkMateOpponent);\r\n            \r\n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\r\n        \r\n    };\r\n\r\n    const computerMove = (newBoard) => {\r\n        console.log('none', currentMove);\r\n        let currMove = currentMove, checkmate = false;\r\n        setCurrentMove(-currMove);\r\n\r\n        const possibleMoves = getAllMoves(-currMove, newBoard);\r\n        console.log(possibleMoves)\r\n        if (possibleMoves.length === 0) {\r\n            setGameRunning(false);\r\n            return;\r\n        }\r\n\r\n        let newPossibleMoves, newMove;\r\n\r\n        if (currDifficulty === \"easy\") {\r\n            newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n            newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n           \r\n        } else if (currDifficulty === \"medium\") {\r\n            \r\n            let minNum = { number: Number.POSITIVE_INFINITY };\r\n            possibleMoves.forEach(move => {\r\n                move.moves.forEach(possMove => {\r\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\r\n                        minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                        newMove = possMove;\r\n                        newPossibleMoves = move; \r\n                    }\r\n                });\r\n            });\r\n\r\n            if (minNum.number === Number.POSITIVE_INFINITY) {\r\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n            }\r\n            \r\n        } else if (currDifficulty === \"hard\") {\r\n            \r\n            let minNum = { number: Number.POSITIVE_INFINITY };\r\n            possibleMoves.forEach(move => {\r\n                move.moves.forEach(possMove => {\r\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\r\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\r\n                            console.log('no, is not defensed');\r\n\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n\r\n            if (minNum.number === Number.POSITIVE_INFINITY) {\r\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n            }\r\n\r\n        } else if (currDifficulty === \"very hard\") {\r\n            let minNum = { number: Number.POSITIVE_INFINITY };\r\n            possibleMoves.forEach(move => {\r\n                move.moves.forEach(possMove => {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    \r\n                    previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\r\n                    previewVirtualBoard.current[parseInt(possMove / 8)][possMove % 8] = move.piece;\r\n                    console.log(previewVirtualBoard.current);\r\n                    let squaresVirtualBoard = [];\r\n\r\n                    previewVirtualBoard.current.forEach(row => {\r\n                        row.forEach(square => squaresVirtualBoard.push(square));\r\n                    });\r\n                    \r\n                    let kingSquare;\r\n\r\n                    squaresVirtualBoard.forEach((square, totalIdx) => {\r\n                        const iconColor = square && square < 0 ? -1 : 1;\r\n                        if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) \r\n                            kingSquare = totalIdx;\r\n                    });  \r\n                    console.log(kingSquare, setColor * 6);\r\n                    if (!isDefensed(newBoard, move.idx, possMove) && checkCheckOptimised(kingSquare, setColor * 6)) {\r\n                        \r\n                        if (checkCheckmate(kingSquare, previewVirtualBoard.current)) checkmate = true;\r\n        \r\n                        minNum.number = -1;\r\n                        newMove = possMove;\r\n                        newPossibleMoves = move;\r\n                    } else if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\r\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\r\n                            console.log('no, is not defensed');\r\n\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        }\r\n                    }\r\n\r\n                    previewVirtualBoard.current = oldBoard;\r\n                });\r\n            });\r\n\r\n            if (minNum.number === Number.POSITIVE_INFINITY) {\r\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n            }\r\n        }\r\n       \r\n        console.log(newMove);\r\n        let cloneVirtualBoard = cloneDeep(newBoard);\r\n\r\n        const oldX = parseInt(newPossibleMoves.idx / 8);\r\n        const oldY = newPossibleMoves.idx % 8;\r\n        const newX = parseInt(newMove / 8);\r\n        const newY = newMove % 8;\r\n\r\n        const iconContainerElement = currSquareElement.current[newPossibleMoves.idx].firstChild;\r\n        iconContainerElement.classList.add('opponent');\r\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\r\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\r\n        iconContainerElement.classList.add('changed-move');\r\n        \r\n        setTimeout(() => {\r\n            // iconContainerElement.classList.remove('opponent');\r\n            iconContainerElement.style.zIndex = 'initial';\r\n            iconContainerElement.style.position = 'initial';\r\n            iconContainerElement.style.left = `initial`;\r\n            iconContainerElement.style.top = `initial`;\r\n            iconContainerElement.style.transform = 'initial';\r\n           \r\n            let sound;\r\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\r\n            else sound = pieceSound;\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[newX][newY] = newPossibleMoves.piece;\r\n\r\n            localStorage.setItem(\"computer-current-move\", setColor);\r\n            localStorage.setItem(\"computer-board\", JSON.stringify(cloneVirtualBoard));\r\n\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n            sound.play();\r\n            if (checkmate) setGameRunning(false);\r\n            setCurrentMove(currMove);\r\n\r\n        }, 750);\r\n    };\r\n\r\n    // Computer check if any piece is attacked and can defense it\r\n\r\n    // const isAttacked = (board, computerIdx, playerIdx) => {\r\n    //     const computerPiece = board[parseInt(computerIdx / 8)][computerIdx % 8];\r\n    //     const playerPiece = board[parseInt(playerIdx / 8)][playerIdx % 8];\r\n\r\n    //     let squareBoard = [];\r\n    //     board.forEach(row => {\r\n    //         row.forEach(square => squareBoard.push(square));\r\n    //     });\r\n\r\n    //     const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\r\n    //         if (!checkOppositeColor(square, setColor) && square !== 0) return {\r\n    //             piece: square,\r\n    //             idx: idx\r\n    //         }\r\n    //     });\r\n\r\n    //     const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\r\n\r\n    //     playerPieces.forEach(piece => {\r\n            \r\n    //     });\r\n    // };\r\n\r\n    // Check if player move is defensed\r\n\r\n    const isDefensed = (board, computerIdx, playerIdx) => {\r\n        \r\n        let squareBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => squareBoard.push(square));\r\n        });\r\n\r\n        const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, setColor) && square !== 0) return {\r\n                piece: square,\r\n                idx: idx\r\n            };\r\n\r\n            return undefined;\r\n        });\r\n\r\n        const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\r\n\r\n        console.log(playerPieces);\r\n\r\n        let cloneBoard = cloneDeep(board);\r\n        cloneBoard[parseInt(playerIdx / 8)][playerIdx % 8] = 0;\r\n\r\n        // Get possible moves for each piece\r\n\r\n        return playerPieces.some(piece => {\r\n            const playerPossibleMoves = getPossibleMoves(piece.piece, piece.idx, cloneBoard);\r\n            return playerPossibleMoves.some(move => move === playerIdx);\r\n        });\r\n    };\r\n\r\n\r\n    const getAllMoves = (color, newBoard) => {\r\n        let currBoard = [];\r\n\r\n        newBoard.forEach(row => {\r\n            row.forEach(square => {\r\n                currBoard.push(square);\r\n            });\r\n        });\r\n\r\n        let possibleMoves = [], allMoves = [];\r\n\r\n        currBoard.forEach((square, idx) => {\r\n            if (!checkOppositeColor(color, square) && square !== 0) possibleMoves.push({\r\n                piece: square, \r\n                idx: idx\r\n            });\r\n        });\r\n\r\n        possibleMoves.length !== 0 && possibleMoves.forEach(move => {\r\n            const currPossMoves = getPossibleMoves(move.piece, move.idx, newBoard);\r\n            console.log(move);\r\n            const currMoves = currPossMoves.length !== 0 && isArray(currPossMoves) ? currPossMoves.filter(currPieceMove => {\r\n                if (currPieceMove.rocade != null) return false;\r\n                let oldPreviewVirtualBoard = cloneDeep(previewVirtualBoard.current);\r\n                console.log(move.idx, currPieceMove);\r\n                previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\r\n                previewVirtualBoard.current[parseInt(currPieceMove / 8)][currPieceMove % 8] = move.piece;\r\n                let kingSquare;\r\n                console.log(newVirtualBoard);\r\n                previewVirtualBoard.current.forEach((row, rowIdx) => {\r\n                    row.forEach((square, squareIdx) => {\r\n                        if (square === -setColor * 6) kingSquare = rowIdx * 8 + squareIdx;\r\n                    });\r\n                });\r\n                \r\n                const isCheck = checkCheckOptimised(kingSquare, -setColor * 6);\r\n                previewVirtualBoard.current = cloneDeep(oldPreviewVirtualBoard);\r\n                \r\n                return !isCheck;\r\n            }) : [];\r\n\r\n            console.log(currMoves);\r\n            \r\n            if (currMoves.length !== 0) {\r\n                allMoves.push({\r\n                    piece: move.piece,\r\n                    idx: move.idx, \r\n                    moves: currMoves\r\n                });\r\n            }\r\n        });\r\n\r\n        console.log(allMoves);\r\n\r\n        return allMoves;\r\n    };\r\n\r\n    const computerMoveFirst = () => {\r\n        let newBoard1 = cloneDeep(newVirtualBoard);\r\n        newBoard1[2][0] = 0;\r\n        newBoard1[0][1] = 3;\r\n        setNewVirtualBoard(newBoard1);\r\n        const possibleMoves = getAllMoves(currentMove, newBoard1);\r\n        console.log(possibleMoves, Math.random() * possibleMoves.length);\r\n        const randomPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n        const randomMove = randomPossibleMoves.moves[Math.floor(Math.random() * randomPossibleMoves.moves.length)];\r\n        console.log(randomMove);\r\n        let cloneVirtualBoard = cloneDeep(newBoard1);\r\n\r\n        const oldX = parseInt(randomPossibleMoves.idx / 8);\r\n        const oldY = randomPossibleMoves.idx % 8;\r\n        const newX = parseInt(randomMove / 8);\r\n        const newY = randomMove % 8;\r\n        console.log(newX, newY);\r\n\r\n        const iconContainerElement = currSquareElement.current[randomPossibleMoves.idx].firstChild;\r\n        iconContainerElement.classList.add('opponent');\r\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\r\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\r\n        iconContainerElement.classList.add('changed-move');\r\n        \r\n        setTimeout(() => {\r\n            // iconContainerElement.classList.remove('opponent');\r\n            iconContainerElement.style.zIndex = 'initial';\r\n            iconContainerElement.style.position = 'initial';\r\n            iconContainerElement.style.left = `initial`;\r\n            iconContainerElement.style.top = `initial`;\r\n            iconContainerElement.style.transform = 'initial';\r\n            \r\n           \r\n            let sound;\r\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\r\n            else sound = pieceSound;\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[newX][newY] = randomPossibleMoves.piece;\r\n\r\n            localStorage.setItem(\"computer-current-move\", setColor);\r\n            localStorage.setItem(\"computer-board\", JSON.stringify(cloneVirtualBoard));\r\n\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n            sound.play();\r\n            setCurrentMove(setColor);\r\n\r\n          \r\n        }, 750);\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (setColor === -1) computerMoveFirst();\r\n    }, [setColor]);\r\n    \r\n       \r\n \r\n\r\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\r\n\r\n        // Get transformed piece's code\r\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\r\n        const newBoard = cloneDeep(newVirtualBoard);\r\n        const currentX = parseInt(idx / 8);\r\n        const currentY = idx % 8;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n        newBoard[currentX][currentY] = transformPieceCode;\r\n        newBoard[oldX][oldY] = 0;\r\n        setNewVirtualBoard(newBoard);\r\n        console.log(newBoard);\r\n        previewVirtualBoard.current = newBoard;\r\n        console.log(newBoard);\r\n        \r\n        setPawnTransform({\r\n            idx: idx,\r\n            piece: transformPieceCode,\r\n            elements: []\r\n        });\r\n\r\n        localStorage.setItem(\"computer-board\", JSON.stringify(newBoard));\r\n    };\r\n\r\n    const checkOppositeColor = (piece1, piece2) => {\r\n        if (piece1 < 0 && piece2 > 0) return true;\r\n        else if (piece1 > 0 && piece2 < 0) return true;\r\n        return false;\r\n    }\r\n\r\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        // Getting coords\r\n        const currentX = parseInt(kingSquare / 8);\r\n        const currentY = kingSquare % 8;\r\n        const pieceCode = kCode / (-6);\r\n\r\n        let check = false;\r\n\r\n        const kingPossibleSquares = [\r\n            [currentX - 1, currentY - 1],\r\n            [currentX - 1, currentY],\r\n            [currentX - 1, currentY + 1],\r\n            [currentX, currentY - 1],\r\n            [currentX, currentY + 1],\r\n            [currentX + 1, currentY - 1],\r\n            [currentX + 1, currentY],\r\n            [currentX + 1, currentY + 1]\r\n        ];\r\n\r\n        console.log(previewVirtualBoard.current, pieceCode);\r\n\r\n        kingPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === -kCode && square !== null) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        // Pawns \r\n\r\n        const pawnPossibleSquares = [\r\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\r\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\r\n        ];\r\n        \r\n        console.log(pawnPossibleSquares);\r\n\r\n        pawnPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                console.log('check');\r\n                check = true;\r\n            }\r\n        });\r\n        \r\n        // Rows\r\n\r\n        if (currentX > 0) {\r\n            for (let i = currentX - 1; i >= 0; i--) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentX < ROWS - 1) {\r\n            for (let i = currentX + 1; i < ROWS; i++) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n\r\n                console.log(rowSquare, pieceCode, previewVirtualBoard.current);\r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare * pieceCode === 5) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) {\r\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\r\n                        console.log(checkMate);\r\n                    }\r\n                    console.log(\"here in if\")\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Columns \r\n\r\n        if (currentY > 0) {\r\n            for (let i = currentY - 1; i >= 0; i--) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentY < COLUMNS - 1) {\r\n            for (let i = currentX + 1; i < COLUMNS; i++) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top left\r\n        \r\n        if (currentX > 0 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top right\r\n\r\n        if (currentX > 0 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom left\r\n\r\n        if (currentX < ROWS - 1 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom right\r\n\r\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Knight moves\r\n\r\n        const knightPossibleMoves = [\r\n            [currentX - 2, currentY - 1],\r\n            [currentX - 2, currentY + 1],\r\n            [currentX + 2, currentY - 1],\r\n            [currentX + 2, currentY + 1],\r\n            [currentX - 1, currentY - 2],\r\n            [currentX - 1, currentY + 2],\r\n            [currentX + 1, currentY - 2],\r\n            [currentX + 1, currentY + 2]\r\n        ];\r\n\r\n        \r\n        \r\n        knightPossibleMoves.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode * 3) { \r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        return check;\r\n    };\r\n\r\n    const legalBoard = (board, kCode) => {\r\n        return board.some(row => {\r\n            return row.some(cell => cell === kCode);\r\n        });\r\n    };\r\n\r\n    // Checking the check-mate\r\n\r\n    const checkCheckmate = (kCode, board) => {\r\n\r\n        console.log(board);\r\n        const constantBoard = board;\r\n        let currBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            }\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n        console.log(mySquares);\r\n        let checkMate = true;\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        mySquares.forEach(square => {\r\n\r\n            // Next possible moves to check if it's checkmate\r\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            console.log(possibleMovesCheckmate);\r\n\r\n            possibleMovesCheckmate.forEach(move => {\r\n                const currX = parseInt(square.coords / 8);\r\n                const currY = square.coords % 8;\r\n                const newX = parseInt(move / 8);\r\n                const newY = move % 8;\r\n                const newBoard = cloneDeep(constantBoard);\r\n\r\n                newBoard[currX][currY] = 0;\r\n                \r\n                if (newBoard != null && (newBoard[newX] != null) && (newBoard[newX][newY] != null)) {\r\n                    if (newBoard[newX][newY] !== 0) {\r\n                        const enemyPieceNumber = newBoard[newX][newY];\r\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\r\n                    } else newBoard[newX][newY] = square.pieceCode;\r\n                }\r\n\r\n                \r\n                previewVirtualBoard.current = cloneDeep(newBoard);\r\n\r\n                let allInOneBoard = [];\r\n\r\n                previewVirtualBoard.current.forEach(row => {\r\n                    row.forEach(square => allInOneBoard.push(square));\r\n                });\r\n\r\n                console.log(newBoard, kCode);\r\n\r\n                console.log(allInOneBoard);\r\n\r\n                let kingSquare = -1;\r\n\r\n                allInOneBoard.forEach((square, idx) => {\r\n                    if (square === kCode) kingSquare = idx;\r\n                });\r\n\r\n                console.log(kingSquare);\r\n                const possibleBoard = legalBoard(newBoard, kCode);\r\n                \r\n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\r\n                console.log(newBoardCheck, kingSquare, kCode);\r\n                if (!newBoardCheck && possibleBoard) checkMate = false;\r\n                \r\n            });\r\n        });\r\n        \r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n       if (checkMate) setGameRunning(false);\r\n       return checkMate;\r\n        \r\n    };\r\n\r\n    const checkPat = (pieceCode, board) => {\r\n        let currBoard = [];\r\n        console.log(board, pieceCode);\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\r\n            if (checkOppositeColor(pieceCode, square)) return {\r\n                pieceCode: square,\r\n                coords: coords\r\n            };\r\n        });\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        return oppositeSquares.every(square => {\r\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\r\n            console.log(oppPossibleMoves);\r\n            return oppPossibleMoves.length === 0;\r\n        });\r\n    };\r\n\r\n\r\n    const addSquares = () => {\r\n        let squareComponents = [];\r\n        console.log(virtualBoard);\r\n        const board = newVirtualBoard.map((row, rowIdx) => {\r\n\r\n            const rows = row.map((square, squareIdx) => {\r\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\r\n                const realIdx = rowIdx * 8 + squareIdx;\r\n               \r\n                const squareComponent = \r\n                    <div className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} key={squareIdx} ref={ref => { \r\n                        currSquareElement.current[realIdx] = ref;\r\n                    }}>\r\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\r\n                            pawnTransform.elements.length > 0 ? (<div \r\n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                key={totalIdx}\r\n                            >   \r\n                                {pawnTransform.elements}  \r\n                            </div>)\r\n                            : (\r\n                                <div \r\n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\r\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\r\n                                    onMouseMove={e => movePiece(e)}\r\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \r\n                                    key={totalIdx}\r\n                                >   \r\n                                    <FontAwesomeIcon \r\n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \r\n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \r\n                                        code={pawnTransform.piece}\r\n                                    />\r\n                                </div>\r\n                            )\r\n                        ) : square !== 0 ? (\r\n                            <div \r\n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\r\n                                onMouseMove={e => movePiece(e)}\r\n                                onMouseUp={e => dropPiece(e, square)} \r\n                                key={totalIdx}\r\n                            >   \r\n                                <FontAwesomeIcon \r\n                                    icon={piecesCode[Math.abs(square).toString()]} \r\n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \r\n                                    code={square}\r\n                                />\r\n                            </div>\r\n                        ) : \"\"}\r\n                    </div>;\r\n\r\n                return squareComponent;\r\n            });\r\n            return (\r\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\r\n                    {rows}\r\n                </div>\r\n            );\r\n        });\r\n\r\n        squareElements.current = squareComponents;\r\n\r\n        return board;\r\n    };\r\n\r\n    return (\r\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\r\n            {addSquares()}\r\n            <div className=\"letters\">\r\n                <p>A</p>\r\n                <p>B</p>\r\n                <p>C</p>\r\n                <p>D</p>\r\n                <p>E</p>\r\n                <p>F</p>\r\n                <p>G</p>\r\n                <p>H</p>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\RightSide.jsx",["119","120"],"import React, {useEffect, useState} from \"react\";\r\nimport { faArrowLeft, faArrowRight } from '@fortawesome/free-solid-svg-icons';\r\n\r\nimport ResetButton from './ResetButton';\r\nimport PreviousButton from \"./PreviousButton\";\r\n\r\nimport '../styles/right-side.css';\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\n\r\nexport default function RightSide({clickButton, onlineGame, computerGame, practiceGame, empty, stopTimer, time, gameEnd, timer, players, color}) {\r\n\r\n    console.warn(empty);\r\n    console.log(stopTimer);\r\n    const [upTimerMinutes, setUpTimerMinutes] = useState(onlineGame ? (localStorage.getItem(\"online-opponent-minutes\") ? localStorage.getItem(\"online-opponent-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-opponent-minutes\") ? localStorage.getItem(\"computer-opponent-minutes\") : time) : (localStorage.getItem(\"opponent-minutes\") ? localStorage.getItem(\"opponent-minutes\") : time));\r\n    const [upTimerSeconds, setUpTimerSeconds] = useState(onlineGame ? (localStorage.getItem(\"online-opponent-seconds\") ? localStorage.getItem(\"online-opponent-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-opponent-seconds\") ? localStorage.getItem(\"computer-opponent-seconds\") : 0) : (localStorage.getItem(\"opponent-seconds\") ? localStorage.getItem(\"opponent-seconds\") : 0));\r\n    const [downTimerMinutes, setDownTimerMinutes] = useState(onlineGame ? (localStorage.getItem(\"online-player-minutes\") ? localStorage.getItem(\"online-player-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-player-minutes\") ? localStorage.getItem(\"computer-player-minutes\") : time) : (localStorage.getItem(\"player-minutes\") ? localStorage.getItem(\"player-minutes\") : time));\r\n    const [downTimerSeconds, setDownTimerSeconds] = useState(onlineGame ? (localStorage.getItem(\"online-player-seconds\") ? localStorage.getItem(\"online-player-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-player-seconds\") ? localStorage.getItem(\"computer-player-seconds\") : 0) : (localStorage.getItem(\"player-seconds\") ? localStorage.getItem(\"player-seconds\") : 0));\r\n    \r\n    let downTimeSec = onlineGame ? (localStorage.getItem(\"online-player-seconds\") ? localStorage.getItem(\"online-player-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-player-seconds\") ? localStorage.getItem(\"computer-player-seconds\") : 0) : (localStorage.getItem(\"player-seconds\") ? localStorage.getItem(\"player-seconds\") : 0);\r\n    let upTimeSec = onlineGame ? (localStorage.getItem(\"online-opponent-seconds\") ? localStorage.getItem(\"online-opponent-seconds\") : 0) : computerGame ? (localStorage.getItem(\"computer-opponent-seconds\") ? localStorage.getItem(\"computer-opponent-seconds\") : 0) : (localStorage.getItem(\"opponent-seconds\") ? localStorage.getItem(\"opponent-seconds\") : 0);\r\n    let downTimeMinutes = onlineGame ? (localStorage.getItem(\"online-player-minutes\") ? localStorage.getItem(\"online-player-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-player-minutes\") ? localStorage.getItem(\"computer-player-minutes\") : time) : (localStorage.getItem(\"player-minutes\") ? localStorage.getItem(\"player-minutes\") : time);\r\n    let upTimeMinutes = onlineGame ? (localStorage.getItem(\"online-opponent-minutes\") ? localStorage.getItem(\"online-opponent-minutes\") : time) : computerGame ? (localStorage.getItem(\"computer-opponent-minutes\") ? localStorage.getItem(\"computer-opponent-minutes\") : time) : (localStorage.getItem(\"opponent-minutes\") ? localStorage.getItem(\"opponent-minutes\") : time);\r\n    // const setStorage = computerGame ? (localStorage.getItem(\"computer-opponent-minutes\") || localStorage.getItem(\"computer-opponent-seconds\") || localStorage.getItem(\"computer-player-minutes\") || localStorage.getItem(\"computer-player-seconds\")) : (localStorage.getItem(\"opponent-minutes\") || localStorage.getItem(\"opponent-seconds\") || localStorage.getItem(\"player-minutes\") || localStorage.getItem(\"player-seconds\"));\r\n    // console.log(setStorage);\r\n\r\n    const downTimer = () => {\r\n        if (!timer) return;\r\n        if (onlineGame && players < 2) return;\r\n        if (downTimeSec <= 0 && downTimeMinutes <= 0) {\r\n            gameEnd(!color);\r\n            clearInterval(upTimer);\r\n            clearInterval(downTimer);\r\n            return;\r\n        }\r\n\r\n        console.log(stopTimer);\r\n   \r\n        if (downTimeSec <= 0) {\r\n            setDownTimerMinutes(downTime => downTime - 1);\r\n            setDownTimerSeconds(59);\r\n            downTimeSec = 59;\r\n            downTimeMinutes--;\r\n        } else {\r\n            setDownTimerSeconds(downTime => downTime - 1);\r\n            downTimeSec--;\r\n        }\r\n        if (onlineGame) {\r\n            localStorage.setItem(\"online-player-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"online-player-seconds\", downTimeSec);\r\n        }\r\n        else if (computerGame) {\r\n            localStorage.setItem(\"computer-player-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"computer-player-seconds\", downTimeSec);\r\n        } else {\r\n            localStorage.setItem(\"player-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"player-seconds\", downTimeSec);\r\n        }\r\n        \r\n    };\r\n\r\n    const upTimer = () => {\r\n        if (computerGame) return;\r\n        if (onlineGame && players < 2) return;\r\n        if (upTimeSec <= 0 && upTimeMinutes <= 0) {\r\n            gameEnd(color);\r\n            clearInterval(upTimer);\r\n            clearInterval(downTimer);\r\n            return;\r\n        }\r\n\r\n\r\n        if (upTimeSec <= 0) {\r\n            setUpTimerMinutes(upTime => upTime - 1);\r\n            setUpTimerSeconds(59);\r\n            upTimeSec = 59;\r\n            upTimeMinutes--;\r\n        } else {\r\n            setUpTimerSeconds(upTime => upTime - 1);\r\n            upTimeSec--;\r\n        }\r\n\r\n        if (onlineGame) {\r\n            localStorage.setItem(\"online-opponent-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"online-opponent-seconds\", downTimeSec);\r\n        }\r\n        else if (computerGame) {\r\n            localStorage.setItem(\"computer-opponent-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"computer-opponent-seconds\", downTimeSec);\r\n        } else {\r\n            localStorage.setItem(\"opponent-minutes\", downTimeMinutes);\r\n            localStorage.setItem(\"opponent-seconds\", downTimeSec);\r\n        }\r\n       \r\n    };\r\n\r\n    \r\n\r\n    useEffect(() => {\r\n        const interval1 = setInterval(downTimer, 1000);\r\n        const interval2 = setInterval(upTimer, 1000);\r\n        \r\n        if (stopTimer || (onlineGame && players < 2)) clearInterval(interval1);\r\n        else if (!stopTimer) clearInterval(interval2);\r\n\r\n        return () => {\r\n            clearInterval(interval1);\r\n            clearInterval(interval2);\r\n        }\r\n    }, [stopTimer, players]);\r\n    \r\n\r\n    if (empty) return <div></div>;\r\n\r\n    return (\r\n        <div className=\"right-side\">\r\n            <div className={`timer opponent-timer ${color === 1 ? \"black\" : \"white\"} `}>\r\n                {!computerGame && !practiceGame && <h2>{upTimerMinutes < 10 ? `0${upTimerMinutes}` : upTimerMinutes} : {upTimerSeconds < 10 ? `0${upTimerSeconds}` : upTimerSeconds}</h2>}\r\n            </div>\r\n            <ResetButton computerGame={computerGame} />\r\n            <div className=\"prev-next\">\r\n                <PreviousButton icon={faArrowLeft} classDiv=\"prev-button\" clickButton={clickButton}/>\r\n                <PreviousButton icon={faArrowRight} classDiv=\"next-button\" clickButton={clickButton}/>\r\n            </div>\r\n            <div className={`timer my-timer ${color === 1 ? \"white\" : \"black\"} `}>\r\n                {timer && <h2>{downTimerMinutes < 10 ? `0${downTimerMinutes}` : downTimerMinutes} : {downTimerSeconds < 10 ? `0${downTimerSeconds}` : downTimerSeconds}</h2>}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Board.jsx",["121","122","123"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\r\nimport cloneDeep from 'lodash/cloneDeep';\r\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\r\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\r\n\r\nimport '../styles/board.css';\r\n\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\nconst ROWS = 8;\r\nconst COLUMNS = 8;\r\n\r\nexport default function Board({ color, prevButtons, random, stopTimer, winner, lesson, gameEnd }) {\r\n\r\n    const setColor = color;\r\n  \r\n\r\n    const createVirtualBoard = () => {\r\n        let board = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            let row = [];\r\n\r\n            for (let j = 0; j < 8; j++)\r\n                if (i === 1) row.push(-setColor * 1);\r\n                else if (i === 6) row.push(setColor * 1);\r\n                else if (i !== 7 && i !== 0) row.push(0);\r\n\r\n            if (color < 0) {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 6, -setColor * 5, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 6, setColor * 5, setColor * 4, setColor * 3, setColor * 2);    \r\n            } else {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 5, -setColor * 6, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 5, setColor * 6, setColor * 4, setColor * 3, setColor * 2);    \r\n            }         \r\n            board.push(row);\r\n        }\r\n\r\n        return board;\r\n    };\r\n\r\n    const boardRef = useRef(null);\r\n    const squareRef = useRef(null);\r\n    \r\n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"classic-current-move\") === null ? 1 : localStorage.getItem(\"classic-current-move\"));\r\n    const [oldIdx, setOldIdx] = useState(null);\r\n    const [possibleMoves, setPossibleMoves] = useState(null);\r\n    const [activePiece, setActivePiece] = useState(null);\r\n    const [dropPiecer, setActiveDrop] = useState(null);\r\n    const virtualBoard = localStorage.getItem(\"classic-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"classic-board\"));\r\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\r\n    const [previewMoves, setPreviewMoves] = useState([]);\r\n    const [gameRunning, setGameRunning] = useState(true);\r\n    const [pawnTransform, setPawnTransform] = useState(null);\r\n    const [prevMoves, setPrevMoves] = useState(localStorage.getItem(\"classic-prev-moves\") !== null ? JSON.parse(localStorage.getItem(\"classic-prev-moves\")) : []);\r\n    const [nextMoves, setNextMoves] = useState(localStorage.getItem(\"classic-next-moves\") !== null ? JSON.parse(localStorage.getItem(\"classic-next-moves\")) : []);\r\n \r\n    const previewVirtualBoard = useRef(virtualBoard);\r\n    const squareElements = useRef(null);\r\n    const currSquareElement = useRef([]);\r\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\r\n    const rookMoved = useRef({\r\n        \"2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        },\r\n\r\n        \"-2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        }\r\n    });\r\n\r\n    const piecesCode = {\r\n        1: faChessPawn,\r\n        2: faChessRook,\r\n        3: faChessKnight,\r\n        4: faChessBishop,\r\n        5: faChessQueen,\r\n        6: faChessKing\r\n    };\r\n\r\n    const pieceSound = new Audio(pieceMoveSound);\r\n    const pieceCapture = new Audio(pieceCaptureSound);\r\n    pieceCapture.volume = 0.3;\r\n\r\n    console.log(boardRef.current);\r\n\r\n    const minX = boardRef.current?.offsetLeft;\r\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\r\n\r\n    const minY = boardRef.current?.offsetTop;\r\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\r\n\r\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\r\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\r\n\r\n    console.log(squareWidth, squareHeight);\r\n\r\n    // Checking everytime prev/next button is pressed\r\n    \r\n    useEffect(() => {\r\n       \r\n        if (!prevButtons) return;\r\n        if (prevButtons.classList.contains('prev-button') && prevMoves.length === 0) return;\r\n        if (prevButtons.classList.contains('next-button') && nextMoves.length === 0) return;\r\n        \r\n        const lastMove = prevButtons.classList.contains('prev-button') ? prevMoves[prevMoves.length - 1] : nextMoves[nextMoves.length - 1];\r\n        console.log(prevButtons, prevMoves, lastMove.pieceCode);\r\n        const currBoard = cloneDeep(newVirtualBoard);\r\n        const oldX = parseInt(lastMove.oldIdx / 8);\r\n        const oldY = lastMove.oldIdx % 8;\r\n        const newX = parseInt(lastMove.newIdx / 8);\r\n        const newY = lastMove.newIdx % 8;\r\n        currBoard[oldX][oldY] = prevButtons.classList.contains('prev-button') ? lastMove.pieceCode : 0;\r\n        currBoard[newX][newY] = lastMove.oldPieceCode;\r\n    \r\n        setNewVirtualBoard(currBoard);\r\n\r\n        if (prevButtons.classList.contains('prev-button')) {\r\n            const newNextMoves = [...nextMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n            localStorage.setItem(\"classic-prev-moves\", JSON.stringify(prevMoves.slice(0, -1)));\r\n            localStorage.setItem(\"classic-next-moves\", JSON.stringify(newNextMoves));\r\n\r\n            setPrevMoves(prevMoves.slice(0, -1));\r\n            setNextMoves(newNextMoves);\r\n\r\n        } else  {\r\n            console.log('ok from here');\r\n            const newPrevMoves = [...prevMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n\r\n            localStorage.setItem(\"classic-prev-moves\", JSON.stringify(newPrevMoves));\r\n            localStorage.setItem(\"classic-next-moves\", JSON.stringify(nextMoves.slice(0, -1)));\r\n        \r\n            setNextMoves(nextMoves.slice(0, -1));\r\n            setPrevMoves(newPrevMoves);\r\n        }\r\n\r\n        localStorage.setItem(\"classic-current-move\", -currentMove);\r\n        localStorage.setItem(\"classic-board\", JSON.stringify(currBoard));\r\n        \r\n        setCurrentMove(-currentMove);\r\n\r\n    }, [random]);\r\n\r\n    // Function for checking the check \r\n\r\n    const getPossibleMoves = (pieceCode, coords, board) => {\r\n        const piece = Math.abs(pieceCode);\r\n        let possibleMoves = [];\r\n\r\n        // Current coordonates\r\n        const currentX = parseInt(coords / 8);\r\n        const currentY = coords % 8; \r\n\r\n        console.log(currentX, currentY);\r\n\r\n        // Code for pawn\r\n        if (piece === 1) {\r\n\r\n            // Coordonates for possible moves\r\n            const newDiagX = currentX - (pieceCode * setColor);\r\n            const newDiagY = currentY + (pieceCode * setColor);\r\n            const newDiagY2 = currentY - (pieceCode * setColor);\r\n            \r\n            const newCoords = newDiagX * 8 + newDiagY;\r\n            const newCoords2 = newDiagX * 8 + newDiagY2;\r\n            const newFrontCoords = newDiagX * 8 + currentY;\r\n            const frontElement = board[newDiagX] &&\r\n                                 board[newDiagX][currentY] &&\r\n                                 board[newDiagX][currentY];\r\n\r\n            console.log(frontElement);\r\n\r\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\r\n\r\n            console.log(possibleMoves);\r\n            \r\n            const diagonalElement = board[newDiagX] &&\r\n                                    board[newDiagX][newDiagY] &&\r\n                                    board[newDiagX][newDiagY];\r\n\r\n            const diagonalElement2 = board[newDiagX] &&\r\n                                     board[newDiagX][newDiagY2] &&\r\n                                     board[newDiagX][newDiagY2];\r\n            \r\n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\r\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\r\n                console.log(newFrontX);\r\n                const newFrontCoords = newFrontX * 8 + currentY;\r\n\r\n                const newCoordsSquare = board[newFrontX][currentY];\r\n                if (newCoordsSquare === 0 && frontElement === 0) possibleMoves.push(newFrontCoords);\r\n                \r\n            }\r\n\r\n            if (diagonalElement2 !== 0) {\r\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\r\n            }\r\n           \r\n            if (diagonalElement === 0) return possibleMoves;\r\n            \r\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\r\n\r\n        } else if (piece === 2) {\r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    \r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);    \r\n \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                             break;\r\n                        } else possibleMoves.push(newCoords);    \r\n\r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                                           \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n                        \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 3) {\r\n\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 2\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    }\r\n                    else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n        } else if (piece === 4) {\r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n  \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                       \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves, newSquare, board, newX, newY);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 5) {\r\n            console.log(board); \r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);   \r\n                                         \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {   \r\n\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newCoords, possibleMoves);\r\n                    }   \r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            }\r\n            \r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY, pieceCode);\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY);\r\n                    if (newSquare !== undefined) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n        \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                   \r\n                    if (newSquare !== undefined) {\r\n                        console.log(newX, newY);\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 6) {\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY \r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 1\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    } else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n\r\n            // Movement for rocade\r\n            console.log(kingsMoved.current[pieceCode]);\r\n            if (!kingsMoved.current[pieceCode]) {\r\n                console.log('rocade', rookMoved);\r\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\r\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\r\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\r\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\r\n\r\n                const smallRocadeSquare = board[currentX] &&\r\n                                          board[currentX][currentY + 2] &&\r\n                                          board[currentX][currentY + 2];\r\n\r\n                const bigRocadeSquare = board[currentX] &&\r\n                                        board[currentX][currentY - 3] &&\r\n                                        board[currentX][currentY - 3];\r\n\r\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\r\n\r\n                // Checking if the squares between king and rook are empty \r\n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                   \r\n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\r\n                } \r\n\r\n                for (let i = bigRocadeCoords; i < coords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                    console.log('gdjigdfjhh');\r\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\r\n                } \r\n\r\n                console.log(smallRocadeEmpty, bigRocadeEmpty)\r\n\r\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\r\n                    possibleMoves.push({\r\n                        king: smallRocadeCoords,\r\n                        rook: smallRocadeRookCoords,\r\n                        rocade: \"s\"\r\n                    });\r\n                } \r\n\r\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\r\n                    possibleMoves.push({\r\n                        king: bigRocadeCoords,\r\n                        rook: bigRocadeRookCoords,\r\n                        rocade: \"b\"\r\n                    });\r\n                }\r\n\r\n                \r\n\r\n                // possibleMoves.push(smallRocade);\r\n                // possibleMoves.push(bigRocade);\r\n            }\r\n        }\r\n      \r\n        return possibleMoves;\r\n    };\r\n\r\n    const dragPiece = (e, square) => {\r\n        if (lesson) return;\r\n        if (!gameRunning) return;\r\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\r\n\r\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\r\n        const containerElement = element.parentElement;\r\n        console.log(containerElement, square, containerElement.getBoundingClientRect().top);\r\n \r\n        const x = e.clientX - 20 + (lesson ? window.scrollX : 0);\r\n        const y = e.clientY - 20 + (lesson ? window.scrollY : 0);\r\n        console.log(x, y, square, currentMove);\r\n        containerElement.style.position = 'absolute';\r\n        containerElement.style.left = `${x}px`;\r\n        containerElement.style.top = `${y}px`;\r\n        \r\n        setActivePiece(containerElement);\r\n        setActiveDrop(parseInt(containerElement.classList[2]));\r\n        let newTotalCoords;\r\n        currSquareElement.current.forEach((square, idx) => {\r\n            if (square === containerElement.parentElement) newTotalCoords = idx;\r\n        });\r\n\r\n        setOldIdx(newTotalCoords);\r\n\r\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\r\n        console.log(currPossibleMoves, newVirtualBoard, square, currentMove, newTotalCoords);\r\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\r\n        else {\r\n            setPossibleMoves(currPossibleMoves);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                console.log(move, oldPreviewMoves);\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n        \r\n            let newPreviewMoves = [];\r\n            currPossibleMoves.forEach((move, idx) => {\r\n                setTimeout(() => {\r\n                    const currSquare = currSquareElement.current[move];\r\n\r\n                    if (currSquare && currSquare.firstChild == null) {\r\n                        const dotElement = document.createElement('div');\r\n                        dotElement.classList.add('possible-move')\r\n\r\n                        currSquare.appendChild(dotElement);\r\n                        console.log(currSquare);\r\n                        newPreviewMoves.push(currSquare);\r\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\r\n                        currSquare.firstChild.firstChild.classList.add('attacked');\r\n                        newPreviewMoves.push(currSquare);\r\n                    }\r\n                }, idx * 0);\r\n            });\r\n\r\n            setPreviewMoves(newPreviewMoves);\r\n        }\r\n       \r\n    };\r\n    \r\n    const movePiece = e => {\r\n       \r\n        if (!activePiece) return;\r\n        const x = e.clientX - 20 + (lesson ? window.scrollX : 0);\r\n        const y = e.clientY - 20 + (lesson ? window.scrollY : 0);\r\n        activePiece.style.position = 'absolute';\r\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\r\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\r\n        activePiece.style.zIndex = 3;\r\n\r\n        console.log()\r\n\r\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\r\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\r\n        \r\n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\r\n        console.log(squareRef.current);\r\n    };\r\n    \r\n    const dropPiece = (e, pieceCode) => {\r\n        console.log(winner);\r\n        \r\n        if (!activePiece || !squareRef.current || oldIdx === null) return;\r\n        if (!possibleMoves) return;\r\n        setActivePiece(null);\r\n        console.log(squareRef.current?.x, squareRef.current?.y)\r\n        const currentX = squareRef.current?.x;\r\n        const currentY = squareRef.current?.y;\r\n        let rocade = false;\r\n        const idx = currentX * 8 + currentY;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n\r\n        const sameIndex = possibleMoves.find(move => {\r\n            if (typeof move === 'object') rocade = move;\r\n            return idx === (typeof move === 'object' ? move.king : move);\r\n        });\r\n\r\n        activePiece.style.left = 'initial';\r\n        activePiece.style.top= 'initial';\r\n        activePiece.position = 'relative';\r\n        activePiece.style.zIndex = 'initial';\r\n        console.log(previewVirtualBoard.current);\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n        const otherBoard = cloneDeep(previewVirtualBoard.current);\r\n        otherBoard[oldX][oldY] = 0;\r\n        otherBoard[currentX][currentY] = pieceCode; \r\n        previewVirtualBoard.current = otherBoard;\r\n        console.log('afdsokogjfdjjhihijhpjhijhipfghjpifjhpgjhpijhpfgjh', previewVirtualBoard.current);\r\n\r\n        let squaresVirtualBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => squaresVirtualBoard.push(square));\r\n        });\r\n        \r\n        let kingSquare;\r\n\r\n        squaresVirtualBoard.forEach((square, totalIdx) => {\r\n            const iconColor = square && square < 0 ? -1 : 1;\r\n            if (square === currentMove * 6 && !checkOppositeColor(iconColor, currentMove)) kingSquare = totalIdx;\r\n        });  \r\n\r\n        console.log(kingSquare, currentMove);\r\n        const check = checkCheckOptimised(kingSquare, currentMove * 6);\r\n        console.log(check);\r\n\r\n        if (sameIndex !== undefined && !check && winner == null) {  \r\n\r\n            // Sound of piece moving\r\n            pieceSound.play();\r\n\r\n            const squareDOM = currSquareElement.current[idx];\r\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\r\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\r\n            squareRef.current = null;\r\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\r\n            console.log(cloneIcon, prevMoves);\r\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\r\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\r\n                // squareDOM.innerHTML = '';\r\n                pieceSound.pause();\r\n                pieceCapture.play();\r\n            }\r\n    \r\n\r\n            // Piece being moved to new square\r\n            if ((squareDOM && pieceCode === 1 && currentX === 0) || (squareDOM && pieceCode === -1 && currentX === 7)) {\r\n                \r\n                console.log('here'); \r\n                \r\n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\r\n                const leftContainers = containers;  \r\n                console.log(leftContainers);\r\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\r\n                    return (\r\n                        <div \r\n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\r\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\r\n                        >\r\n                            <FontAwesomeIcon \r\n                                icon={piece} \r\n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \r\n                                code={pieceCode}\r\n                                \r\n                            />\r\n                        </div>\r\n                    );\r\n                }) : activePiece;\r\n\r\n                setPawnTransform({\r\n                    idx: idx,\r\n                    elements: elements\r\n                });\r\n\r\n            } else { \r\n                setPawnTransform(null);\r\n            }\r\n\r\n            setPrevMoves([...prevMoves, \r\n                {\r\n                    oldIdx: oldIdx, \r\n                    newIdx: idx, \r\n                    pieceCode: pieceCode,\r\n                    oldPieceCode: newVirtualBoard[currentX][currentY],\r\n                }\r\n            ]);\r\n\r\n            setNextMoves([]);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\r\n                    move.removeChild(oldPreviewMoves);\r\n                }\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n\r\n            if (rocade) {\r\n                if (rocade.rocade === 's') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                } else if (rocade.rocade === 'b') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                }\r\n            }\r\n\r\n            if (Math.abs(dropPiecer) === 6) {\r\n                kingsMoved.current[dropPiecer] = true;\r\n                console.log(kingsMoved.current[dropPiecer])\r\n            } else if (dropPiecer === 2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\r\n                console.log(rookMoved.current[2][\"right\"]);\r\n            } else if (dropPiecer === -2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\r\n            }\r\n   \r\n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\r\n\r\n            console.log(oldX, oldY, currentX, currentY);\r\n\r\n            console.log(cloneVirtualBoard);\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\r\n\r\n            console.log(cloneVirtualBoard);\r\n            \r\n            // Checking if it's giving checkmate to the opponent\r\n            let oppositeKingSquare, newBoard = [];\r\n\r\n            cloneVirtualBoard.forEach(row => {\r\n                row.forEach(square => newBoard.push(square));\r\n            });\r\n\r\n            newBoard.forEach((square, totalIdx) => {\r\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\r\n            });\r\n\r\n            console.log(oppositeKingSquare);\r\n            \r\n            const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\r\n            console.log(checkMateOpponent);\r\n            if (checkMateOpponent) {\r\n                console.log(\"IM HERE\");\r\n                setGameRunning(false);\r\n                gameEnd(currentMove);\r\n            }\r\n\r\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\r\n            console.log(checkEqual);\r\n            if (checkEqual) {\r\n                setGameRunning(false);\r\n                gameEnd(0);\r\n            }\r\n            localStorage.setItem(\"classic-current-move\", -currentMove);\r\n            let move = currentMove;\r\n            setCurrentMove(-currentMove);\r\n\r\n            localStorage.setItem(\"classic-board\", JSON.stringify(cloneVirtualBoard));\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n           \r\n            console.log(cloneVirtualBoard);\r\n\r\n            // Stopping & starting timer\r\n\r\n            stopTimer(move === 1 ? true : move === -1 ? false : null);\r\n\r\n            // console.log(checkMateOpponent);\r\n            \r\n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\r\n        \r\n    };\r\n\r\n    // const getContainers = (elements, piece) => {\r\n\r\n    //     let currBoard = [];\r\n    //     console.log(piece);\r\n    //     newVirtualBoard.forEach(row => {\r\n    //         row.forEach(square => currBoard.push(square));\r\n    //     });\r\n\r\n    //     const mySquaresClone = currBoard.filter((square, idx) => {\r\n    //         return (!checkOppositeColor(square, piece) && square !== 0);\r\n    //     });\r\n\r\n    //     const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n\r\n    //     console.log(mySquares);\r\n\r\n    //     const result = elements.filter((element, elementIdx) => {\r\n    //         let count = 0;\r\n    //         mySquares.forEach(square => {\r\n    //             if (square - 2 === elementIdx) count++;\r\n    //         });\r\n\r\n    //         console.log(count, elementIdx);\r\n\r\n    //         if (count < 1 && elementIdx === 3) {\r\n    //             console.log('queen not working')\r\n    //             return element;\r\n    //         }\r\n    //         else if (count < 2 && elementIdx !== 3) return element;\r\n\r\n    //         return null;\r\n    //     });\r\n\r\n    //     return result;\r\n    // };\r\n\r\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\r\n\r\n        // Get transformed piece's code\r\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\r\n        const newBoard = cloneDeep(newVirtualBoard);\r\n        const currentX = parseInt(idx / 8);\r\n        const currentY = idx % 8;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n        newBoard[currentX][currentY] = transformPieceCode;\r\n        newBoard[oldX][oldY] = 0;\r\n        setNewVirtualBoard(newBoard);\r\n        console.log(newBoard);\r\n        previewVirtualBoard.current = newBoard;\r\n        console.log(newBoard);\r\n        \r\n        setPawnTransform({\r\n            idx: idx,\r\n            piece: transformPieceCode,\r\n            elements: []\r\n        });\r\n\r\n        localStorage.setItem(\"classic-board\", JSON.stringify(newBoard));\r\n    };\r\n\r\n    const checkOppositeColor = (piece1, piece2) => {\r\n        if (piece1 < 0 && piece2 > 0) return true;\r\n        else if (piece1 > 0 && piece2 < 0) return true;\r\n        return false;\r\n    }\r\n\r\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        if (!isFromCheckMate) console.log(previewVirtualBoard.current);\r\n\r\n        // Getting coords\r\n        const currentX = parseInt(kingSquare / 8);\r\n        const currentY = kingSquare % 8;\r\n        const pieceCode = kCode / (-6);\r\n\r\n        let check = false;\r\n\r\n        const kingPossibleSquares = [\r\n            [currentX - 1, currentY - 1],\r\n            [currentX - 1, currentY],\r\n            [currentX - 1, currentY + 1],\r\n            [currentX, currentY - 1],\r\n            [currentX, currentY + 1],\r\n            [currentX + 1, currentY - 1],\r\n            [currentX + 1, currentY],\r\n            [currentX + 1, currentY + 1]\r\n        ];\r\n\r\n        console.log(previewVirtualBoard.current, pieceCode);\r\n\r\n        kingPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === -kCode && square !== null) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        // Pawns \r\n\r\n        const pawnPossibleSquares = [\r\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\r\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\r\n        ];\r\n        \r\n        console.log(pawnPossibleSquares);\r\n\r\n        pawnPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                console.log('check');\r\n                check = true;\r\n            }\r\n        });\r\n        \r\n        // Rows\r\n\r\n        if (currentX > 0) {\r\n            for (let i = currentX - 1; i >= 0; i--) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n                \r\n                console.log(5 * pieceCode, rowSquare);\r\n\r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentX < ROWS - 1) {\r\n            for (let i = currentX + 1; i < ROWS; i++) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n\r\n                console.log(5 * pieceCode, rowSquare);\r\n               \r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                   \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\r\n                        console.log(checkMate);\r\n                        if (checkMate) {\r\n                            setGameRunning(false);\r\n                            gameEnd(kCode / 6);\r\n                        }\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    console.log(\"here in if\")\r\n                    \r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Columns \r\n\r\n        if (currentY > 0) {\r\n            for (let i = currentY - 1; i >= 0; i--) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                        \r\n                    }\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentY < COLUMNS - 1) {\r\n            for (let i = currentX + 1; i < COLUMNS; i++) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top left\r\n        \r\n        if (currentX > 0 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top right\r\n\r\n        if (currentX > 0 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom left\r\n\r\n        if (currentX < ROWS - 1 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom right\r\n\r\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                console.log(newX, newY, square, 5 * pieceCode);\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    \r\n                    if (!isFromCheckMate) {\r\n                        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                        checkCheckmate(kCode, newVirtualBoard);\r\n                        previewVirtualBoard.current = oldBoard;\r\n                    }\r\n                    check = true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Knight moves\r\n\r\n        const knightPossibleMoves = [\r\n            [currentX - 2, currentY - 1],\r\n            [currentX - 2, currentY + 1],\r\n            [currentX + 2, currentY - 1],\r\n            [currentX + 2, currentY + 1],\r\n            [currentX - 1, currentY - 2],\r\n            [currentX - 1, currentY + 2],\r\n            [currentX + 1, currentY - 2],\r\n            [currentX + 1, currentY + 2]\r\n        ];\r\n\r\n        \r\n        \r\n        knightPossibleMoves.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode * 3) { \r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        return check;\r\n    };\r\n\r\n    const legalBoard = (board, kCode) => {\r\n        return board.some(row => {\r\n            return row.some(cell => cell === kCode);\r\n        });\r\n    };\r\n\r\n    // Checking the check-mate\r\n\r\n    const checkCheckmate = (kCode, board) => {\r\n\r\n        console.log(board);\r\n        const constantBoard = board;\r\n        let currBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            };\r\n            return undefined;\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n        console.log(mySquares);\r\n        let checkMate = true;\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        mySquares.forEach(square => {\r\n\r\n            // Next possible moves to check if it's checkmate\r\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            console.log(square.pieceCode, square.coords, possibleMovesCheckmate);\r\n\r\n            possibleMovesCheckmate.forEach(move => {\r\n                const currX = parseInt(square.coords / 8);\r\n                const currY = square.coords % 8;\r\n                const newX = parseInt(move / 8);\r\n                const newY = move % 8;\r\n                const newBoard = cloneDeep(constantBoard);\r\n\r\n                newBoard[currX][currY] = 0;\r\n                \r\n                if (newBoard != null && (newBoard[newX] != null) && (newBoard[newX][newY] != null)) {\r\n                  \r\n                    if (newBoard[newX][newY] !== 0) {\r\n                        const enemyPieceNumber = newBoard[newX][newY];\r\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\r\n                    } else {\r\n                        newBoard[newX][newY] = square.pieceCode;\r\n                    }\r\n                }\r\n\r\n                console.log(newBoard);\r\n                \r\n                previewVirtualBoard.current = cloneDeep(newBoard);\r\n\r\n                let allInOneBoard = [];\r\n\r\n                previewVirtualBoard.current.forEach(row => {\r\n                    row.forEach(square => allInOneBoard.push(square));\r\n                });\r\n\r\n\r\n                const possibleBoard = legalBoard(newBoard, kCode);\r\n                console.log(newBoard, newBoard[newX][newY], kCode);\r\n\r\n                console.log(allInOneBoard);\r\n\r\n                let kingSquare = -1;\r\n\r\n                allInOneBoard.forEach((square, idx) => {\r\n                    if (square === kCode) kingSquare = idx;\r\n                });\r\n\r\n\r\n                console.log(kingSquare);\r\n                \r\n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\r\n                console.log(previewVirtualBoard.current, newBoardCheck, possibleBoard, kingSquare, kCode);\r\n\r\n                if (!newBoardCheck && possibleBoard) checkMate = false;\r\n                \r\n            });\r\n        });\r\n        \r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n       if (checkMate) {\r\n           setGameRunning(false);\r\n           gameEnd(kCode / -6);\r\n       }\r\n       return checkMate;\r\n        \r\n    };\r\n\r\n    const checkPat = (pieceCode, board) => {\r\n        let currBoard = [];\r\n        console.log(board, pieceCode);\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\r\n            if (checkOppositeColor(pieceCode, square)) return {\r\n                pieceCode: square,\r\n                coords: coords\r\n            };\r\n\r\n            return undefined;\r\n        });\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        return oppositeSquares.every(square => {\r\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\r\n            console.log(oppPossibleMoves);\r\n            return oppPossibleMoves.length === 0;\r\n        });\r\n    };\r\n\r\n\r\n    const addSquares = () => {\r\n        let squareComponents = [];\r\n        console.log(virtualBoard);\r\n        const board = newVirtualBoard.map((row, rowIdx) => {\r\n\r\n            const rows = row.map((square, squareIdx) => {\r\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\r\n                const realIdx = rowIdx * 8 + squareIdx;\r\n               \r\n                const squareComponent = \r\n                    <div className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} key={squareIdx} ref={ref => { \r\n                        currSquareElement.current[realIdx] = ref;\r\n                    }}>\r\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\r\n                            pawnTransform.elements.length > 0 ? (<div \r\n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                key={totalIdx}\r\n                            >   \r\n                                {pawnTransform.elements}  \r\n                            </div>)\r\n                            : (\r\n                                <div \r\n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\r\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\r\n                                    onMouseMove={e => movePiece(e)}\r\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \r\n                                    key={totalIdx}\r\n                                >   \r\n                                    <FontAwesomeIcon \r\n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \r\n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \r\n                                        code={pawnTransform.piece}\r\n                                    />\r\n                                </div>\r\n                            )\r\n                        ) : square !== 0 ? (\r\n                            <div \r\n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\r\n                                onMouseMove={e => movePiece(e)}\r\n                                onMouseUp={e => dropPiece(e, square)} \r\n                                key={totalIdx}\r\n                            >   \r\n                                <FontAwesomeIcon \r\n                                    icon={piecesCode[Math.abs(square).toString()]} \r\n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \r\n                                    code={square}\r\n                                />\r\n                            </div>\r\n                        ) : \"\"}\r\n                    </div>;\r\n\r\n                return squareComponent;\r\n            });\r\n            return (\r\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\r\n                    {rows}\r\n                </div>\r\n            );\r\n        });\r\n\r\n        squareElements.current = squareComponents;\r\n\r\n        return board;\r\n    };\r\n\r\n    return (\r\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\r\n            {addSquares()}\r\n            <div className=\"letters\">\r\n                <p>A</p>\r\n                <p>B</p>\r\n                <p>C</p>\r\n                <p>D</p>\r\n                <p>E</p>\r\n                <p>F</p>\r\n                <p>G</p>\r\n                <p>H</p>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\OnlineBoard.jsx",["124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\r\nimport cloneDeep from 'lodash/cloneDeep';\r\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\r\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\r\n\r\nimport '../styles/board.css';\r\nimport OnlineSocket from \"./OnlineSocket\";\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\nconst SQUARES = 64;\r\nconst ROWS = 8;\r\nconst COLUMNS = 8;\r\n\r\nexport default function OnlineBoard({ color, prevButtons, random, socket, oppId, players, stopTimer }) {\r\n\r\n    const setColor = color;\r\n   \r\n    const createVirtualBoard = () => {\r\n        let board = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            let row = [];\r\n\r\n            for (let j = 0; j < 8; j++)\r\n                if (i === 1) row.push(-setColor * 1);\r\n                else if (i === 6) row.push(setColor * 1);\r\n                else if (i !== 7 && i !== 0) row.push(0);\r\n\r\n            if (color < 0) {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 6, -setColor * 5, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 6, setColor * 5, setColor * 4, setColor * 3, setColor * 2);    \r\n            } else {\r\n                if (i === 0) row.push(-setColor * 2, -setColor * 3, -setColor * 4, -setColor * 5, -setColor * 6, -setColor * 4, -setColor * 3, -setColor * 2);\r\n                else if (i === 7) row.push(setColor * 2, setColor * 3, setColor * 4, setColor * 5, setColor * 6, setColor * 4, setColor * 3, setColor * 2);    \r\n            }         \r\n            board.push(row);\r\n        }\r\n\r\n        return board;\r\n    };\r\n\r\n    const boardRef = useRef(null);\r\n    const squareRef = useRef(null);\r\n    \r\n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"online-current-move\") === null ? 1 : localStorage.getItem(\"online-current-move\"));\r\n    const [currentTotalCoords, setCurrentTotalCoords] = useState(null);\r\n    const [oldIdx, setOldIdx] = useState(null);\r\n    const [possibleMoves, setPossibleMoves] = useState(null);\r\n    const [activePiece, setActivePiece] = useState(null);\r\n    const [dropPiecer, setActiveDrop] = useState(null);\r\n    const [virtualBoard, setVirtualBoard] = useState(localStorage.getItem(\"online-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"online-board\")));\r\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\r\n    const [previewMoves, setPreviewMoves] = useState([]);\r\n    const [gameRunning, setGameRunning] = useState(true);\r\n    const [pawnTransform, setPawnTransform] = useState(null);\r\n   \r\n    const [sendPiece, setSendPiece] = useState(null);\r\n\r\n    const previewVirtualBoard = useRef(virtualBoard);\r\n    const squareElements = useRef(null);\r\n    const currSquareElement = useRef([]);\r\n    const oldChildren = useRef([]);\r\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\r\n    const rookMoved = useRef({\r\n        \"2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        },\r\n\r\n        \"-2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        }\r\n    });\r\n\r\n    const piecesCode = {\r\n        1: faChessPawn,\r\n        2: faChessRook,\r\n        3: faChessKnight,\r\n        4: faChessBishop,\r\n        5: faChessQueen,\r\n        6: faChessKing\r\n    };\r\n\r\n    const pieceSound = new Audio(pieceMoveSound);\r\n    const pieceCapture = new Audio(pieceCaptureSound);\r\n    pieceCapture.volume = 0.3;\r\n\r\n\r\n    const minX = boardRef.current?.offsetLeft;\r\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\r\n\r\n    const minY = boardRef.current?.offsetTop;\r\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\r\n\r\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\r\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\r\n\r\n    const player2Color = virtualBoard[0][0] > 0 ? \"white\" : \"black\";\r\n    const player1Color = player2Color === \"white\" ? \"black\" : \"white\";\r\n\r\n    // Function for checking the check \r\n\r\n    const getPossibleMoves = (pieceCode, coords, board) => {\r\n        const piece = Math.abs(pieceCode);\r\n        let possibleMoves = [];\r\n\r\n        // Current coordonates\r\n        const currentX = parseInt(coords / 8);\r\n        const currentY = coords % 8; \r\n\r\n\r\n        // Code for pawn\r\n        if (piece === 1) {\r\n\r\n            // Coordonates for possible moves\r\n            const newDiagX = currentX - (pieceCode * setColor);\r\n            const newDiagY = currentY + (pieceCode * setColor);\r\n            const newDiagY2 = currentY - (pieceCode * setColor);\r\n            \r\n            const newCoords = newDiagX * 8 + newDiagY;\r\n            const newCoords2 = newDiagX * 8 + newDiagY2;\r\n            const newFrontCoords = newDiagX * 8 + currentY;\r\n            const frontElement = board[newDiagX] &&\r\n                                 board[newDiagX][currentY] &&\r\n                                 board[newDiagX][currentY];\r\n\r\n\r\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\r\n\r\n           \r\n            \r\n            const diagonalElement = board[newDiagX] &&\r\n                                    board[newDiagX][newDiagY] &&\r\n                                    board[newDiagX][newDiagY];\r\n\r\n            const diagonalElement2 = board[newDiagX] &&\r\n                                     board[newDiagX][newDiagY2] &&\r\n                                     board[newDiagX][newDiagY2];\r\n            \r\n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\r\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\r\n               \r\n                const newFrontCoords = newFrontX * 8 + currentY;\r\n\r\n                const newCoordsSquare = board[newFrontX][currentY];\r\n                if (newCoordsSquare === 0) possibleMoves.push(newFrontCoords);\r\n                \r\n            }\r\n\r\n            if (diagonalElement2 !== 0) {\r\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\r\n            }\r\n           \r\n            if (diagonalElement === 0) return possibleMoves;\r\n            \r\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\r\n\r\n        } else if (piece === 2) {\r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    \r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);    \r\n \r\n                       \r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                             break;\r\n                        } else possibleMoves.push(newCoords);    \r\n\r\n                       \r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                                           \r\n                       \r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n                        \r\n                      \r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 3) {\r\n\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 2\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    }\r\n                    else possibleMoves.push(newCoords);\r\n\r\n                   \r\n                }\r\n            });\r\n        } else if (piece === 4) {\r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            \r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n  \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                       \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves, newSquare, board, newX, newY);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 5) {\r\n            console.log(board); \r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);   \r\n                                         \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {   \r\n\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newCoords, possibleMoves);\r\n                    }   \r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            }\r\n            \r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY, pieceCode);\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY);\r\n                    if (newSquare !== undefined) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n        \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                   \r\n                    if (newSquare !== undefined) {\r\n                        console.log(newX, newY);\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 6) {\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY \r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 1\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    } else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n\r\n            // Movement for rocade\r\n            console.log(kingsMoved.current[pieceCode]);\r\n            if (!kingsMoved.current[pieceCode]) {\r\n                console.log('rocade', rookMoved);\r\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\r\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\r\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\r\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\r\n\r\n                const smallRocadeSquare = board[currentX] &&\r\n                                          board[currentX][currentY + 2] &&\r\n                                          board[currentX][currentY + 2];\r\n\r\n                const bigRocadeSquare = board[currentX] &&\r\n                                        board[currentX][currentY - 3] &&\r\n                                        board[currentX][currentY - 3];\r\n\r\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\r\n\r\n                // Checking if the squares between king and rook are empty \r\n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                   \r\n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\r\n                } \r\n\r\n                for (let i = bigRocadeCoords; i < coords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\r\n                } \r\n\r\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\r\n                    possibleMoves.push({\r\n                        king: smallRocadeCoords,\r\n                        rook: smallRocadeRookCoords,\r\n                        rocade: \"s\"\r\n                    });\r\n                } \r\n\r\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\r\n                    possibleMoves.push({\r\n                        king: bigRocadeCoords,\r\n                        rook: bigRocadeRookCoords,\r\n                        rocade: \"b\"\r\n                    });\r\n                }\r\n\r\n                \r\n\r\n                // possibleMoves.push(smallRocade);\r\n                // possibleMoves.push(bigRocade);\r\n            }\r\n        }\r\n      \r\n        return possibleMoves;\r\n    };\r\n\r\n    const dragPiece = (e, square) => {\r\n        \r\n        if (!gameRunning) return;\r\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\r\n\r\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\r\n        const containerElement = element.parentElement;\r\n     \r\n        const x = e.clientX - 20;\r\n        const y = e.clientY - 20;\r\n        \r\n        containerElement.style.position = 'absolute';\r\n        containerElement.style.left = `${x}px`;\r\n        containerElement.style.top = `${y}px`;\r\n        \r\n        setActivePiece(containerElement);\r\n        setActiveDrop(parseInt(containerElement.classList[2]));\r\n        let newTotalCoords;\r\n        currSquareElement.current.forEach((square, idx) => {\r\n            if (square === containerElement.parentElement) newTotalCoords = idx;\r\n        });\r\n\r\n        setOldIdx(newTotalCoords);\r\n\r\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\r\n      \r\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\r\n        else {\r\n            setPossibleMoves(currPossibleMoves);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n               \r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n        \r\n            let newPreviewMoves = [];\r\n            currPossibleMoves.forEach((move, idx) => {\r\n                setTimeout(() => {\r\n                    const currSquare = currSquareElement.current[move];\r\n\r\n                    if (currSquare && currSquare.firstChild == null) {\r\n                        const dotElement = document.createElement('div');\r\n                        dotElement.classList.add('possible-move')\r\n\r\n                        currSquare.appendChild(dotElement);\r\n                       \r\n                        newPreviewMoves.push(currSquare);\r\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\r\n                        currSquare.firstChild.firstChild.classList.add('attacked');\r\n                        newPreviewMoves.push(currSquare);\r\n                    }\r\n                }, idx * 0);\r\n            });\r\n\r\n            setPreviewMoves(newPreviewMoves);\r\n        }\r\n       \r\n    };\r\n    \r\n    const movePiece = e => {\r\n        \r\n        if (!activePiece) return;\r\n        const x = e.clientX - 20;\r\n        const y = e.clientY - 20;\r\n        activePiece.style.position = 'absolute';\r\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\r\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\r\n        activePiece.style.zIndex = 3;\r\n\r\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\r\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\r\n        \r\n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\r\n       \r\n    };\r\n    \r\n    const dropPiece = (e, pieceCode) => {\r\n        \r\n        if (!activePiece || !squareRef.current || oldIdx === null) return;\r\n        if (!possibleMoves) return;\r\n        \r\n        \r\n        setActivePiece(null);\r\n       \r\n        const currentX = squareRef.current?.x;\r\n        const currentY = squareRef.current?.y;\r\n        let rocade = false;\r\n        const idx = currentX * 8 + currentY;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n\r\n        const sameIndex = possibleMoves.find(move => {\r\n            if (typeof move === 'object') rocade = move;\r\n            return idx === (typeof move === 'object' ? move.king : move);\r\n        });\r\n\r\n        activePiece.style.left = 'initial';\r\n        activePiece.style.top= 'initial';\r\n        activePiece.position = 'relative';\r\n        activePiece.style.zIndex = 'initial';\r\n        if (currentMove != setColor) return;\r\n        if (players !== 2) return;\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n        const otherBoard = cloneDeep(previewVirtualBoard.current);\r\n        otherBoard[oldX][oldY] = 0;\r\n        otherBoard[currentX][currentY] = pieceCode; \r\n        previewVirtualBoard.current = otherBoard;\r\n      \r\n\r\n        let squaresVirtualBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => squaresVirtualBoard.push(square));\r\n        });\r\n        \r\n        let kingSquare;\r\n\r\n        squaresVirtualBoard.forEach((square, totalIdx) => {\r\n            const iconColor = square && square < 0 ? -1 : 1;\r\n\r\n            const x = parseInt(totalIdx / 8);\r\n            const y = parseInt(totalIdx % 8);\r\n\r\n            if (square === currentMove * 6 && !checkOppositeColor(iconColor, currentMove)) kingSquare = totalIdx;\r\n        });  \r\n\r\n\r\n        const check = checkCheckOptimised(kingSquare, currentMove * 6);\r\n        console.log(check, previewVirtualBoard.current);\r\n\r\n        let sound = \"move\";\r\n\r\n        if (sameIndex !== undefined && !check) {  \r\n\r\n            // Sound of piece moving\r\n            pieceSound.play();\r\n\r\n            const squareDOM = currSquareElement.current[idx];\r\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\r\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\r\n            squareRef.current = null;\r\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\r\n         \r\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\r\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\r\n                // squareDOM.innerHTML = '';\r\n                pieceSound.pause();\r\n                pieceCapture.play();\r\n                sound = \"take\";\r\n            }\r\n            \r\n            let newPiece = pieceCode;\r\n    \r\n\r\n            // Piece being moved to new square\r\n            if ((squareDOM && pieceCode === 1 && currentX === 0) || (squareDOM && pieceCode === -1 && currentX === 7)) {\r\n                \r\n               \r\n                \r\n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\r\n                const leftContainers = containers;  \r\n              \r\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\r\n                    return (\r\n                        <div \r\n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\r\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\r\n                        >\r\n                            <FontAwesomeIcon \r\n                                icon={piece} \r\n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \r\n                                code={pieceCode}\r\n                                \r\n                            />\r\n                        </div>\r\n                    );\r\n                }) : activePiece;\r\n\r\n                setPawnTransform({\r\n                    idx: idx,\r\n                    elements: elements\r\n                });\r\n\r\n            } else { \r\n                setPawnTransform(null);\r\n            }\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\r\n                    move.removeChild(oldPreviewMoves);\r\n                }\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n\r\n            // Checking if it's rocade\r\n\r\n            if (rocade) {\r\n                if (rocade.rocade === 's') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                } else if (rocade.rocade === 'b') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                }\r\n            }\r\n\r\n            if (Math.abs(dropPiecer) === 6) {\r\n                kingsMoved.current[dropPiecer] = true;\r\n                \r\n            } else if (dropPiecer === 2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\r\n              \r\n            } else if (dropPiecer === -2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\r\n            }\r\n   \r\n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\r\n            \r\n            // Checking if it's giving checkmate to the opponent\r\n            let oppositeKingSquare, newBoard = [];\r\n\r\n            cloneVirtualBoard.forEach(row => {\r\n                row.forEach(square => newBoard.push(square));\r\n            });\r\n\r\n            newBoard.forEach((square, totalIdx) => {\r\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\r\n            });\r\n            \r\n            const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\r\n         \r\n            if (checkMateOpponent) setGameRunning(false);\r\n\r\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\r\n            console.log(checkEqual);\r\n            if (checkEqual) setGameRunning(false);\r\n            \r\n            const mirrorOldX = 7 - oldX;\r\n            const mirrorOldY = 7 - oldY;\r\n            const mirrorOldIdx = mirrorOldX * 8 + mirrorOldY;\r\n           \r\n            const mirrorNewX = 7 - currentX;\r\n            const mirrorNewY = 7 - currentY;\r\n            const mirrorNewIdx = mirrorNewX * 8 + mirrorNewY;\r\n            \r\n            setSendPiece(mirrorOldIdx + mirrorNewIdx + pieceCode);\r\n            socket.emit(\"move-piece\", mirrorOldIdx, mirrorNewIdx, pieceCode, sound);\r\n            \r\n            \r\n\r\n            localStorage.setItem(\"online-current-move\", -currentMove);\r\n            \r\n            stopTimer(currentMove === 1 ? true : currentMove === -1 ? false : null);\r\n            setCurrentMove(-currentMove);\r\n\r\n\r\n            localStorage.setItem(\"online-board\", JSON.stringify(cloneVirtualBoard));\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n\r\n            // console.log(checkMateOpponent);\r\n           \r\n            \r\n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\r\n        \r\n    };\r\n\r\n    const getContainers = (elements, piece) => {\r\n\r\n        let currBoard = [];\r\n        console.log(piece);\r\n        newVirtualBoard.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, piece) && square !== 0) return square;\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n\r\n      \r\n\r\n        const result = elements.filter((element, elementIdx) => {\r\n            let count = 0;\r\n            mySquares.forEach(square => {\r\n                if (square - 2 === elementIdx) count++;\r\n            });\r\n\r\n           \r\n\r\n            if (count < 1 && elementIdx === 3) {\r\n                console.log('queen not working')\r\n                return element;\r\n            }\r\n            else if (count < 2 && elementIdx !== 3) return element;\r\n        });\r\n\r\n        return result;\r\n    };\r\n\r\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\r\n\r\n        // Get transformed piece's code\r\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\r\n        const newBoard = cloneDeep(newVirtualBoard);\r\n        const currentX = parseInt(idx / 8);\r\n        const currentY = idx % 8;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n        const totalIdx = currentX * 8 + currentY + + (currentX % 2 !== 0 ? 1 : 0)\r\n        newBoard[currentX][currentY] = transformPieceCode;\r\n        newBoard[oldX][oldY] = 0;\r\n        setNewVirtualBoard(newBoard);\r\n        \r\n        previewVirtualBoard.current = newBoard;\r\n    \r\n        \r\n        setPawnTransform({\r\n            idx: idx,\r\n            piece: transformPieceCode,\r\n            elements: []\r\n        });\r\n\r\n        localStorage.setItem(\"online-board\", JSON.stringify(newBoard));\r\n    };\r\n\r\n    const checkOppositeColor = (piece1, piece2) => {\r\n        if (piece1 < 0 && piece2 > 0) return true;\r\n        else if (piece1 > 0 && piece2 < 0) return true;\r\n        return false;\r\n    }\r\n\r\n    const checkCheck = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        // console.log('lalalalaalaallapgdkkdfpgogjodjfgjdp', previewVirtualBoard.current, kingSquare);\r\n        let currBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => {\r\n                currBoard.push(square);\r\n            });\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, idx) => {\r\n            if (checkOppositeColor(kCode, square)) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            };\r\n        });\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        // Checking if king is attacked\r\n\r\n        const check = oppositeSquares.some(square => {\r\n         \r\n            const possibleMovesCheck = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n          \r\n            return possibleMovesCheck.some(currSquare => {\r\n               \r\n                return currSquare === kingSquare;\r\n            });\r\n        });\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        if (check && !isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n\r\n        return check;\r\n    };\r\n\r\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        // Getting coords\r\n        const currentX = parseInt(kingSquare / 8);\r\n        const currentY = kingSquare % 8;\r\n        const pieceCode = kCode / (-6);\r\n\r\n        let check = false;\r\n\r\n        const kingPossibleSquares = [\r\n            [currentX - 1, currentY - 1],\r\n            [currentX - 1, currentY],\r\n            [currentX - 1, currentY + 1],\r\n            [currentX, currentY - 1],\r\n            [currentX, currentY + 1],\r\n            [currentX + 1, currentY - 1],\r\n            [currentX + 1, currentY],\r\n            [currentX + 1, currentY + 1]\r\n        ];\r\n\r\n        console.log(previewVirtualBoard.current, pieceCode);\r\n\r\n        kingPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === -kCode && square !== null) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        // Pawns \r\n\r\n        const pawnPossibleSquares = [\r\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\r\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\r\n        ];\r\n        \r\n        console.log(pawnPossibleSquares);\r\n\r\n        pawnPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                console.log('check');\r\n                check = true;\r\n            }\r\n        });\r\n        \r\n        // Rows\r\n\r\n        if (currentX > 0) {\r\n            for (let i = currentX - 1; i >= 0; i--) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentX < ROWS - 1) {\r\n            for (let i = currentX + 1; i < ROWS; i++) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n\r\n                console.log(rowSquare, pieceCode, previewVirtualBoard.current);\r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare * pieceCode === 5) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) {\r\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\r\n                        console.log(checkMate);\r\n                    }\r\n                    console.log(\"here in if\")\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Columns \r\n\r\n        if (currentY > 0) {\r\n            for (let i = currentY - 1; i >= 0; i--) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentY < COLUMNS - 1) {\r\n            for (let i = currentX + 1; i < COLUMNS; i++) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top left\r\n        \r\n        if (currentX > 0 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top right\r\n\r\n        if (currentX > 0 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom left\r\n\r\n        if (currentX < ROWS - 1 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom right\r\n\r\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Knight moves\r\n\r\n        const knightPossibleMoves = [\r\n            [currentX - 2, currentY - 1],\r\n            [currentX - 2, currentY + 1],\r\n            [currentX + 2, currentY - 1],\r\n            [currentX + 2, currentY + 1],\r\n            [currentX - 1, currentY - 2],\r\n            [currentX - 1, currentY + 2],\r\n            [currentX + 1, currentY - 2],\r\n            [currentX + 1, currentY + 2]\r\n        ];\r\n\r\n        \r\n        \r\n        knightPossibleMoves.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode * 3) { \r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        return check;\r\n    };\r\n\r\n    const legalBoard = (board, kCode) => {\r\n        return board.some(row => {\r\n            return row.some(cell => cell === kCode);\r\n        });\r\n    };\r\n\r\n    // Checking the check-mate\r\n\r\n    const checkCheckmate = (kCode, board) => {\r\n\r\n        console.log(board);\r\n        const constantBoard = board;\r\n        let currBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            }\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n        console.log(mySquares);\r\n        let checkMate = true;\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        mySquares.forEach(square => {\r\n\r\n            // Next possible moves to check if it's checkmate\r\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            console.log(possibleMovesCheckmate);\r\n\r\n            possibleMovesCheckmate.forEach(move => {\r\n                const currX = parseInt(square.coords / 8);\r\n                const currY = square.coords % 8;\r\n                const newX = parseInt(move / 8);\r\n                const newY = move % 8;\r\n                const newBoard = cloneDeep(constantBoard);\r\n\r\n                newBoard[currX][currY] = 0;\r\n                \r\n                if (newBoard != null && (newBoard[newX] != null) && (newBoard[newX][newY] != null)) {\r\n                    if (newBoard[newX][newY] !== 0) {\r\n                        const enemyPieceNumber = newBoard[newX][newY];\r\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\r\n                    } else newBoard[newX][newY] = square.pieceCode;\r\n                }\r\n\r\n                \r\n                previewVirtualBoard.current = cloneDeep(newBoard);\r\n\r\n                let allInOneBoard = [];\r\n\r\n                previewVirtualBoard.current.forEach(row => {\r\n                    row.forEach(square => allInOneBoard.push(square));\r\n                });\r\n\r\n\r\n\r\n                console.log(newBoard, kCode);\r\n\r\n                console.log(allInOneBoard);\r\n\r\n                let kingSquare = -1;\r\n\r\n                allInOneBoard.forEach((square, idx) => {\r\n                    if (square === kCode) kingSquare = idx;\r\n                });\r\n\r\n\r\n                console.log(kingSquare);\r\n\r\n                const possibleBoard = legalBoard(newBoard, kCode);\r\n                \r\n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\r\n                console.log(newBoardCheck, kingSquare, kCode);\r\n                if (!newBoardCheck && possibleBoard) checkMate = false;\r\n                \r\n            });\r\n        });\r\n        \r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n        if (checkMate) setGameRunning(false);\r\n        return checkMate;\r\n        \r\n    };\r\n\r\n    const checkPat = (pieceCode, board) => {\r\n        let currBoard = [];\r\n       \r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\r\n            if (checkOppositeColor(pieceCode, square)) return {\r\n                pieceCode: square,\r\n                coords: coords\r\n            };\r\n        });\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        return oppositeSquares.every(square => {\r\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\r\n         \r\n            return oppPossibleMoves.length === 0;\r\n        });\r\n    };\r\n\r\n\r\n    const addSquares = () => {\r\n        let squareComponents = [];\r\n\r\n        const board = newVirtualBoard.map((row, rowIdx) => {\r\n\r\n\r\n            const rows = row.map((square, squareIdx) => {\r\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\r\n                const realIdx = rowIdx * 8 + squareIdx;\r\n               \r\n                const squareComponent = \r\n                    <div className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} key={squareIdx} ref={ref => { \r\n                        currSquareElement.current[realIdx] = ref;\r\n                    }}>\r\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\r\n                            pawnTransform.elements.length > 0 ? (<div \r\n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                key={totalIdx}\r\n                            >   \r\n                                {pawnTransform.elements}  \r\n                            </div>)\r\n                            : (\r\n                                <div \r\n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\r\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\r\n                                    onMouseMove={e => movePiece(e)}\r\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \r\n                                    key={totalIdx}\r\n                                >   \r\n                                    <FontAwesomeIcon \r\n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \r\n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \r\n                                        code={pawnTransform.piece}\r\n                                    />\r\n                                </div>\r\n                            )\r\n                        ) : square !== 0 ? (\r\n                            <div \r\n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\r\n                                onMouseMove={e => movePiece(e)}\r\n                                onMouseUp={e => dropPiece(e, square)} \r\n                                key={totalIdx}\r\n                            >   \r\n                                <FontAwesomeIcon \r\n                                    icon={piecesCode[Math.abs(square).toString()]} \r\n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \r\n                                    code={square}\r\n                                />\r\n                            </div>\r\n                        ) : \"\"}\r\n                    </div>;\r\n\r\n                return squareComponent;\r\n            });\r\n            return (\r\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\r\n                    {rows}\r\n                </div>\r\n            );\r\n        });\r\n\r\n        squareElements.current = squareComponents;\r\n\r\n        return board;\r\n    };\r\n\r\n    const addLetters = () => {\r\n        const letterComponent = parseInt(setColor) === 1 ? (\r\n            <div className=\"letters\"> \r\n                <p>A</p> \r\n                <p>B</p> \r\n                <p>C</p> \r\n                <p>D</p> \r\n                <p>E</p> \r\n                <p>F</p> \r\n                <p>G</p> \r\n                <p>H</p> \r\n            </div>\r\n        ) : (\r\n            <div className=\"letters\"> \r\n                <p>H</p> \r\n                <p>G</p> \r\n                <p>F</p> \r\n                <p>E</p> \r\n                <p>D</p> \r\n                <p>C</p> \r\n                <p>B</p> \r\n                <p>A</p> \r\n            </div>\r\n        );\r\n\r\n        return letterComponent;\r\n    };\r\n\r\n    \r\n    useEffect(() => {\r\n        socket.on('send-piece', (oldIdx, newIdx, pieceCode, sound) => {\r\n            const iconContainerElement = currSquareElement.current[oldIdx].firstChild;\r\n            console.log('use effect', newVirtualBoard, sendPiece);\r\n            const cloneVirtualBoard = cloneDeep(newVirtualBoard);\r\n            const serverOldX = parseInt(oldIdx / 8);\r\n            const serverOldY = oldIdx % 8;\r\n            cloneVirtualBoard[serverOldX][serverOldY] = 0;\r\n            const serverNewX = parseInt(newIdx / 8);\r\n            const serverNewY = newIdx % 8;\r\n            cloneVirtualBoard[serverNewX][serverNewY] = pieceCode;\r\n            stopTimer(pieceCode < 0 ? false : true);\r\n            pieceSound.pause();\r\n            pieceCapture.pause();\r\n            pieceSound.currentTime = 0;\r\n            pieceCapture.currentTime = 0;\r\n            iconContainerElement.classList.add('opponent');\r\n            iconContainerElement.style.setProperty(\"--element-left\", `${(serverNewY - serverOldY) * 100}px`);\r\n            iconContainerElement.style.setProperty(\"--element-top\", `${(serverNewX - serverOldX) * 100}px`)\r\n            iconContainerElement.classList.add('changed-move');\r\n\r\n            previewVirtualBoard.current = cloneDeep(cloneVirtualBoard);\r\n\r\n\r\n            iconContainerElement.addEventListener(\"transitionend\", () => {\r\n                if (sound === \"move\") pieceSound.play();\r\n                else pieceCapture.play();\r\n                iconContainerElement.style.zIndex = 'initial';\r\n                iconContainerElement.style.position = 'initial';\r\n                iconContainerElement.style.left = `initial`;\r\n                iconContainerElement.style.top = `initial`;\r\n                iconContainerElement.style.transform = 'initial';\r\n                localStorage.setItem(\"online-current-move\", -currentMove);\r\n                setCurrentMove(-currentMove);\r\n                localStorage.setItem(\"online-board\", JSON.stringify(cloneVirtualBoard));\r\n                setNewVirtualBoard(cloneVirtualBoard);      \r\n            });\r\n        });\r\n        \r\n    }, [sendPiece]);\r\n\r\n    return (\r\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\r\n            {addSquares()}\r\n            {addLetters()}\r\n        </div>\r\n    );\r\n};\r\n","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\PracticeBoard.jsx",["148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175"],"import React, { useState, useEffect, useRef } from \"react\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faChessPawn, faChessKnight, faChessRook, faChessBishop, faChessKing, faChessQueen } from '@fortawesome/free-solid-svg-icons';\r\nimport cloneDeep from 'lodash/cloneDeep';\r\nimport { isArray } from \"lodash\";\r\nimport pieceMoveSound from \"../sounds/piece-move.wav\";\r\nimport pieceCaptureSound from \"../sounds/piece-taken.mp3\";\r\n\r\nimport '../styles/board.css';\r\nimport \"../styles/practice.css\";\r\n\r\nconst HEIGHT = 85 * window.innerHeight / 100;\r\nconst ROWS = 8;\r\nconst COLUMNS = 8;\r\n\r\nexport default function PracticeBoard({ color, prevButtons, random, difficulty, choosePiece, deleteIcon }) {\r\n\r\n    const setColor = localStorage.getItem(\"set-color\") ? parseInt(localStorage.getItem(\"set-color\")) : color;\r\n    localStorage.setItem(\"set-color\", setColor);\r\n    const currDifficulty = localStorage.getItem(\"practice-difficulty\") !== null ? difficulty : JSON.parse(localStorage.getItem(\"practice-difficulty\"));\r\n    localStorage.setItem(\"practice-difficulty\", JSON.stringify(difficulty));\r\n\r\n    const createVirtualBoard = () => {\r\n        let board = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            let row = [];\r\n\r\n            for (let j = 0; j < 8; j++)\r\n                row.push(0);\r\n                \r\n            board.push(row);\r\n        }\r\n\r\n        return board;\r\n    };\r\n\r\n    const boardRef = useRef(null);\r\n    const squareRef = useRef(null);\r\n    \r\n    const [currentMove, setCurrentMove] = useState(localStorage.getItem(\"practice-current-move\") === null ? 1 : localStorage.getItem(\"practice-current-move\"));\r\n    const [oldIdx, setOldIdx] = useState(null);\r\n    const [possibleMoves, setPossibleMoves] = useState(null);\r\n    const [activePiece, setActivePiece] = useState(null);\r\n    const [dropPiecer, setActiveDrop] = useState(null);\r\n    const [virtualBoard, setVirtualBoard] = useState(localStorage.getItem(\"practice-board\") === null ? createVirtualBoard() : JSON.parse(localStorage.getItem(\"practice-board\")));\r\n    const [newVirtualBoard, setNewVirtualBoard] = useState(virtualBoard);\r\n    const [previewMoves, setPreviewMoves] = useState([]);\r\n    const [gameRunning, setGameRunning] = useState(true);\r\n    const [pawnTransform, setPawnTransform] = useState(null);\r\n    const [prevMoves, setPrevMoves] = useState(localStorage.getItem(\"practice-prev-moves\") !== null ? JSON.parse(localStorage.getItem(\"practice-prev-moves\")) : []);\r\n    const [nextMoves, setNextMoves] = useState(localStorage.getItem(\"practice-next-moves\") !== null ? JSON.parse(localStorage.getItem(\"practice-next-moves\")) : []);\r\n\r\n    const previewVirtualBoard = useRef(virtualBoard);\r\n    const squareElements = useRef(null);\r\n    const currSquareElement = useRef([]);\r\n    const kingsMoved = useRef({\"6\": false, \"-6\": false});\r\n    const rookMoved = useRef({\r\n        \"2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        },\r\n\r\n        \"-2\": {\r\n            \"left\": false,\r\n            \"right\": false\r\n        }\r\n    });\r\n\r\n    const piecesCode = {\r\n        1: faChessPawn,\r\n        2: faChessRook,\r\n        3: faChessKnight,\r\n        4: faChessBishop,\r\n        5: faChessQueen,\r\n        6: faChessKing\r\n    };\r\n\r\n    console.log(virtualBoard);\r\n\r\n    const pieceSound = new Audio(pieceMoveSound);\r\n    const pieceCapture = new Audio(pieceCaptureSound);\r\n    pieceCapture.volume = 0.3;\r\n\r\n    const minX = boardRef.current?.offsetLeft;\r\n    const maxX = boardRef.current?.offsetLeft + boardRef.current?.offsetWidth - 25;\r\n\r\n    const minY = boardRef.current?.offsetTop;\r\n    const maxY = boardRef.current?.offsetTop + boardRef.current?.offsetHeight - 50;\r\n\r\n    const squareWidth = parseInt(boardRef.current?.style.width) / 8;\r\n    const squareHeight = parseInt(boardRef.current?.style.height) / 8;\r\n\r\n    console.log(squareWidth, squareHeight);\r\n    const player2Color = virtualBoard[0][0] > 0 ? \"white\" : \"black\";\r\n    const player1Color = player2Color === \"white\" ? \"black\" : \"white\";\r\n\r\n    // Checking everytime prev/next button is pressed\r\n    \r\n    useEffect(() => {\r\n       \r\n        if (!prevButtons) return;\r\n        if (prevButtons.classList.contains('prev-button') && prevMoves.length === 0) return;\r\n        if (prevButtons.classList.contains('next-button') && nextMoves.length === 0) return;\r\n        \r\n        const lastMove = prevButtons.classList.contains('prev-button') ? prevMoves[prevMoves.length - 1] : nextMoves[nextMoves.length - 1];\r\n        console.log(prevButtons, prevMoves, lastMove.pieceCode);\r\n        const currBoard = cloneDeep(newVirtualBoard);\r\n        const oldX = parseInt(lastMove.oldIdx / 8);\r\n        const oldY = lastMove.oldIdx % 8;\r\n        const newX = parseInt(lastMove.newIdx / 8);\r\n        const newY = lastMove.newIdx % 8;\r\n        currBoard[oldX][oldY] = prevButtons.classList.contains('prev-button') ? lastMove.pieceCode : 0;\r\n        currBoard[newX][newY] = lastMove.oldPieceCode;\r\n    \r\n        setNewVirtualBoard(currBoard);\r\n\r\n        if (prevButtons.classList.contains('prev-button')) {\r\n            const newNextMoves = [...nextMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n            localStorage.setItem(\"practice-prev-moves\", JSON.stringify(prevMoves.slice(0, -1)));\r\n            localStorage.setItem(\"practice-next-moves\", JSON.stringify(newNextMoves));\r\n\r\n            setPrevMoves(prevMoves.slice(0, -1));\r\n            setNextMoves(newNextMoves);\r\n\r\n        } else  {\r\n            console.log('ok from here');\r\n            const newPrevMoves = [...prevMoves,\r\n                {\r\n                    oldIdx: lastMove.oldIdx,\r\n                    newIdx: lastMove.newIdx,\r\n                    oldPieceCode: lastMove.pieceCode,\r\n                    pieceCode: lastMove.oldPieceCode\r\n                }\r\n            ];\r\n\r\n            localStorage.setItem(\"practice-prev-moves\", JSON.stringify(newPrevMoves));\r\n            localStorage.setItem(\"practice-next-moves\", JSON.stringify(nextMoves.slice(0, -1)));\r\n        \r\n            setNextMoves(nextMoves.slice(0, -1));\r\n            setPrevMoves(newPrevMoves);\r\n        }\r\n\r\n        localStorage.setItem(\"practice-current-move\", -currentMove);\r\n        localStorage.setItem(\"practice-board\", JSON.stringify(currBoard));\r\n        \r\n        setCurrentMove(-currentMove);\r\n\r\n    }, [random]);\r\n\r\n    useEffect(() => {\r\n        if (typeof choosePiece !== \"number\") return;\r\n        let idx;\r\n        currSquareElement.current.forEach((square, squareIdx) => square.classList.contains('selected') ? idx = squareIdx : null);\r\n        if (!idx) return;\r\n        let cloneBoard = cloneDeep(newVirtualBoard);\r\n        cloneBoard[parseInt(idx / 8)][idx % 8] = choosePiece;\r\n        setNewVirtualBoard(cloneBoard);\r\n        previewVirtualBoard.current = cloneBoard;\r\n        console.log(cloneBoard);\r\n\r\n    }, [choosePiece]);\r\n\r\n    useEffect(() => {\r\n        if (deleteIcon === null) return;\r\n    \r\n        let idx;\r\n        currSquareElement.current.forEach((square, squareIdx) => square.classList.contains('selected') ? idx = squareIdx : null);\r\n        if (!idx) return;\r\n\r\n        let cloneBoard = cloneDeep(newVirtualBoard);\r\n        cloneBoard[parseInt(idx / 8)][idx % 8] = 0;\r\n        setNewVirtualBoard(cloneBoard);\r\n        previewVirtualBoard.current = cloneBoard;\r\n\r\n    }, [deleteIcon]);\r\n\r\n    const selectSquare = (square) => {\r\n        const currSelected = currSquareElement.current.find(squareElement => squareElement.classList.contains('selected'));\r\n        currSelected && currSelected.classList.remove('selected');\r\n        currSquareElement.current.forEach(currSquare => currSquare.classList.remove('selected'));\r\n        if (square !== currSelected)  square.classList.add('selected');\r\n    }\r\n\r\n    const isKing = (piece) => {\r\n        \r\n    }\r\n\r\n\r\n    // Function for checking the check \r\n\r\n    const getPossibleMoves = (pieceCode, coords, board) => {\r\n        const piece = Math.abs(pieceCode);\r\n        let possibleMoves = [];\r\n\r\n        // Current coordonates\r\n        const currentX = parseInt(coords / 8);\r\n        const currentY = coords % 8; \r\n\r\n        console.log(currentX, currentY);\r\n\r\n        // Code for pawn\r\n        if (piece === 1) {\r\n\r\n            // Coordonates for possible moves\r\n            const newDiagX = currentX - (pieceCode * setColor);\r\n            const newDiagY = currentY + (pieceCode * setColor);\r\n            const newDiagY2 = currentY - (pieceCode * setColor);\r\n            \r\n            const newCoords = newDiagX * 8 + newDiagY;\r\n            const newCoords2 = newDiagX * 8 + newDiagY2;\r\n            const newFrontCoords = newDiagX * 8 + currentY;\r\n            const frontElement = board[newDiagX] &&\r\n                                 board[newDiagX][currentY] &&\r\n                                 board[newDiagX][currentY];\r\n\r\n            console.log(frontElement);\r\n\r\n            if (frontElement === 0) possibleMoves.push(newFrontCoords);\r\n\r\n            console.log(possibleMoves);\r\n            \r\n            const diagonalElement = board[newDiagX] &&\r\n                                    board[newDiagX][newDiagY] &&\r\n                                    board[newDiagX][newDiagY];\r\n\r\n            const diagonalElement2 = board[newDiagX] &&\r\n                                     board[newDiagX][newDiagY2] &&\r\n                                     board[newDiagX][newDiagY2];\r\n            \r\n            if ((pieceCode * setColor < 0 && currentX === 1) || (pieceCode * setColor > 0 && currentX === 6)) {\r\n                const newFrontX = currentX - (pieceCode * 2 * setColor);\r\n                console.log(newFrontX);\r\n                const newFrontCoords = newFrontX * 8 + currentY;\r\n\r\n                const newCoordsSquare = board[newFrontX][currentY];\r\n                if (newCoordsSquare === 0 && frontElement === 0) possibleMoves.push(newFrontCoords);\r\n            }\r\n\r\n            if (diagonalElement2 !== 0) {\r\n                if (checkOppositeColor(pieceCode, diagonalElement2)) possibleMoves.push(newCoords2);\r\n            }\r\n           \r\n            if (diagonalElement === 0) return possibleMoves;\r\n            if (checkOppositeColor(pieceCode, diagonalElement)) possibleMoves.push(newCoords);\r\n\r\n        } else if (piece === 2) {\r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    \r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);    \r\n \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                             break;\r\n                        } else possibleMoves.push(newCoords);    \r\n\r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                                           \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n                        \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 3) {\r\n\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX - 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 2,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 2\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 2\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    }\r\n                    else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n        } else if (piece === 4) {\r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n  \r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined && newX >= 0 && newY >= 0 && newX < 8 && newY < 8) {\r\n                       \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            console.log(possibleMoves, newSquare, board, newX, newY);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, newCoords);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 5) {\r\n            console.log(board); \r\n\r\n            if (currentY > 1) {\r\n                for (let i = currentY - 1; i >= 0; i--) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);   \r\n                                         \r\n                        console.log('empty text just for fun', newSquare);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentY < 7) {\r\n                for (let i = currentY + 1; i < 8; i++) {\r\n                    const newCoords = currentX * 8 + i;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {   \r\n\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX > 1) {\r\n                for (let i = currentX - 1; i >= 0; i--) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            console.log(board, board[newX][newY], pieceCode, newCoords);\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newCoords, possibleMoves);\r\n                    }   \r\n                }\r\n            }\r\n\r\n            if (currentX < 7) {\r\n                for (let i = currentX + 1; i < 8; i++) {\r\n                    const newCoords = i * 8 + currentY;\r\n                    const newX = parseInt(newCoords / 8);\r\n                    const newY = parseInt(newCoords % 8);\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n        \r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            }\r\n            \r\n            if (currentX >= 1 && currentY >= 1) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY, pieceCode);\r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX >= 1 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX - i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                    console.log(newSquare, newX, newY);\r\n                    if (newSquare !== undefined) {\r\n                        \r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            } \r\n\r\n            if (currentX <= 7 && currentY >= 0) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY - i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n        \r\n                    if (newSquare !== undefined) {\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentX <= 7 && currentY <= 7) {\r\n                for (let i = 1; i < 8; i++) {\r\n                    const newX = currentX + i;\r\n                    const newY = currentY + i;\r\n                    const newCoords = newX * 8 + newY;\r\n                    const newSquare = board[newX] &&\r\n                                      board[newX][newY] &&\r\n                                      board[newX][newY];\r\n                   \r\n                    if (newSquare !== undefined) {\r\n                        console.log(newX, newY);\r\n                        if (newSquare !== 0) {\r\n                            if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                            break;\r\n                        } else possibleMoves.push(newCoords);\r\n\r\n                        console.log('empty text just for fun', newSquare, possibleMoves);\r\n                    }\r\n\r\n                }\r\n            } \r\n        } else if (piece === 6) {\r\n            const pieceMoves = [\r\n                {\r\n                    x: currentX,\r\n                    y: currentY - 1\r\n                },\r\n                \r\n                {\r\n                    x: currentX,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY \r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX - 1,\r\n                    y: currentY + 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY - 1\r\n                },\r\n\r\n                {\r\n                    x: currentX + 1,\r\n                    y: currentY + 1\r\n                }\r\n            ];\r\n\r\n            pieceMoves.forEach(pieceMove => {\r\n                const newCoords = pieceMove.x * 8 + pieceMove.y;\r\n                const newSquare = board[pieceMove.x] &&\r\n                                  board[pieceMove.x][pieceMove.y] &&\r\n                                  board[pieceMove.x][pieceMove.y];\r\n                if (newSquare !== undefined && pieceMove.x >= 0 && pieceMove.y >= 0 && pieceMove.x < 8 && pieceMove.y < 8) {\r\n                    if (newSquare !== 0) {\r\n                        if (checkOppositeColor(pieceCode, newSquare)) possibleMoves.push(newCoords);\r\n                    } else possibleMoves.push(newCoords);\r\n\r\n                    console.log(newSquare, pieceMove.x, pieceMove.y)\r\n                }\r\n            });\r\n\r\n            // Movement for rocade\r\n            console.log(kingsMoved.current[pieceCode]);\r\n            if (!kingsMoved.current[pieceCode]) {\r\n                console.log('rocade', rookMoved);\r\n                const smallRocadeCoords = currentX * 8 + currentY + 2;\r\n                const bigRocadeCoords = currentX * 8 + currentY - 3;\r\n                const smallRocadeRookCoords = pieceCode < 0 ? 5 : 61;\r\n                const bigRocadeRookCoords = pieceCode < 0 ? 2 : 58;\r\n\r\n                const smallRocadeSquare = board[currentX] &&\r\n                                          board[currentX][currentY + 2] &&\r\n                                          board[currentX][currentY + 2];\r\n\r\n                const bigRocadeSquare = board[currentX] &&\r\n                                        board[currentX][currentY - 3] &&\r\n                                        board[currentX][currentY - 3];\r\n\r\n                let smallRocadeEmpty = true, bigRocadeEmpty = true;\r\n\r\n                // Checking if the squares between king and rook are empty \r\n                for (let i = coords + 1; i <= smallRocadeCoords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                   \r\n                    if (board[rocadeX][rocadeY] !== 0) smallRocadeEmpty = false;\r\n                } \r\n\r\n                for (let i = bigRocadeCoords; i < coords; i++) {\r\n                    const rocadeX = parseInt(i / 8);\r\n                    const rocadeY = i % 8;\r\n                    console.log('gdjigdfjhh');\r\n                    if (board[rocadeX][rocadeY] !== 0) bigRocadeEmpty = false;\r\n                } \r\n\r\n                console.log(smallRocadeEmpty, bigRocadeEmpty)\r\n\r\n                if (smallRocadeSquare !== undefined && smallRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"right\"]) {\r\n                    possibleMoves.push({\r\n                        king: smallRocadeCoords,\r\n                        rook: smallRocadeRookCoords,\r\n                        rocade: \"s\"\r\n                    });\r\n                } \r\n\r\n                if (bigRocadeSquare !== undefined && bigRocadeEmpty && !rookMoved.current[pieceCode < 0 ? \"-2\" : \"2\"][\"left\"]) {\r\n                    possibleMoves.push({\r\n                        king: bigRocadeCoords,\r\n                        rook: bigRocadeRookCoords,\r\n                        rocade: \"b\"\r\n                    });\r\n                }\r\n\r\n                \r\n\r\n                // possibleMoves.push(smallRocade);\r\n                // possibleMoves.push(bigRocade);\r\n            }\r\n        }\r\n      \r\n        return possibleMoves;\r\n    };\r\n\r\n    const dragPiece = (e, square) => {\r\n        \r\n        if (!gameRunning) return;\r\n        if (pawnTransform && pawnTransform?.elements.length > 1) return;\r\n\r\n        const element = e.target.classList.contains('piece') ? e.target : e.target.parentElement;\r\n        const containerElement = element.parentElement;\r\n        console.log(containerElement, square);\r\n        const x = e.clientX - 20;\r\n        const y = e.clientY - 20;\r\n        console.log(x, y, square, currentMove);\r\n        containerElement.style.position = 'absolute';\r\n        containerElement.style.left = `${x}px`;\r\n        containerElement.style.top = `${y}px`;\r\n\r\n        \r\n        \r\n        setActivePiece(containerElement);\r\n        setActiveDrop(parseInt(containerElement.classList[2]));\r\n        let newTotalCoords;\r\n        currSquareElement.current.forEach((square, idx) => {\r\n            if (square === containerElement.parentElement) newTotalCoords = idx;\r\n        });\r\n\r\n        setOldIdx(newTotalCoords);\r\n\r\n        const currPossibleMoves = getPossibleMoves(square, newTotalCoords, newVirtualBoard);\r\n        console.log(currPossibleMoves, newVirtualBoard, square, currentMove, newTotalCoords);\r\n        if (checkOppositeColor(square, currentMove)) setPossibleMoves([]);\r\n        else {\r\n            setPossibleMoves(currPossibleMoves);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                console.log(move, oldPreviewMoves);\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container')) move.removeChild(oldPreviewMoves);\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n        \r\n            let newPreviewMoves = [];\r\n            currPossibleMoves.forEach((move, idx) => {\r\n                setTimeout(() => {\r\n                    const currSquare = currSquareElement.current[move];\r\n\r\n                    if (currSquare && currSquare.firstChild == null) {\r\n                        const dotElement = document.createElement('div');\r\n                        dotElement.classList.add('possible-move')\r\n\r\n                        currSquare.appendChild(dotElement);\r\n                        console.log(currSquare);\r\n                        newPreviewMoves.push(currSquare);\r\n                    } else if (currSquare && currSquare.firstChild.firstChild !== null) {\r\n                        currSquare.firstChild.firstChild.classList.add('attacked');\r\n                        newPreviewMoves.push(currSquare);\r\n                    }\r\n                }, idx * 0);\r\n            });\r\n\r\n            setPreviewMoves(newPreviewMoves);\r\n        }\r\n       \r\n    };\r\n    \r\n    const movePiece = e => {\r\n        \r\n        if (!activePiece) return;\r\n        const x = e.clientX - 15;\r\n        const y = e.clientY - 15;\r\n        activePiece.style.position = 'absolute';\r\n        activePiece.style.left = `${x > maxX ? maxX : x < minX ? minX : x}px`;\r\n        activePiece.style.top = `${y > maxY ? maxY : y < minY ? minY : y}px`;\r\n        activePiece.style.zIndex = 3;\r\n\r\n        const ySquare = (parseInt(activePiece.style.left) - boardRef.current?.offsetLeft) / squareWidth;\r\n        const xSquare = (parseInt(activePiece.style.top) - boardRef.current?.offsetTop) / squareHeight;\r\n        \r\n        squareRef.current = {x: Math.round(xSquare), y: Math.round(ySquare)};\r\n        console.log(squareRef.current);\r\n    };\r\n    \r\n    const dropPiece = (e, pieceCode) => {\r\n        \r\n        if (!activePiece || !squareRef.current || oldIdx === null) return;\r\n        if (!possibleMoves) return;\r\n        setActivePiece(null);\r\n        console.log(squareRef.current?.x, squareRef.current?.y)\r\n        const currentX = squareRef.current?.x;\r\n        const currentY = squareRef.current?.y;\r\n        let rocade = false;\r\n        const idx = currentX * 8 + currentY;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n\r\n        const sameIndex = possibleMoves.find(move => {\r\n            if (typeof move === 'object') rocade = move;\r\n            return idx === (typeof move === 'object' ? move.king : move);\r\n        });\r\n\r\n        activePiece.style.left = 'initial';\r\n        activePiece.style.top= 'initial';\r\n        activePiece.position = 'relative';\r\n        activePiece.style.zIndex = 'initial';\r\n        console.log(previewVirtualBoard.current);\r\n\r\n        if (setColor != currentMove) {\r\n            console.log('here', setColor, currentMove);\r\n            return;\r\n        }\r\n\r\n        const oldBoard = cloneDeep(newVirtualBoard);\r\n        const otherBoard = cloneDeep(newVirtualBoard);\r\n        otherBoard[oldX][oldY] = 0;\r\n        otherBoard[currentX][currentY] = pieceCode; \r\n        previewVirtualBoard.current = otherBoard;\r\n        console.log('afdsokogjfdjjhihijhpjhijhipfghjpifjhpgjhpijhpfgjh', previewVirtualBoard.current);\r\n\r\n        let squaresVirtualBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => {\r\n                squaresVirtualBoard.push(square);\r\n            });\r\n        });\r\n\r\n        const kingPiece = squaresVirtualBoard.some(piece => {\r\n            if (pieceCode < 0) return piece === -6;\r\n            else return piece === 6;\r\n        });\r\n\r\n        const opponentKingPiece = squaresVirtualBoard.some(piece => {\r\n            if (pieceCode < 0) return piece === 6;\r\n            else return piece === -6;\r\n        \r\n        });\r\n\r\n        if (!kingPiece || !opponentKingPiece) return;\r\n        \r\n        let kingSquare;\r\n\r\n        squaresVirtualBoard.forEach((square, totalIdx) => {\r\n            const iconColor = square && square < 0 ? -1 : 1;\r\n\r\n            const x = parseInt(totalIdx / 8);\r\n            const y = parseInt(totalIdx % 8);\r\n\r\n            if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) kingSquare = totalIdx;\r\n        });  \r\n\r\n        console.log(kingSquare, currentMove,  previewVirtualBoard.current);\r\n        const check = checkCheckOptimised(kingSquare, setColor * 6);\r\n        console.log(check);\r\n\r\n        if (sameIndex !== undefined && !check) {  \r\n\r\n            // Sound of piece moving\r\n            pieceSound.play();\r\n\r\n            const squareDOM = currSquareElement.current[idx];\r\n            const squarePiece = squareDOM && squareDOM.querySelector('[code]');\r\n            const dropPieceCode = squarePiece && squarePiece.getAttribute('code');\r\n            squareRef.current = null;\r\n            const cloneIcon = squareDOM && squareDOM.firstChild && squareDOM.firstChild.classList.contains('icon-container') ?  squareDOM.firstChild.cloneNode(true) : null;\r\n            console.log(cloneIcon, prevMoves);\r\n            if (dropPieceCode && !checkOppositeColor(pieceCode, dropPieceCode)) return;\r\n            else if (dropPieceCode && checkOppositeColor(pieceCode, dropPieceCode) && ((pieceCode !== 1 || currentX !== 0) && (squareDOM && pieceCode !== -1 || currentX !== 7))) {\r\n                // squareDOM.innerHTML = '';\r\n                pieceSound.pause();\r\n                pieceCapture.play();\r\n            }\r\n            \r\n            let newPiece = pieceCode;\r\n            let skipComputerMove = false;\r\n\r\n            // Piece being moved to new square\r\n            if ((squareDOM && pieceCode === 1 && currentX === 0 && setColor === 1) || (squareDOM && pieceCode === -1 && currentX === 7 && setColor === 1) || (squareDOM && pieceCode === 1 && currentX === 7 && setColor === -1) || (squareDOM && pieceCode === -1 && currentX === 0 && setColor === -1)) {\r\n                \r\n                console.log('here'); \r\n                \r\n                const containers = [faChessRook, faChessKnight, faChessBishop, faChessQueen];\r\n                const leftContainers = containers;  \r\n                console.log(leftContainers);\r\n                const elements = leftContainers.length >= 1 ? leftContainers.map(piece => {\r\n                    return (\r\n                        <div \r\n                            className={`mini-icon-container ${pieceCode < 0 ? -1 : 1} ${pieceCode}`}\r\n                            onClick={(e) => pawnTransformPiece(piece, idx, oldIdx)}\r\n                        >\r\n                            <FontAwesomeIcon \r\n                                icon={piece} \r\n                                className={`mini-piece ${pieceCode < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                color={pieceCode > 0 ? \"#fff\" : \"#000\"} \r\n                                code={pieceCode}\r\n                                \r\n                            />\r\n                        </div>\r\n                    );\r\n                }) : activePiece;\r\n\r\n                setPawnTransform({\r\n                    idx: idx,\r\n                    elements: elements\r\n                });\r\n\r\n                skipComputerMove = true;\r\n\r\n            } else setPawnTransform(null);\r\n\r\n            setPrevMoves([...prevMoves, \r\n                {\r\n                    oldIdx: oldIdx, \r\n                    newIdx: idx, \r\n                    pieceCode: pieceCode,\r\n                    oldPieceCode: newVirtualBoard[currentX][currentY],\r\n                }\r\n            ]);\r\n\r\n            setNextMoves([]);\r\n\r\n            // Removing old preview dots\r\n            previewMoves && previewMoves.forEach(move => {\r\n                const oldPreviewMoves = move.firstChild;\r\n                if (oldPreviewMoves && !oldPreviewMoves.classList.contains('icon-container') && !oldPreviewMoves.classList.contains('mini-icon-container')) {\r\n                    move.removeChild(oldPreviewMoves);\r\n                }\r\n                else if (oldPreviewMoves) oldPreviewMoves.firstChild.classList.remove('attacked');\r\n            });\r\n\r\n            if (rocade) {\r\n                if (rocade.rocade === 's') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 7 : 63].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                } else if (rocade.rocade === 'b') {\r\n                    const rookSquare = currSquareElement.current[rocade.rook];\r\n                    const rookInit = currSquareElement.current[dropPiecer < 0 ? 0 : 56].firstChild;\r\n                    rookSquare.appendChild(rookInit);\r\n                }\r\n            }\r\n\r\n            if (Math.abs(dropPiecer) === 6) {\r\n                kingsMoved.current[dropPiecer] = true;\r\n                console.log(kingsMoved.current[dropPiecer])\r\n            } else if (dropPiecer === 2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 56 ? \"left\" : oldIdx === 63 ? \"right\" : null] = true;\r\n                console.log(rookMoved.current[2][\"right\"]);\r\n            } else if (dropPiecer === -2) {\r\n                rookMoved.current[dropPiecer][oldIdx === 0 ? \"left\" : oldIdx === 7 ? \"right\" : null] = true;\r\n            }\r\n   \r\n            let cloneVirtualBoard = cloneDeep(newVirtualBoard);\r\n            console.log(oldX, oldY, currentX, currentY);\r\n            console.log(cloneVirtualBoard);\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[currentX][currentY] = pieceCode;\r\n\r\n            console.log(cloneVirtualBoard);\r\n            \r\n            // Checking if it's giving checkmate to the opponent\r\n            let oppositeKingSquare, newBoard = [];\r\n\r\n            cloneVirtualBoard.forEach(row => {\r\n                row.forEach(square => newBoard.push(square));\r\n            });\r\n\r\n            newBoard.forEach((square, totalIdx) => {\r\n                if (square === -currentMove * 6 && checkOppositeColor(square, currentMove)) oppositeKingSquare = totalIdx;\r\n            });\r\n\r\n            console.log(oppositeKingSquare);\r\n            \r\n            // const checkMateOpponent = checkCheckmate(-currentMove * 6, cloneVirtualBoard);\r\n            // console.log(checkMateOpponent);\r\n            // if (checkMateOpponent) setGameRunning(false);\r\n\r\n            const checkEqual = checkPat(currentMove, cloneVirtualBoard);\r\n            console.log(checkEqual);\r\n            if (checkEqual) setGameRunning(false);\r\n            localStorage.setItem(\"practice-current-move\", -currentMove);\r\n            // setCurrentMove(-currentMove);\r\n\r\n            localStorage.setItem(\"practice-board\", JSON.stringify(cloneVirtualBoard));\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n\r\n            if (!skipComputerMove) computerMove(cloneVirtualBoard);\r\n           \r\n            console.log(cloneVirtualBoard);\r\n\r\n            // console.log(checkMateOpponent);\r\n            \r\n        } else if (sameIndex === undefined || check) previewVirtualBoard.current = oldBoard;\r\n        \r\n    };\r\n\r\n    const getContainers = (elements, piece) => {\r\n\r\n        let currBoard = [];\r\n        console.log(piece);\r\n        newVirtualBoard.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, piece) && square !== 0) return square;\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n\r\n        console.log(mySquares);\r\n\r\n        const result = elements.filter((element, elementIdx) => {\r\n            let count = 0;\r\n            mySquares.forEach(square => {\r\n                if (square - 2 === elementIdx) count++;\r\n            });\r\n\r\n            console.log(count, elementIdx);\r\n\r\n            if (count < 1 && elementIdx === 3) {\r\n                console.log('queen not working')\r\n                return element;\r\n            }\r\n            else if (count < 2 && elementIdx !== 3) return element;\r\n        });\r\n\r\n        return result;\r\n    };\r\n\r\n    const computerMove = (newBoard) => {\r\n        console.log('none', currentMove);\r\n        let currMove = currentMove, checkmate = false;\r\n        setCurrentMove(-currMove);\r\n\r\n        const possibleMoves = getAllMoves(-currMove, newBoard);\r\n        console.log(possibleMoves)\r\n        if (possibleMoves.length === 0) {\r\n            setGameRunning(false);\r\n            return;\r\n        }\r\n\r\n        let newPossibleMoves, newMove;\r\n\r\n        if (currDifficulty === \"easy\") {\r\n            newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n            newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n           \r\n        } else if (currDifficulty === \"medium\") {\r\n            \r\n            let minNum = { number: Number.POSITIVE_INFINITY };\r\n            possibleMoves.forEach(move => {\r\n                move.moves.forEach(possMove => {\r\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\r\n                        minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                        newMove = possMove;\r\n                        newPossibleMoves = move; \r\n                    }\r\n                });\r\n            });\r\n\r\n            if (minNum.number === Number.POSITIVE_INFINITY) {\r\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n            }\r\n            \r\n        } else if (currDifficulty === \"hard\") {\r\n            \r\n            let minNum = { number: Number.POSITIVE_INFINITY };\r\n            possibleMoves.forEach(move => {\r\n                move.moves.forEach(possMove => {\r\n                    if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\r\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\r\n                            console.log('no, is not defensed');\r\n\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n\r\n            if (minNum.number === Number.POSITIVE_INFINITY) {\r\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n            }\r\n\r\n        } else if (currDifficulty === \"very hard\") {\r\n            let minNum = { number: Number.POSITIVE_INFINITY };\r\n            possibleMoves.forEach(move => {\r\n                move.moves.forEach(possMove => {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    \r\n                    previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\r\n                    previewVirtualBoard.current[parseInt(possMove / 8)][possMove % 8] = move.piece;\r\n                    console.log(previewVirtualBoard.current);\r\n                    let squaresVirtualBoard = [];\r\n\r\n                    previewVirtualBoard.current.forEach(row => {\r\n                        row.forEach(square => squaresVirtualBoard.push(square));\r\n                    });\r\n                    \r\n                    let kingSquare;\r\n\r\n                    squaresVirtualBoard.forEach((square, totalIdx) => {\r\n                        const iconColor = square && square < 0 ? -1 : 1;\r\n                        if (square === setColor * 6 && !checkOppositeColor(iconColor, setColor)) \r\n                            kingSquare = totalIdx;\r\n                    });  \r\n                    console.log(kingSquare, setColor * 6);\r\n                    if (!isDefensed(newBoard, move.idx, possMove) && checkCheckOptimised(kingSquare, setColor * 6)) {\r\n                        \r\n                        if (checkCheckmate(kingSquare, previewVirtualBoard.current)) checkmate = true;\r\n        \r\n                        minNum.number = -1;\r\n                        newMove = possMove;\r\n                        newPossibleMoves = move;\r\n                    } else if (newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && newBoard[parseInt(possMove / 8)][possMove % 8] !== 0 && Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < minNum.number) {\r\n                        if (Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]) < 0) {\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        } else if (!isDefensed(newBoard, move.idx, possMove)) {\r\n                            console.log('no, is not defensed');\r\n\r\n                            minNum.number = Math.abs(move.piece) - Math.abs(newBoard[parseInt(possMove / 8)][possMove % 8]); \r\n                            newMove = possMove;\r\n                            newPossibleMoves = move;\r\n                        }\r\n                    }\r\n\r\n                    previewVirtualBoard.current = oldBoard;\r\n                });\r\n            });\r\n\r\n            if (minNum.number === Number.POSITIVE_INFINITY) {\r\n                newPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n                newMove = newPossibleMoves.moves[Math.floor(Math.random() * newPossibleMoves.moves.length)];\r\n            }\r\n        }\r\n       \r\n        console.log(newMove);\r\n        let cloneVirtualBoard = cloneDeep(newBoard);\r\n\r\n        const oldX = parseInt(newPossibleMoves.idx / 8);\r\n        const oldY = newPossibleMoves.idx % 8;\r\n        const newX = parseInt(newMove / 8);\r\n        const newY = newMove % 8;\r\n\r\n        const iconContainerElement = currSquareElement.current[newPossibleMoves.idx].firstChild;\r\n        iconContainerElement.classList.add('opponent');\r\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\r\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\r\n        iconContainerElement.classList.add('changed-move');\r\n        \r\n        setTimeout(() => {\r\n            // iconContainerElement.classList.remove('opponent');\r\n            iconContainerElement.style.zIndex = 'initial';\r\n            iconContainerElement.style.position = 'initial';\r\n            iconContainerElement.style.left = `initial`;\r\n            iconContainerElement.style.top = `initial`;\r\n            iconContainerElement.style.transform = 'initial';\r\n           \r\n            let sound;\r\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\r\n            else sound = pieceSound;\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[newX][newY] = newPossibleMoves.piece;\r\n\r\n            localStorage.setItem(\"practice-current-move\", setColor);\r\n            localStorage.setItem(\"practice-board\", JSON.stringify(cloneVirtualBoard));\r\n\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n            sound.play();\r\n            if (checkmate) setGameRunning(false);\r\n            setCurrentMove(currMove);\r\n\r\n        }, 750);\r\n    };\r\n\r\n    // Computer check if any piece is attacked and can defense it\r\n\r\n    const isAttacked = (board, computerIdx, playerIdx) => {\r\n        const computerPiece = board[parseInt(computerIdx / 8)][computerIdx % 8];\r\n        const playerPiece = board[parseInt(playerIdx / 8)][playerIdx % 8];\r\n\r\n        let squareBoard = [];\r\n        board.forEach(row => {\r\n            row.forEach(square => squareBoard.push(square));\r\n        });\r\n\r\n        const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, setColor) && square !== 0) return {\r\n                piece: square,\r\n                idx: idx\r\n            }\r\n        });\r\n\r\n        const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\r\n\r\n        playerPieces.forEach(piece => {\r\n            \r\n        });\r\n    };\r\n\r\n    // Check if player move is defensed\r\n\r\n    const isDefensed = (board, computerIdx, playerIdx) => {\r\n        const computerPiece = board[parseInt(computerIdx / 8)][computerIdx % 8];\r\n        const playerPiece = board[parseInt(playerIdx / 8)][playerIdx % 8];\r\n        \r\n        let squareBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => squareBoard.push(square));\r\n        });\r\n\r\n        const playerPiecesUnfiltered = squareBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, setColor) && square !== 0) return {\r\n                piece: square,\r\n                idx: idx\r\n            };\r\n        });\r\n\r\n        const playerPieces = playerPiecesUnfiltered.filter(square => square !== undefined);\r\n\r\n        console.log(playerPieces);\r\n\r\n        let cloneBoard = cloneDeep(board);\r\n        cloneBoard[parseInt(playerIdx / 8)][playerIdx % 8] = 0;\r\n\r\n        // Get possible moves for each piece\r\n\r\n        return playerPieces.some(piece => {\r\n            const playerPossibleMoves = getPossibleMoves(piece.piece, piece.idx, cloneBoard);\r\n            return playerPossibleMoves.some(move => move === playerIdx);\r\n        });\r\n    };\r\n\r\n\r\n    const getAllMoves = (color, newBoard) => {\r\n        let currBoard = [];\r\n\r\n        newBoard.forEach(row => {\r\n            row.forEach(square => {\r\n                currBoard.push(square);\r\n            });\r\n        });\r\n\r\n        let possibleMoves = [], allMoves = [];\r\n\r\n        currBoard.forEach((square, idx) => {\r\n            if (!checkOppositeColor(color, square) && square !== 0) possibleMoves.push({\r\n                piece: square, \r\n                idx: idx\r\n            });\r\n        });\r\n\r\n        possibleMoves.length !== 0 && possibleMoves.forEach(move => {\r\n            const currPossMoves = getPossibleMoves(move.piece, move.idx, newBoard);\r\n            console.log(move);\r\n            const currMoves = currPossMoves.length !== 0 && isArray(currPossMoves) ? currPossMoves.filter(currPieceMove => {\r\n                if (currPieceMove.rocade != null) return false;\r\n                let oldPreviewVirtualBoard = cloneDeep(previewVirtualBoard.current);\r\n                console.log(move.idx, currPieceMove);\r\n                previewVirtualBoard.current[parseInt(move.idx / 8)][move.idx % 8] = 0;\r\n                previewVirtualBoard.current[parseInt(currPieceMove / 8)][currPieceMove % 8] = move.piece;\r\n                let kingSquare;\r\n                console.log(newVirtualBoard);\r\n                previewVirtualBoard.current.forEach((row, rowIdx) => {\r\n                    row.forEach((square, squareIdx) => {\r\n                        if (square === -setColor * 6) kingSquare = rowIdx * 8 + squareIdx;\r\n                    });\r\n                });\r\n                \r\n                const isCheck = checkCheckOptimised(kingSquare, -setColor * 6);\r\n                previewVirtualBoard.current = cloneDeep(oldPreviewVirtualBoard);\r\n                \r\n                return !isCheck;\r\n            }) : [];\r\n\r\n            console.log(currMoves);\r\n            \r\n            if (currMoves.length !== 0) {\r\n                allMoves.push({\r\n                    piece: move.piece,\r\n                    idx: move.idx, \r\n                    moves: currMoves\r\n                });\r\n            }\r\n        });\r\n\r\n        console.log(allMoves);\r\n\r\n        return allMoves;\r\n    };\r\n\r\n    const computerMoveFirst = () => {\r\n        let newBoard1 = cloneDeep(newVirtualBoard);\r\n        newBoard1[2][0] = 0;\r\n        newBoard1[0][1] = 3;\r\n        setNewVirtualBoard(newBoard1);\r\n        const possibleMoves = getAllMoves(currentMove, newBoard1);\r\n        console.log(possibleMoves, Math.random() * possibleMoves.length);\r\n        const randomPossibleMoves = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\r\n        const randomMove = randomPossibleMoves.moves[Math.floor(Math.random() * randomPossibleMoves.moves.length)];\r\n        console.log(randomMove);\r\n        let cloneVirtualBoard = cloneDeep(newBoard1);\r\n\r\n        const oldX = parseInt(randomPossibleMoves.idx / 8);\r\n        const oldY = randomPossibleMoves.idx % 8;\r\n        const newX = parseInt(randomMove / 8);\r\n        const newY = randomMove % 8;\r\n        console.log(newX, newY);\r\n\r\n        const iconContainerElement = currSquareElement.current[randomPossibleMoves.idx].firstChild;\r\n        iconContainerElement.classList.add('opponent');\r\n        iconContainerElement.style.setProperty(\"--element-left\", `${(newY - oldY) * 100}px`);\r\n        iconContainerElement.style.setProperty(\"--element-top\", `${(newX - oldX) * 100}px`)\r\n        iconContainerElement.classList.add('changed-move');\r\n        \r\n        setTimeout(() => {\r\n            // iconContainerElement.classList.remove('opponent');\r\n            iconContainerElement.style.zIndex = 'initial';\r\n            iconContainerElement.style.position = 'initial';\r\n            iconContainerElement.style.left = `initial`;\r\n            iconContainerElement.style.top = `initial`;\r\n            iconContainerElement.style.transform = 'initial';\r\n            \r\n           \r\n            let sound;\r\n            if (cloneVirtualBoard[newX][newY] !== 0) sound = pieceCapture;\r\n            else sound = pieceSound;\r\n\r\n            cloneVirtualBoard[oldX][oldY] = 0;\r\n            cloneVirtualBoard[newX][newY] = randomPossibleMoves.piece;\r\n\r\n            localStorage.setItem(\"practice-current-move\", setColor);\r\n            localStorage.setItem(\"practice-board\", JSON.stringify(cloneVirtualBoard));\r\n\r\n            setNewVirtualBoard(cloneVirtualBoard);\r\n            sound.play();\r\n            setCurrentMove(setColor);\r\n\r\n          \r\n        }, 750);\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (setColor === -1) computerMoveFirst();\r\n    }, []);\r\n    \r\n       \r\n \r\n\r\n    const pawnTransformPiece = (piece, idx, oldIdx) => {\r\n\r\n        // Get transformed piece's code\r\n        const transformPieceCode = currentMove * Object.keys(piecesCode).find(key => piecesCode[key] === piece);\r\n        const newBoard = cloneDeep(newVirtualBoard);\r\n        const currentX = parseInt(idx / 8);\r\n        const currentY = idx % 8;\r\n        const oldX = parseInt(oldIdx / 8);\r\n        const oldY = oldIdx % 8;\r\n        const totalIdx = currentX * 8 + currentY + + (currentX % 2 !== 0 ? 1 : 0)\r\n        newBoard[currentX][currentY] = transformPieceCode;\r\n        newBoard[oldX][oldY] = 0;\r\n        setNewVirtualBoard(newBoard);\r\n        console.log(newBoard);\r\n        previewVirtualBoard.current = newBoard;\r\n        console.log(newBoard);\r\n        \r\n        setPawnTransform({\r\n            idx: idx,\r\n            piece: transformPieceCode,\r\n            elements: []\r\n        });\r\n\r\n        localStorage.setItem(\"practice-board\", JSON.stringify(newBoard));\r\n    };\r\n\r\n    const checkOppositeColor = (piece1, piece2) => {\r\n        if (piece1 < 0 && piece2 > 0) return true;\r\n        else if (piece1 > 0 && piece2 < 0) return true;\r\n        return false;\r\n    }\r\n\r\n    const checkCheck = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        console.log('lalalalaalaallapgdkkdfpgogjodjfgjdp', previewVirtualBoard.current, kingSquare);\r\n        console.log(kingSquare);\r\n        let currBoard = [];\r\n\r\n        previewVirtualBoard.current.forEach(row => {\r\n            row.forEach(square => {\r\n                currBoard.push(square);\r\n            });\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, idx) => {\r\n            if (checkOppositeColor(kCode, square)) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            };\r\n        });\r\n\r\n        console.log(oppositeSquaresClone);\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        console.log(oppositeSquares, kingSquare);\r\n\r\n        // Checking if king is attacked\r\n\r\n        const check = oppositeSquares.some(square => {\r\n            console.log(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            const possibleMovesCheck = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            console.log(possibleMoves);\r\n            return possibleMovesCheck.some(currSquare => {\r\n                \r\n                console.log(currSquare, kingSquare);\r\n                return currSquare === kingSquare;\r\n            });\r\n        });\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        if (check && !isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n\r\n        return check;\r\n    };\r\n\r\n    const checkCheckOptimised = (kingSquare, kCode, isFromCheckMate = false) => {\r\n\r\n        // Getting coords\r\n        const currentX = parseInt(kingSquare / 8);\r\n        const currentY = kingSquare % 8;\r\n        const pieceCode = kCode / (-6);\r\n\r\n        let check = false;\r\n\r\n        const kingPossibleSquares = [\r\n            [currentX - 1, currentY - 1],\r\n            [currentX - 1, currentY],\r\n            [currentX - 1, currentY + 1],\r\n            [currentX, currentY - 1],\r\n            [currentX, currentY + 1],\r\n            [currentX + 1, currentY - 1],\r\n            [currentX + 1, currentY],\r\n            [currentX + 1, currentY + 1]\r\n        ];\r\n\r\n        console.log(previewVirtualBoard.current, pieceCode);\r\n\r\n        kingPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === -kCode && square !== null) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        // Pawns \r\n\r\n        const pawnPossibleSquares = [\r\n            [currentX + (pieceCode * setColor), currentY - (pieceCode * setColor)],\r\n            [currentX + (pieceCode * setColor), currentY + (pieceCode * setColor)]\r\n        ];\r\n        \r\n        console.log(pawnPossibleSquares);\r\n\r\n        pawnPossibleSquares.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode) {\r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                console.log('check');\r\n                check = true;\r\n            }\r\n        });\r\n        \r\n        // Rows\r\n\r\n        if (currentX > 0) {\r\n            for (let i = currentX - 1; i >= 0; i--) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentX < ROWS - 1) {\r\n            for (let i = currentX + 1; i < ROWS; i++) {\r\n                const rowSquare =   previewVirtualBoard.current[i] && \r\n                                    previewVirtualBoard.current[i][currentY] &&\r\n                                    previewVirtualBoard.current[i][currentY];\r\n\r\n                console.log(rowSquare, pieceCode, previewVirtualBoard.current);\r\n                \r\n                if (rowSquare === 2 * pieceCode || rowSquare * pieceCode === 5) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) {\r\n                        const checkMate = checkCheckmate(kCode, newVirtualBoard);\r\n                        console.log(checkMate);\r\n                    }\r\n                    console.log(\"here in if\")\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (rowSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Columns \r\n\r\n        if (currentY > 0) {\r\n            for (let i = currentY - 1; i >= 0; i--) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        if (currentY < COLUMNS - 1) {\r\n            for (let i = currentX + 1; i < COLUMNS; i++) {\r\n                const columnSquare = previewVirtualBoard.current[currentX] &&\r\n                                     previewVirtualBoard.current[currentX][i] && \r\n                                     previewVirtualBoard.current[currentX][i];\r\n                \r\n                if (columnSquare === 2 * pieceCode || columnSquare === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (columnSquare !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top left\r\n        \r\n        if (currentX > 0 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal top right\r\n\r\n        if (currentX > 0 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX - i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom left\r\n\r\n        if (currentX < ROWS - 1 && currentY > 0) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY - i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Diagonal bottom right\r\n\r\n        if (currentX < ROWS - 1 && currentY < COLUMNS - 1) {\r\n            for (let i = 1; i < 8; i++) {\r\n                const newX = currentX + i;\r\n                const newY = currentY + i;\r\n                const square = previewVirtualBoard.current[newX] &&\r\n                               previewVirtualBoard.current[newX][newY] && \r\n                               previewVirtualBoard.current[newX][newY];\r\n                if (square == null) break;\r\n                \r\n                if (square === 4 * pieceCode || square === 5 * pieceCode) {\r\n                    const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                    if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                    previewVirtualBoard.current = oldBoard;\r\n                    return true;\r\n                }\r\n                else if (square !== 0) break;\r\n            }\r\n        }\r\n\r\n        // Knight moves\r\n\r\n        const knightPossibleMoves = [\r\n            [currentX - 2, currentY - 1],\r\n            [currentX - 2, currentY + 1],\r\n            [currentX + 2, currentY - 1],\r\n            [currentX + 2, currentY + 1],\r\n            [currentX - 1, currentY - 2],\r\n            [currentX - 1, currentY + 2],\r\n            [currentX + 1, currentY - 2],\r\n            [currentX + 1, currentY + 2]\r\n        ];\r\n\r\n        \r\n        \r\n        knightPossibleMoves.forEach(move => {\r\n            const square = previewVirtualBoard.current[move[0]] && \r\n                           previewVirtualBoard.current[move[0]][move[1]] &&\r\n                           previewVirtualBoard.current[move[0]][move[1]];\r\n\r\n            if (square === pieceCode * 3) { \r\n                const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n                if (!isFromCheckMate) checkCheckmate(kCode, newVirtualBoard);\r\n                previewVirtualBoard.current = oldBoard;\r\n                check = true;\r\n            }\r\n        });\r\n\r\n        return check;\r\n    };\r\n\r\n\r\n    // Checking the check-mate\r\n\r\n    const checkCheckmate = (kCode, board) => {\r\n\r\n        console.log(board);\r\n        const constantBoard = board;\r\n        let currBoard = [];\r\n\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const mySquaresClone = currBoard.map((square, idx) => {\r\n            if (!checkOppositeColor(square, kCode) && square !== 0) return {\r\n                pieceCode: square,\r\n                coords: idx\r\n            }\r\n        });\r\n\r\n        const mySquares = mySquaresClone.filter(square => square !== undefined);\r\n        console.log(mySquares);\r\n        let checkMate = true;\r\n\r\n        const oldBoard = cloneDeep(previewVirtualBoard.current);\r\n\r\n        mySquares.forEach(square => {\r\n\r\n            // Next possible moves to check if it's checkmate\r\n            const possibleMovesCheckmate = getPossibleMoves(square.pieceCode, square.coords, previewVirtualBoard.current);\r\n            console.log(possibleMovesCheckmate);\r\n\r\n            possibleMovesCheckmate.forEach(move => {\r\n                const currX = parseInt(square.coords / 8);\r\n                const currY = square.coords % 8;\r\n                const newX = parseInt(move / 8);\r\n                const newY = move % 8;\r\n                const newBoard = cloneDeep(constantBoard);\r\n\r\n                newBoard[currX][currY] = 0;\r\n                \r\n                if (newBoard && newBoard[newX] && newBoard[newX][newY]) {\r\n                    if (newBoard[newX][newY] !== 0) {\r\n                        const enemyPieceNumber = newBoard[newX][newY];\r\n                        if (checkOppositeColor(enemyPieceNumber, square.pieceCode)) newBoard[newX][newY] = square.pieceCode;\r\n                    } else newBoard[newX][newY] = square.pieceCode;\r\n                }\r\n\r\n                \r\n                previewVirtualBoard.current = cloneDeep(newBoard);\r\n\r\n                let allInOneBoard = [];\r\n\r\n                previewVirtualBoard.current.forEach(row => {\r\n                    row.forEach(square => allInOneBoard.push(square));\r\n                });\r\n\r\n                console.log(newBoard, kCode);\r\n\r\n                console.log(allInOneBoard);\r\n\r\n                let kingSquare = -1;\r\n\r\n                allInOneBoard.forEach((square, idx) => {\r\n                    if (square === kCode) kingSquare = idx;\r\n                });\r\n\r\n                console.log(kingSquare);\r\n                \r\n                const newBoardCheck = checkCheckOptimised(kingSquare, kCode, true);\r\n                console.log(newBoardCheck, kingSquare, kCode);\r\n                if (!newBoardCheck) checkMate = false;\r\n                \r\n            });\r\n        });\r\n        \r\n\r\n        previewVirtualBoard.current = oldBoard;\r\n       if (checkMate) setGameRunning(false);\r\n       return checkMate;\r\n        \r\n    };\r\n\r\n    const checkPat = (pieceCode, board) => {\r\n        let currBoard = [];\r\n        console.log(board, pieceCode);\r\n        board.forEach(row => {\r\n            row.forEach(square => currBoard.push(square));\r\n        });\r\n\r\n        const oppositeSquaresClone = currBoard.map((square, coords) => {\r\n            if (checkOppositeColor(pieceCode, square)) return {\r\n                pieceCode: square,\r\n                coords: coords\r\n            };\r\n        });\r\n\r\n        const oppositeSquares = oppositeSquaresClone.filter(square => square !== undefined);\r\n\r\n        return oppositeSquares.every(square => {\r\n            const oppPossibleMoves = getPossibleMoves(square.pieceCode, square.coords, board);\r\n            console.log(oppPossibleMoves);\r\n            return oppPossibleMoves.length === 0;\r\n        });\r\n    };\r\n\r\n\r\n    const addSquares = () => {\r\n        let squareComponents = [];\r\n       \r\n        const board = newVirtualBoard.map((row, rowIdx) => {\r\n\r\n            const rows = row.map((square, squareIdx) => {\r\n                const totalIdx = rowIdx * 8 + squareIdx + (rowIdx % 2 !== 0 ? 1 : 0);\r\n                const realIdx = rowIdx * 8 + squareIdx;\r\n               \r\n                const squareComponent = \r\n                    <div \r\n                        className={`square ${totalIdx % 2 === 0 ? \"even\" : \"\"}`} \r\n                        key={squareIdx} \r\n                        ref={ref => { \r\n                            currSquareElement.current[realIdx] = ref;\r\n                        }}\r\n                        onClick={() => selectSquare(currSquareElement.current[realIdx])}\r\n                    >\r\n                        {square !== 0 && pawnTransform?.idx === realIdx ? (\r\n                            pawnTransform.elements.length > 0 ? (<div \r\n                                className={`replace-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                key={totalIdx}\r\n                            >   \r\n                                {pawnTransform.elements}  \r\n                            </div>)\r\n                            : (\r\n                                <div \r\n                                    className={`icon-container ${pawnTransform.piece < 0 ? -1 : 1} ${pawnTransform.piece}`}\r\n                                    onMouseDown={e => dragPiece(e, pawnTransform.piece, totalIdx)}\r\n                                    onMouseMove={e => movePiece(e)}\r\n                                    onMouseUp={e => dropPiece(e, pawnTransform.piece)} \r\n                                    key={totalIdx}\r\n                                >   \r\n                                    <FontAwesomeIcon \r\n                                        icon={piecesCode[Math.abs(pawnTransform.piece).toString()]} \r\n                                        className={`piece ${pawnTransform.piece < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                        color={pawnTransform.piece > 0 ? \"#fff\" : \"initial\"} \r\n                                        code={pawnTransform.piece}\r\n                                    />\r\n                                </div>\r\n                            )\r\n                        ) : square !== 0 ? (\r\n                            <div \r\n                                className={`icon-container ${square < 0 ? -1 : 1} ${square}`}\r\n                                onMouseDown={e => dragPiece(e, square, totalIdx)}\r\n                                onMouseMove={e => movePiece(e)}\r\n                                onMouseUp={e => dropPiece(e, square)} \r\n                                key={totalIdx}\r\n                            >   \r\n                                <FontAwesomeIcon \r\n                                    icon={piecesCode[Math.abs(square).toString()]} \r\n                                    className={`piece ${square < 0 ? \"stroke_white\" : \"stroke_black\"}`}\r\n                                    color={square > 0 ? \"#fff\" : \"initial\"} \r\n                                    code={square}\r\n                                />\r\n                            </div>\r\n                        ) : \"\"}\r\n                    </div>;\r\n\r\n                return squareComponent;\r\n            });\r\n            return (\r\n                <div className=\"row\" key={rowIdx} style={{height: `${100 / rows.length}%`}}>\r\n                    {rows}\r\n                </div>\r\n            );\r\n        });\r\n\r\n        squareElements.current = squareComponents;\r\n\r\n        return board;\r\n    };\r\n\r\n    return (\r\n        <div className=\"board\" style={{width: `${HEIGHT}px`, height: `${HEIGHT}px`}} ref={boardRef}>\r\n            {addSquares()}\r\n            <div className=\"letters\">\r\n                <p>A</p>\r\n                <p>B</p>\r\n                <p>C</p>\r\n                <p>D</p>\r\n                <p>E</p>\r\n                <p>F</p>\r\n                <p>G</p>\r\n                <p>H</p>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\ResetButton.jsx",["176"],"import React, { Component } from \"react\";\r\n\r\nexport default class ResetButton extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.computerGame = this.props.computerGame;\r\n        this.lang = localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\";\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        console.log(\"set\")\r\n        this.lang = localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\";\r\n    }\r\n\r\n    resetGame() {\r\n        if (this.computerGame) { \r\n            for (let i = 0, len = localStorage.length; i < len; i++) {\r\n                const key = localStorage.key(i);\r\n                console.log(key);\r\n                if (key === null) continue;\r\n                if (key.search(\"computer-\") !== -1) localStorage.removeItem(key);\r\n            }\r\n        }\r\n        else localStorage.clear();\r\n        window.location.reload();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"reset-button\" onClick={() => this.resetGame()}>\r\n                <h2>{this.lang === \"en\" ? \"Reset Game\" : this.lang === \"ro\" ? \"Reseteaza Jocul\" : \"Reset játék\"}</h2>\r\n            </div>\r\n        );\r\n    }\r\n \r\n};","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\OnlineSocket.jsx",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\PreviousButton.jsx",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\DraggableIcon.jsx",["177"],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Header.jsx",[],"A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Tutorial.jsx",["178","179","180"],"import React, {useState, useEffect, useRef} from \"react\";\r\nimport Header from \"./Header\";\r\nimport tutorialJson from \"../json/tutorial.json\";\r\n\r\nimport \"../styles/tutorial.css\";\r\nimport PracticeBoard from \"./PracticeBoard\";\r\nimport Board from \"./Board\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleLeft, faAngleRight } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\n\r\nexport default function Tutorial() {\r\n\r\n    const chapters = tutorialJson.modules;\r\n\r\n    const [lang, setLang] = useState(localStorage.getItem(\"language\") ? JSON.parse(localStorage.getItem(\"language\")) : \"en\");\r\n    const [content, setContent] = useState(null);\r\n    const [currChapter, setCurrChapter] = useState(Object.values(chapters)[0].chapters);\r\n    const [currChapterName, setCurrChapterName] = useState(Object.values(chapters)[0][`title_${lang}`]);\r\n    const [currSubChapterName, setCurrSubChapterName] = useState(null);\r\n    const [currSubChapter, setCurrSubChapter] = useState(null);\r\n    const [currChapterIdx, setCurrChapterIdx] = useState(0);\r\n    const [currSubChapterIdx, setCurrSubChapterIdx] = useState(0);\r\n\r\n    const chaptersRef = useRef();\r\n\r\n    useEffect(() => {\r\n        if (localStorage.length !== 0) {\r\n            for (let i = 0, len = localStorage.length; i < len; i++) {\r\n                const key = localStorage.key(i);\r\n                if (key === null) continue;\r\n                if (key.search(\"classic-\") !== -1) localStorage.removeItem(key);\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    useEffect(() => console.log(currChapter), [currChapter]);\r\n\r\n    const stopTimer = () => {\r\n\r\n    };\r\n\r\n    const nextLesson = () => {\r\n        const newSubChapterIdx =  currSubChapterIdx + 1;\r\n        if (newSubChapterIdx < Object.values(currChapter).length) {\r\n            setCurrSubChapter(Object.values(currChapter)[newSubChapterIdx].description);\r\n            setCurrSubChapterIdx(newSubChapterIdx);\r\n            setCurrSubChapterName(Object.values(currChapter)[newSubChapterIdx][`title_${lang}`]);\r\n            return;\r\n        }\r\n\r\n        const newChapterIdx = currChapterIdx + 1;\r\n        const newChapter = Object.values(chapters)[newChapterIdx];\r\n        const newSubChapter = Object.values(newChapter.chapters)[0];\r\n        setCurrChapterIdx(newChapterIdx);\r\n        setCurrChapter(newChapter.chapters);\r\n        setCurrChapterName(newChapter[`title_${lang}`]);\r\n        setCurrSubChapterIdx(0);\r\n        setCurrSubChapter(newSubChapter.description);\r\n        setCurrSubChapterName(newSubChapter[`title_${lang}`]);\r\n    };\r\n\r\n    const backLesson = () => {\r\n        const newSubChapterIdx =  currSubChapterIdx - 1;\r\n        if (newSubChapterIdx >= 0) {\r\n            setCurrSubChapter(Object.values(currChapter)[newSubChapterIdx].description);\r\n            setCurrSubChapterIdx(newSubChapterIdx);\r\n            setCurrSubChapterName(Object.values(currChapter)[newSubChapterIdx][`title_${lang}`]);\r\n            return;\r\n        }\r\n\r\n\r\n        const newChapterIdx = currChapterIdx - 1;\r\n        if (newChapterIdx < 0) return;\r\n        const newChapter = Object.values(chapters)[newChapterIdx];\r\n        const newSubChapter = Object.values(newChapter.chapters)[Object.values(newChapter.chapters).length - 1];\r\n        setCurrChapterIdx(newChapterIdx);\r\n        setCurrChapter(newChapter.chapters);\r\n        setCurrChapterName(newChapter[`title_${lang}`]);\r\n        setCurrSubChapterIdx(Object.values(newChapter.chapters).length - 1);\r\n        setCurrSubChapter(newSubChapter.description);\r\n        setCurrSubChapterName(newSubChapter[`title_${lang}`]);\r\n    };\r\n    \r\n    return (\r\n        <div className=\"container\">\r\n            <Header />\r\n            <div className=\"banner\">\r\n                <h2 className=\"center-text\">Tutorial for absolute beginners!</h2>\r\n            </div>\r\n\r\n            <div className=\"content-tutorial\">\r\n                <div className=\"chapters\">\r\n                    {Object.values(chapters).map((chapter, idx) => (\r\n                        <div className=\"chapter\" key={idx} onClick={() => {\r\n                            chaptersRef.current.classList.remove(\"total_hide\");\r\n                            chaptersRef.current.classList.remove(\"hide\");\r\n                           \r\n                                setCurrChapterIdx(idx);\r\n                                setCurrSubChapterIdx(0);\r\n                                setCurrChapter(chapter.chapters);\r\n                                setCurrChapterName(chapter[`title_${lang}`])\r\n                                setCurrSubChapter(null);\r\n                                setCurrSubChapterName(null);\r\n                            \r\n                        }}>\r\n                            <p>{idx + 1}. {chapter[`title_${lang}`]}</p>\r\n                            <div className=\"tick\"></div>\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n                \r\n                <div ref={chaptersRef} className={`description-tutorial`}>\r\n                    <h2 className=\"chapter-title\">{currChapterName}</h2>\r\n                    <div className=\"chapter-content\">\r\n                        {Object.values(currChapter).map((chapter, idx) => (\r\n                            <div className=\"content-text\" key={idx} onClick={(e) => {\r\n                                chaptersRef.current.classList.add(\"hide\");\r\n                                chaptersRef.current.addEventListener(\"transitionend\", () => {\r\n                                    chaptersRef.current.classList.add(\"total_hide\");\r\n                                    setCurrSubChapterName(chapter[`title_${lang}`]);\r\n                                    setCurrSubChapter(chapter.description);\r\n                                    setCurrSubChapterIdx(idx);\r\n                                });\r\n                            }}>\r\n                                <p className=\"subchapter-title\">{chapter[`title_${lang}`]}</p>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n\r\n                <div className={`subchapter-description ${currSubChapter ? \"show\" : null}`}>\r\n                    <div className=\"subchapter-title\">{currSubChapterName}</div>\r\n                   \r\n                        {currSubChapter && (\r\n                            <div className=\"subchapter-content\">\r\n                                <p className=\"description\">{currSubChapter[`text_${lang}`]}</p>\r\n                                {currSubChapter[`text_2_${lang}`] && (\r\n                                    <p className=\"description\">{currSubChapter[`text_2_${lang}`]}</p>\r\n                                )}\r\n                                \r\n                                <div className=\"board-container-lesson\">\r\n                                    {currSubChapter.board === \"classic\" ? (\r\n                                        <Board color={1} stopTimer={stopTimer} lesson={true}/>\r\n                                    ) : currSubChapter.board === \"practice\" ? (\r\n                                        <PracticeBoard pieceCode={currSubChapter.pieceCode} lesson={true} />\r\n                                    ) : null}       \r\n                                </div>\r\n\r\n                                <div className=\"lesson-buttons\">\r\n                                    {(currChapterIdx - 1 >= 0 || currSubChapterIdx - 1 >= 0) && <button className=\"previous-lesson\" type=\"click\" onClick={() => backLesson()}>\r\n                                        <h3> <FontAwesomeIcon \r\n                                                icon={faAngleLeft}\r\n                                                color=\"#fff\"\r\n                                                className=\"prev-icon\"\r\n                                            />\r\n                                            Previous lesson \r\n                                        </h3>\r\n                                    </button>}\r\n                                    {(currChapterIdx + 1 < Object.values(chapters).length || currSubChapterIdx + 1 < Object.values(Object.values(chapters)[currChapterIdx]).length)&& <button className=\"next-lesson\" type=\"click\" onClick={() => nextLesson()}>\r\n                                        <h3>Next lesson \r\n                                            <FontAwesomeIcon \r\n                                                icon={faAngleRight}\r\n                                                color=\"#fff\"\r\n                                                className=\"next-icon\"\r\n                                            />\r\n                                        </h3>\r\n                                    </button>}\r\n                                </div>\r\n\r\n                                \r\n                            </div>\r\n                        )}\r\n                    \r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};","A:\\Js\\Chess\\CHESS FINAL\\chess\\src\\Components\\Lessons.jsx",["181","182"],"import React, {useState, useEffect} from \"react\";\r\nimport Header from \"./Header\";\r\n\r\nimport \"../styles/lessons.css\";\r\n\r\nexport default function Lessons() {\r\n    return (\r\n        <div className=\"container\">\r\n            <Header />\r\n            <div className=\"banner\">\r\n                s\r\n            </div>\r\n        </div>\r\n    );\r\n};",{"ruleId":"183","replacedBy":"184"},{"ruleId":"185","replacedBy":"186"},{"ruleId":"187","severity":1,"message":"188","line":34,"column":11,"nodeType":"189","messageId":"190","endLine":34,"endColumn":23},{"ruleId":"187","severity":1,"message":"191","line":3,"column":8,"nodeType":"189","messageId":"190","endLine":3,"endColumn":10},{"ruleId":"187","severity":1,"message":"192","line":5,"column":8,"nodeType":"189","messageId":"190","endLine":5,"endColumn":13},{"ruleId":"187","severity":1,"message":"193","line":22,"column":12,"nodeType":"189","messageId":"190","endLine":22,"endColumn":16},{"ruleId":"187","severity":1,"message":"194","line":22,"column":18,"nodeType":"189","messageId":"190","endLine":22,"endColumn":25},{"ruleId":"187","severity":1,"message":"195","line":25,"column":12,"nodeType":"189","messageId":"190","endLine":25,"endColumn":18},{"ruleId":"187","severity":1,"message":"196","line":27,"column":12,"nodeType":"189","messageId":"190","endLine":27,"endColumn":19},{"ruleId":"187","severity":1,"message":"197","line":29,"column":9,"nodeType":"189","messageId":"190","endLine":29,"endColumn":16},{"ruleId":"198","severity":1,"message":"199","line":33,"column":72,"nodeType":"200","messageId":"201","endLine":33,"endColumn":74},{"ruleId":"202","severity":1,"message":"203","line":97,"column":8,"nodeType":"204","endLine":97,"endColumn":25,"suggestions":"205"},{"ruleId":"187","severity":1,"message":"206","line":1,"column":27,"nodeType":"189","messageId":"190","endLine":1,"endColumn":36},{"ruleId":"187","severity":1,"message":"207","line":1,"column":38,"nodeType":"189","messageId":"190","endLine":1,"endColumn":44},{"ruleId":"187","severity":1,"message":"208","line":3,"column":102,"nodeType":"189","messageId":"190","endLine":3,"endColumn":114},{"ruleId":"202","severity":1,"message":"209","line":32,"column":8,"nodeType":"204","endLine":32,"endColumn":10,"suggestions":"210"},{"ruleId":"202","severity":1,"message":"211","line":161,"column":8,"nodeType":"204","endLine":161,"endColumn":16,"suggestions":"212"},{"ruleId":"213","severity":1,"message":"214","line":887,"column":138,"nodeType":"215","messageId":"216","endLine":887,"endColumn":140},{"ruleId":"213","severity":1,"message":"214","line":887,"column":158,"nodeType":"215","messageId":"216","endLine":887,"endColumn":160},{"ruleId":"202","severity":1,"message":"217","line":1342,"column":8,"nodeType":"204","endLine":1342,"endColumn":18,"suggestions":"218"},{"ruleId":"219","severity":1,"message":"220","line":1644,"column":60,"nodeType":"221","messageId":"222","endLine":1644,"endColumn":62},{"ruleId":"219","severity":1,"message":"220","line":1722,"column":69,"nodeType":"221","messageId":"222","endLine":1722,"endColumn":71},{"ruleId":"187","severity":1,"message":"223","line":9,"column":7,"nodeType":"189","messageId":"190","endLine":9,"endColumn":13},{"ruleId":"202","severity":1,"message":"224","line":110,"column":8,"nodeType":"204","endLine":110,"endColumn":28,"suggestions":"225"},{"ruleId":"202","severity":1,"message":"211","line":159,"column":8,"nodeType":"204","endLine":159,"endColumn":16,"suggestions":"226"},{"ruleId":"213","severity":1,"message":"214","line":883,"column":138,"nodeType":"215","messageId":"216","endLine":883,"endColumn":140},{"ruleId":"213","severity":1,"message":"214","line":883,"column":158,"nodeType":"215","messageId":"216","endLine":883,"endColumn":160},{"ruleId":"187","severity":1,"message":"227","line":9,"column":8,"nodeType":"189","messageId":"190","endLine":9,"endColumn":20},{"ruleId":"187","severity":1,"message":"228","line":12,"column":7,"nodeType":"189","messageId":"190","endLine":12,"endColumn":14},{"ruleId":"187","severity":1,"message":"229","line":47,"column":12,"nodeType":"189","messageId":"190","endLine":47,"endColumn":30},{"ruleId":"187","severity":1,"message":"230","line":47,"column":32,"nodeType":"189","messageId":"190","endLine":47,"endColumn":53},{"ruleId":"187","severity":1,"message":"231","line":52,"column":26,"nodeType":"189","messageId":"190","endLine":52,"endColumn":41},{"ruleId":"187","severity":1,"message":"232","line":63,"column":11,"nodeType":"189","messageId":"190","endLine":63,"endColumn":22},{"ruleId":"187","severity":1,"message":"233","line":101,"column":11,"nodeType":"189","messageId":"190","endLine":101,"endColumn":23},{"ruleId":"198","severity":1,"message":"234","line":780,"column":25,"nodeType":"200","messageId":"201","endLine":780,"endColumn":27},{"ruleId":"187","severity":1,"message":"235","line":801,"column":19,"nodeType":"189","messageId":"190","endLine":801,"endColumn":20},{"ruleId":"187","severity":1,"message":"236","line":802,"column":19,"nodeType":"189","messageId":"190","endLine":802,"endColumn":20},{"ruleId":"187","severity":1,"message":"237","line":822,"column":19,"nodeType":"189","messageId":"190","endLine":822,"endColumn":28},{"ruleId":"213","severity":1,"message":"214","line":825,"column":138,"nodeType":"215","messageId":"216","endLine":825,"endColumn":140},{"ruleId":"213","severity":1,"message":"214","line":825,"column":158,"nodeType":"215","messageId":"216","endLine":825,"endColumn":160},{"ruleId":"187","severity":1,"message":"238","line":832,"column":17,"nodeType":"189","messageId":"190","endLine":832,"endColumn":25},{"ruleId":"187","severity":1,"message":"239","line":908,"column":17,"nodeType":"189","messageId":"190","endLine":908,"endColumn":35},{"ruleId":"187","severity":1,"message":"240","line":955,"column":11,"nodeType":"189","messageId":"190","endLine":955,"endColumn":24},{"ruleId":"219","severity":1,"message":"220","line":963,"column":60,"nodeType":"221","messageId":"222","endLine":963,"endColumn":62},{"ruleId":"219","severity":1,"message":"241","line":971,"column":62,"nodeType":"221","messageId":"222","endLine":971,"endColumn":64},{"ruleId":"187","severity":1,"message":"242","line":998,"column":15,"nodeType":"189","messageId":"190","endLine":998,"endColumn":23},{"ruleId":"187","severity":1,"message":"243","line":1021,"column":11,"nodeType":"189","messageId":"190","endLine":1021,"endColumn":21},{"ruleId":"219","severity":1,"message":"220","line":1032,"column":66,"nodeType":"221","messageId":"222","endLine":1032,"endColumn":68},{"ruleId":"219","severity":1,"message":"220","line":1328,"column":60,"nodeType":"221","messageId":"222","endLine":1328,"endColumn":62},{"ruleId":"219","severity":1,"message":"220","line":1410,"column":69,"nodeType":"221","messageId":"222","endLine":1410,"endColumn":71},{"ruleId":"202","severity":1,"message":"244","line":1564,"column":8,"nodeType":"204","endLine":1564,"endColumn":19,"suggestions":"245"},{"ruleId":"187","severity":1,"message":"231","line":45,"column":26,"nodeType":"189","messageId":"190","endLine":45,"endColumn":41},{"ruleId":"187","severity":1,"message":"233","line":95,"column":11,"nodeType":"189","messageId":"190","endLine":95,"endColumn":23},{"ruleId":"202","severity":1,"message":"211","line":155,"column":8,"nodeType":"204","endLine":155,"endColumn":16,"suggestions":"246"},{"ruleId":"202","severity":1,"message":"247","line":168,"column":8,"nodeType":"204","endLine":168,"endColumn":21,"suggestions":"248"},{"ruleId":"202","severity":1,"message":"247","line":182,"column":8,"nodeType":"204","endLine":182,"endColumn":20,"suggestions":"249"},{"ruleId":"187","severity":1,"message":"250","line":191,"column":11,"nodeType":"189","messageId":"190","endLine":191,"endColumn":17},{"ruleId":"198","severity":1,"message":"234","line":878,"column":22,"nodeType":"200","messageId":"201","endLine":878,"endColumn":24},{"ruleId":"187","severity":1,"message":"235","line":916,"column":19,"nodeType":"189","messageId":"190","endLine":916,"endColumn":20},{"ruleId":"187","severity":1,"message":"236","line":917,"column":19,"nodeType":"189","messageId":"190","endLine":917,"endColumn":20},{"ruleId":"213","severity":1,"message":"214","line":938,"column":138,"nodeType":"215","messageId":"216","endLine":938,"endColumn":140},{"ruleId":"213","severity":1,"message":"214","line":938,"column":158,"nodeType":"215","messageId":"216","endLine":938,"endColumn":160},{"ruleId":"187","severity":1,"message":"238","line":944,"column":17,"nodeType":"189","messageId":"190","endLine":944,"endColumn":25},{"ruleId":"187","severity":1,"message":"240","line":1068,"column":11,"nodeType":"189","messageId":"190","endLine":1068,"endColumn":24},{"ruleId":"219","severity":1,"message":"220","line":1076,"column":60,"nodeType":"221","messageId":"222","endLine":1076,"endColumn":62},{"ruleId":"219","severity":1,"message":"241","line":1084,"column":62,"nodeType":"221","messageId":"222","endLine":1084,"endColumn":64},{"ruleId":"187","severity":1,"message":"251","line":1260,"column":11,"nodeType":"189","messageId":"190","endLine":1260,"endColumn":21},{"ruleId":"187","severity":1,"message":"252","line":1261,"column":15,"nodeType":"189","messageId":"190","endLine":1261,"endColumn":28},{"ruleId":"187","severity":1,"message":"253","line":1262,"column":15,"nodeType":"189","messageId":"190","endLine":1262,"endColumn":26},{"ruleId":"219","severity":1,"message":"220","line":1269,"column":70,"nodeType":"221","messageId":"222","endLine":1269,"endColumn":72},{"ruleId":"187","severity":1,"message":"252","line":1286,"column":15,"nodeType":"189","messageId":"190","endLine":1286,"endColumn":28},{"ruleId":"187","severity":1,"message":"253","line":1287,"column":15,"nodeType":"189","messageId":"190","endLine":1287,"endColumn":26},{"ruleId":"219","severity":1,"message":"220","line":1295,"column":70,"nodeType":"221","messageId":"222","endLine":1295,"endColumn":72},{"ruleId":"202","severity":1,"message":"254","line":1428,"column":8,"nodeType":"204","endLine":1428,"endColumn":10,"suggestions":"255"},{"ruleId":"187","severity":1,"message":"242","line":1442,"column":15,"nodeType":"189","messageId":"190","endLine":1442,"endColumn":23},{"ruleId":"187","severity":1,"message":"243","line":1465,"column":11,"nodeType":"189","messageId":"190","endLine":1465,"endColumn":21},{"ruleId":"219","severity":1,"message":"220","line":1477,"column":66,"nodeType":"221","messageId":"222","endLine":1477,"endColumn":68},{"ruleId":"219","severity":1,"message":"220","line":1773,"column":60,"nodeType":"221","messageId":"222","endLine":1773,"endColumn":62},{"ruleId":"219","severity":1,"message":"220","line":1850,"column":69,"nodeType":"221","messageId":"222","endLine":1850,"endColumn":71},{"ruleId":"187","severity":1,"message":"256","line":1,"column":17,"nodeType":"189","messageId":"190","endLine":1,"endColumn":26},{"ruleId":"187","severity":1,"message":"257","line":1,"column":17,"nodeType":"189","messageId":"190","endLine":1,"endColumn":25},{"ruleId":"187","severity":1,"message":"258","line":16,"column":18,"nodeType":"189","messageId":"190","endLine":16,"endColumn":25},{"ruleId":"187","severity":1,"message":"259","line":17,"column":12,"nodeType":"189","messageId":"190","endLine":17,"endColumn":19},{"ruleId":"187","severity":1,"message":"260","line":17,"column":21,"nodeType":"189","messageId":"190","endLine":17,"endColumn":31},{"ruleId":"187","severity":1,"message":"257","line":1,"column":16,"nodeType":"189","messageId":"190","endLine":1,"endColumn":24},{"ruleId":"187","severity":1,"message":"206","line":1,"column":26,"nodeType":"189","messageId":"190","endLine":1,"endColumn":35},"no-native-reassign",["261"],"no-negated-in-lhs",["262"],"no-unused-vars","'colorButtons' is assigned a value but never used.","Identifier","unusedVar","'io' is defined but never used.","'Board' is defined but never used.","'done' is assigned a value but never used.","'setDone' is assigned a value but never used.","'winner' is assigned a value but never used.","'message' is assigned a value but never used.","'players' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'buttonsTarget', 'color', 'random', 'socket', and 'stopRealTimer'. Either include them or remove the dependency array.","ArrayExpression",["263"],"'useEffect' is defined but never used.","'useRef' is defined but never used.","'faPaperPlane' is defined but never used.","React Hook useEffect has missing dependencies: 'online' and 'socket'. Either include them or remove the dependency array.",["264"],"React Hook useEffect has missing dependencies: 'currentMove', 'newVirtualBoard', 'nextMoves', 'prevButtons', and 'prevMoves'. Either include them or remove the dependency array. You can also do a functional update 'setPrevMoves(p => ...)' if you only need 'prevMoves' in the 'setPrevMoves' call.",["265"],"no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","React Hook useEffect has a missing dependency: 'computerMoveFirst'. Either include it or remove the dependency array.",["266"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'HEIGHT' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'downTimer', 'onlineGame', and 'upTimer'. Either include them or remove the dependency array.",["267"],["268"],"'OnlineSocket' is defined but never used.","'SQUARES' is assigned a value but never used.","'currentTotalCoords' is assigned a value but never used.","'setCurrentTotalCoords' is assigned a value but never used.","'setVirtualBoard' is assigned a value but never used.","'oldChildren' is assigned a value but never used.","'player1Color' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'x' is assigned a value but never used.","'y' is assigned a value but never used.","'cloneIcon' is assigned a value but never used.","'newPiece' is assigned a value but never used.","'oppositeKingSquare' is assigned a value but never used.","'getContainers' is assigned a value but never used.","Array.prototype.filter() expects a value to be returned at the end of arrow function.","'totalIdx' is assigned a value but never used.","'checkCheck' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'currentMove', 'newVirtualBoard', 'pieceCapture', 'pieceSound', 'socket', and 'stopTimer'. Either include them or remove the dependency array. If 'stopTimer' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["269"],["270"],"React Hook useEffect has a missing dependency: 'newVirtualBoard'. Either include it or remove the dependency array.",["271"],["272"],"'isKing' is assigned a value but never used.","'isAttacked' is assigned a value but never used.","'computerPiece' is assigned a value but never used.","'playerPiece' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'computerMoveFirst' and 'setColor'. Either include them or remove the dependency array.",["273"],"'Component' is defined but never used.","'useState' is defined but never used.","'setLang' is assigned a value but never used.","'content' is assigned a value but never used.","'setContent' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"274","fix":"275"},{"desc":"276","fix":"277"},{"desc":"278","fix":"279"},{"desc":"280","fix":"281"},{"desc":"282","fix":"283"},{"desc":"278","fix":"284"},{"desc":"285","fix":"286"},{"desc":"278","fix":"287"},{"desc":"288","fix":"289"},{"desc":"290","fix":"291"},{"desc":"280","fix":"292"},"Update the dependencies array to be: [buttonsTarget, color, numberOfPlayers, random, socket, stopRealTimer]",{"range":"293","text":"294"},"Update the dependencies array to be: [online, socket]",{"range":"295","text":"296"},"Update the dependencies array to be: [currentMove, newVirtualBoard, nextMoves, prevButtons, prevMoves, random]",{"range":"297","text":"298"},"Update the dependencies array to be: [computerMoveFirst, setColor]",{"range":"299","text":"300"},"Update the dependencies array to be: [stopTimer, players, downTimer, upTimer, onlineGame]",{"range":"301","text":"302"},{"range":"303","text":"298"},"Update the dependencies array to be: [currentMove, newVirtualBoard, pieceCapture, pieceSound, sendPiece, socket, stopTimer]",{"range":"304","text":"305"},{"range":"306","text":"298"},"Update the dependencies array to be: [choosePiece, newVirtualBoard]",{"range":"307","text":"308"},"Update the dependencies array to be: [deleteIcon, newVirtualBoard]",{"range":"309","text":"310"},{"range":"311","text":"300"},[3656,3673],"[buttonsTarget, color, numberOfPlayers, random, socket, stopRealTimer]",[1091,1093],"[online, socket]",[7168,7176],"[currentMove, newVirtualBoard, nextMoves, prevButtons, prevMoves, random]",[57910,57920],"[computerMoveFirst, setColor]",[6785,6805],"[stopTimer, players, downTimer, upTimer, onlineGame]",[6773,6781],[63243,63254],"[currentMove, newVirtualBoard, pieceCapture, pieceSound, sendPiece, socket, stopTimer]",[6543,6551],[7062,7075],"[choosePiece, newVirtualBoard]",[7538,7550],"[deleteIcon, newVirtualBoard]",[60445,60447]]